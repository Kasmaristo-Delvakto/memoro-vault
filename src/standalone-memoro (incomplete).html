<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Memoro Vault — Single File (All Pages)</title>

  <!-- Bring your real CSS/JS here -->
  <!-- <link rel="stylesheet" href="app.css"> -->
  <!-- <script defer src="app.js"></script> -->

<style>
:root{
  --bg:#000;
  --fg:#00ff99;
  --fg-strong:#0f0;
  --border:#00ff99;
  --border-dim:rgba(0,255,153,.28);

  --panel:#111;
  --radius:12px;
  --radius-xs:8px;

  --gap:clamp(12px,2.4vw,22px);
  --pad:clamp(14px,2.6vw,26px);
  --pad-lg:clamp(18px,3vw,30px);
}

/* ---------- Base ---------- */
*{ box-sizing:border-box; }
html,body{ height:100%; }
body{
  margin:0;
  /* safe-area aware breathing room */
  padding-block:
    max(env(safe-area-inset-top), clamp(18px, 5dvh, 64px))
    max(env(safe-area-inset-bottom), clamp(18px, 6dvh, 72px));
  padding-inline: max(16px, clamp(14px, 5vw, 28px));

  background:var(--bg);
  color:var(--fg);
  font-family:"Fira Code", monospace;

  /* Vertically center the landing content */
  min-height:100dvh;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  /* When there are 2+ vault cards, stop centering so the page scrolls normally */
body:has(.vault-list .vault-item:nth-of-type(2)){
  justify-content: flex-start;
}

/* Let the browser scroll all the way to the hero without clipping */
html{
  scroll-padding-top: max(20px, env(safe-area-inset-top));
}
}

/* When there are 2+ vault cards, stop centering so the page scrolls normally */
body:has(.vault-list .vault-item:nth-of-type(2)){
  justify-content: flex-start;
  min-height: auto; /* allow the page to grow taller than the viewport */
}

/* Let the browser scroll all the way to the hero without clipping */
html{
  scroll-padding-top: max(20px, env(safe-area-inset-top));
}

/* Canvas layers */
canvas{ position:fixed; inset:0; z-index:-2; }
#matrixCanvas{ position:fixed; inset:0; width:100vw; height:100vh; z-index:-3; }
.matrix-overlay{ position:fixed; inset:0; background:rgba(0,0,0,.82); z-index:-2; }

/* ---------- Typography (bigger, fluid) ---------- */
h1,h2,h3{ margin:0; line-height:1.12; }
h1{ 
  color: var(--fg-strong);       /* neon green, same as "Offline Mode Recommended" */
  font-size: clamp(36px, 7vw, 64px); 
  letter-spacing: .02em; 
  font-weight: 700;              /* make it bold */
}
h2{ color:var(--fg-strong);  font-size:clamp(20px, 3vw, 30px); }
h3{ color:var(--fg-strong);  font-size:clamp(18px, 2.6vw, 24px); }
p { color:var(--fg); text-align:center; font-size:clamp(16px, 2.2vw, 20px); margin:0; }

/* ---------- Typewriter Hero ---------- */
.mv-hero{
  display:flex; flex-direction:column; align-items:center; text-align:center;
  gap:10px; margin-top:6px; margin-bottom:12px;
}
.typewriter-text{
  display:inline-block; overflow:hidden; white-space:nowrap;
  border-right:2px solid transparent; color:transparent;
  animation:
    revealText 0s forwards,
    typing 2s steps(40,end) forwards .05s,
    blink-caret .75s step-end 7 2s forwards;
}
@keyframes revealText{ 
  to{ 
    color: var(--fg-strong);           /* neon green for main header */
    border-right-color: var(--fg-strong);
  } 
}

@keyframes typing{ 
  from{ width:0 } 
  to{ width:100% } 
}

@keyframes blink-caret{ 
  0%,100%{ border-color: transparent; } 
  50%{ border-color: var(--fg-strong); }  /* caret blinks neon */
}

/* Buttons fade in after typing */
.button-group{ opacity:0; transform:translateY(6px); animation:fadeInUp .5s ease-out forwards; animation-delay:3.5s; }
@keyframes fadeInUp{ from{opacity:0; transform:translateY(10px);} to{opacity:1; transform:none;} }

/* ---------- Buttons (touch-friendly) ---------- */
.button,
.modal-buttons button,
.unlock-button,
.three-dots{
  background:#111; color:var(--fg);
  border:1px solid var(--border);
  border-radius:var(--radius-xs);
  padding:14px 22px;
  font-size:clamp(15px, 1.8vw, 19px);
  cursor:pointer;
  transition:transform .12s, box-shadow .16s, background .18s;
  box-shadow:0 0 6px var(--fg);
}
.button:hover,
.modal-buttons button:hover,
.unlock-button:hover{ background:#1a1a1a; transform:translateY(-1px); }
.button:focus-visible{ outline:0; box-shadow:0 0 0 3px rgba(0,255,153,.3); }
.button:active{ transform:translateY(0); }
.button[disabled]{ opacity:.5; filter:grayscale(100%); cursor:not-allowed; }

/* Keep real buttons from squishing; fill their grid track */
.button,
.modal-buttons button,
.unlock-button{ min-width:240px; width:100%; min-height:48px; }

/* ---------- CTA row ---------- */
.button-group{
  display:grid; gap:16px 18px;
  justify-content:center; align-content:center;
  margin:18px auto 0; padding:16px 18px;
  background:rgba(0,255,153,.05);
  border:1px solid var(--border-dim);
  border-radius:18px;
  width:auto; max-width:96vw;
}
/* 1×4 row — wide screens */
@media (min-width:1100px){
  .button-group{ grid-template-columns:repeat(4, minmax(240px, max-content)); }
}
/* 2×2 grid — medium screens */
@media (min-width:600px) and (max-width:1099px){
  .button-group{ grid-template-columns:repeat(2, minmax(240px, 1fr)); }
}
/* 1×N column — small screens */
@media (max-width:599px){
  .button-group{ grid-template-columns:1fr; }
}

/* ---------- Vault Grid ---------- */
.vault-list{
  width:min(900px,100%);
  display:grid; grid-template-columns:repeat(auto-fit, minmax(280px,1fr));
  gap:var(--gap); margin-top:26px;
}
.vault-item{
  background:var(--panel);
  border:1px solid var(--border-dim);
  border-radius:var(--radius);
  padding:var(--pad-lg);
  display:flex; flex-direction:column; gap:10px;
  box-shadow:0 0 14px rgba(0,255,153,.12);
}
.vault-item h2{ font-size:clamp(20px, 2.2vw, 24px); color:#b9ffd9; }
.vault-item p { font-size:clamp(14px, 1.9vw, 17px); color:#b9ffd9; text-align:left; }

/* ---------- Modals ---------- */
.modal-overlay{
  display:none; position:fixed; inset:0; z-index:9999;
  background:rgba(0,0,0,.78);
  align-items:center; justify-content:center; padding:20px;
}
.modal{
  background:#111; color:var(--fg);
  width:92%; max-width:520px;
  padding:40px 32px 28px;
  border:1px solid var(--border); border-radius:12px;
  box-shadow:0 0 16px rgba(0,255,153,.18);
  max-height:calc(100vh - 80px); overflow-y:auto;
  display:flex; flex-direction:column; gap:16px; text-align:center;
}
.modal h2{ font-size:clamp(22px, 3.2vw, 28px); color:var(--fg-strong); }
.modal p { font-size:clamp(14px, 2.1vw, 18px); line-height:1.6; }
.modal input{
  width:100%; padding:12px 14px; min-height:46px;
  border-radius:8px; border:1px solid var(--border);
  background:#000; color:var(--fg);
  font-family:"Fira Code", monospace; font-size:16px;
}
.modal-buttons{ display:flex; flex-wrap:wrap; gap:12px; justify-content:center; }

/* ---------- Paper Decrypt — narrow-screen ergonomics ---------- */
#paperDecryptModal{ align-items:center; justify-content:center; padding:12px; }
#paperDecryptModal .modal{
  width:min(720px,100%);
  max-height:90dvh; overflow:auto; box-sizing:border-box;
}
#paperProgressHost{ width:100%; }
#paperStatus{ font-size:14px; line-height:1.35; }
#paperCam{
  width:100%; max-height:42dvh; object-fit:contain;
  background:#000; border-radius:8px;
}

/* ---------- Scrollbars ---------- */
*::-webkit-scrollbar{ width:10px; height:10px; }
*::-webkit-scrollbar-thumb{ background:linear-gradient(#00ff99,#0b7f55); border-radius:10px; }
*::-webkit-scrollbar-track{ background:#0d0d0d; }

/* Frame container stays safe-area aware */
.ui-frame{
  position:fixed;
  inset:
    max(10px, env(safe-area-inset-top))
    max(10px, env(safe-area-inset-right))
    max(12px, env(safe-area-inset-bottom))
    max(10px, env(safe-area-inset-left));
  pointer-events:none;
  z-index:5000;
}
@media (max-width:599px){
  .ui-frame{
    inset:
      max(8px, env(safe-area-inset-top))
      max(8px, env(safe-area-inset-right))
      max(12px, env(safe-area-inset-bottom))
      max(8px, env(safe-area-inset-left));
  }
}
.ui-frame-svg{ width:100%; height:100%; display:block; }

/* The animated border */
.ui-frame-path{
  fill:transparent;
  stroke:var(--border);
  stroke-width:1.6;
  filter:url(#neonGlow);

  /* trace-on */
  stroke-dasharray:1000;
  stroke-dashoffset:1000;
  animation:
    drawFrame 4s linear forwards,        /* 0→4s: outline draws in */
    neonPulse 4s ease-in-out 4s infinite;/* 4s+: soft breathing glow */
}

/* optional soft inner/outer radiance using a pseudo ring */
.ui-frame::after{
  content:"";
  position:absolute; inset:0;
  border-radius:16px;
  box-shadow:
    0 0 0 1px rgba(0,255,153,.22),
    inset 0 0 18px rgba(0,255,153,.16),
    0 0 22px rgba(0,255,153,.18);
  pointer-events:none;
  opacity:.0;
  animation: frameHalo 4s linear forwards; /* fade halo in as line draws */
}

/* animations */
@keyframes drawFrame { to { stroke-dashoffset:0; } }
@keyframes neonPulse {
  0%,100% { opacity:.9; stroke-width:1.6; }
  50%     { opacity:1;  stroke-width:2.2; }
}
@keyframes frameHalo { to { opacity:1; } }

/* Accessibility: respect reduced motion */
@media (prefers-reduced-motion: reduce){
  .ui-frame-path{
    animation:none;
    stroke-dasharray:none; stroke-dashoffset:0;
  }
  .ui-frame::after{ animation:none; opacity:1; }
}

/* tighter on small screens */
@media (max-width:599px){
  .ui-frame{
    inset:
      max(8px, env(safe-area-inset-top))
      max(8px, env(safe-area-inset-right))
      max(12px, env(safe-area-inset-bottom))
      max(8px, env(safe-area-inset-left));
    border-radius:14px;
  }
}

/* Keep the last row clear of the neon frame */
body::after{
  content:"";
  display:block;
  /* room for the frame + glow + safe area */
  height: max(36px, calc(env(safe-area-inset-bottom) + 26px));
}

/* small extra breathing room below the grid */
.vault-list{ margin-bottom: 12px; }

/* ===== Mobile tweaks ===== */
@media (max-width:599px){
  /* reduce side padding a touch */
body{ padding-inline: max(14px, clamp(14px, 6vw, 22px)); }

  /* larger headline on small phones for presence */
  h1{ font-size:clamp(34px, 9vw, 60px); }
  h2{ font-size:clamp(20px, 4.6vw, 28px); }
  p { font-size:clamp(15px, 3.8vw, 18px); }

  .button, .modal-buttons button, .unlock-button{
    min-height:50px; border-radius:12px; font-size:16px;
    box-shadow:0 0 0 1px rgba(0,255,153,.12), 0 6px 14px rgba(0,0,0,.45);
  }

  /* make inner “card” invisible if you still use .app-shell */
  .app-shell{
    background:transparent; border:none; box-shadow:none; backdrop-filter:none; padding:0;
  }

  .modal-overlay{ padding:12px; }
  .modal{ max-height:92dvh; padding:28px 20px 22px; border-radius:14px; }
}

/* ===== Tablet scale-up ===== */
@media (600px <= width <= 900px){
  .app-shell{ width:min(640px,100%); border-radius:18px; }
}
</style>

</head>
<body>

  <!-- =======================
       PAGE: INDEX (Landing)
       ======================= -->
  <section id="page-index" class="page" aria-current="page">
    <div class="content">
      <img src="assets/memoro-logo-with-words.png"
           alt="Memoro Vault Logo"
           style="max-width: 300px; height: auto; margin-bottom: 20px;" />
      <p id="mainText"></p>
      <button onclick="showSafetyModal()" id="startBtn">Begin</button>
    </div>

    <div id="safetyModal" class="modal" style="display:none;">
      <div class="modal-content">
        <h2>Before You Begin</h2>
        <ul>
          <li>Use a clean, trusted computer.</li>
          <li>Disconnect from WiFi or turn off internet access.</li>
          <li>Close unnecessary apps and browsers.</li>
          <li>Do not use public or shared computers.</li>
          <li>Ensure no suspicious browser extensions are installed.</li>
        </ul>
        <div class="modal-buttons">
          <button onclick="acceptSafety()">I Understand</button>
        </div>
      </div>
    </div>

    <script>
      function showSafetyModal() {
        document.getElementById('safetyModal').style.display = 'flex';
      }
      function typeWriterEffect(text, element, delay = 30, callback = null) {
        let i = 0; element.innerText = "";
        (function type(){ if(i<text.length){ element.innerText+=text.charAt(i++); setTimeout(type,delay);} else if(callback){callback();} })();
      }
      function acceptSafety() {
        typeWriterEffect("Welcome_to_Memoro_Vault", document.getElementById('mainText'), 40, () => {
          showPage('dashboard');
        });
      }
    </script>
  </section>

  <!-- =======================
       PAGE: DASHBOARD (canonical IDs)
       ======================= -->
  <section id="page-dashboard" class="page" aria-current="false">
    <div class="ui-frame" aria-hidden="true"></div>

    <input type="file" id="vaultZipInput" accept=".zip" style="display:none;" onchange="handleVaultZip(event)">

    <div style="display: flex; justify-content: center;">
      <h1><span class="typewriter-text" style="animation-delay: 0s;">Memoro Vault</span></h1>
    </div>
    <div style="position: relative; width: 100%; display: flex; justify-content: center;">
      <p class="typewriter-text" style="animation-delay: 1.3s; margin-bottom: 0.3em; pointer-events: none;">What matters most.</p>
    </div>
    <div style="position: relative; width: 100%; display: flex; justify-content: center;">
      <p class="typewriter-text" style="animation-delay: 2.5s; margin-top: 0; pointer-events: none;">Hidden in plain sight.</p>
    </div>

    <div class="button-group">
      <button class="button" style="animation-delay: 3.5s;" onclick="promptOfflineWarning('create')">+ Create New Vault</button>
      <button class="button" style="animation-delay: 5.5s;" onclick="promptOfflineWarning('load')">Load Vault File</button>
      <button class="button" style="animation-delay: 7.5s;" onclick="showPage('how')">How Memoro Works</button>
      <button class="button" style="animation-delay: 9.5s;" onclick="showPage('recover')">Recover Vault</button>
    </div>

    <div class="vault-list" id="vaultList"></div>

    <!-- Unlock Vault Modal -->
    <div class="modal-overlay" id="unlockModal">
      <div class="modal">
        <h2>Unlock Vault</h2>
        <h3 id="question1Label"></h3>
        <input type="text" id="answer1Input" placeholder="Answer 1">
        <h3 id="question2Label"></h3>
        <input type="text" id="answer2Input" placeholder="Answer 2">
        <div id="lockoutSection" style="display:none; width:100%; margin-top:10px; text-align:center;">
          <p id="lockoutTimerText" style="margin:5px 0; font-size:16px; color:#ccc;">Locked for 15s</p>
          <div style="background-color:#444; width:100%; height:10px; border-radius:5px; overflow:hidden;">
            <div id="lockoutProgress" style="background-color:#00ff99; width:100%; height:10px;"></div>
          </div>
        </div>
        <div class="modal-buttons">
          <button id="unlockButton" onclick="submitUnlock()">Unlock</button>
          <button onclick="cancelUnlock()">Cancel</button>
        </div>
      </div>
    </div>

    <!-- Offline Warning Modal -->
    <div class="modal-overlay" id="offlineWarning">
      <div class="modal">
        <h2>Offline Mode Recommended</h2>
        <p>We recommend disabling your internet connection temporarily for maximum security.</p>
        <div class="modal-buttons">
          <button onclick="proceedAfterOfflineWarning()">Continue</button>
          <button onclick="cancelOfflineWarning()">Cancel</button>
        </div>
      </div>
    </div>

    <!-- Message Modal (canonical) -->
    <div class="modal-overlay" id="messageModal">
      <div class="modal">
        <h2 id="messageModalTitle">Title</h2>
        <p id="messageModalText">Message goes here.</p>
        <div class="modal-buttons">
          <button onclick="closeMessageModal()">OK</button>
        </div>
      </div>
    </div>

    <!-- Confirm Modal -->
    <div class="modal-overlay" id="confirmModal">
      <div class="modal">
        <h2>Confirm</h2>
        <p id="confirmModalText">Are you sure?</p>
        <div class="modal-buttons">
          <button onclick="confirmNo()">No</button>
          <button onclick="confirmYes()">Yes</button>
        </div>
      </div>
    </div>

    <!-- Rename Vault Modal -->
    <div class="modal-overlay" id="renameModal">
      <div class="modal">
        <h2>Rename Vault</h2>
        <input type="text" id="renameInput" placeholder="New vault name">
        <div class="modal-buttons">
          <button onclick="submitRename()">Rename</button>
          <button onclick="cancelRename()">Cancel</button>
        </div>
      </div>
    </div>

    <!-- Paper Decrypt Modal -->
    <div class="modal-overlay" id="paperDecryptModal">
      <div class="modal" style="max-width: 720px;">
        <h2>Restore Physical Backup</h2>
        <p style="white-space: normal; text-align:left;">
          Upload the full PDF or individual page images. We’ll extract:<br>
          • 1× <code>MVKEY</code> (single key QR)<br>
          • 1× <code>MVHDR</code> (header) and all <code>MVCT</code> tiles (ciphertext)<br>
          Then we rebuild <code>memoro-lite.zip</code>.
        </p>
        <input id="paperFiles" type="file" accept=".pdf,image/*" multiple style="width:100%; margin-bottom:12px;">
        <div style="width:100%; border:1px solid #0f0; padding:10px; border-radius:8px; margin:8px 0;">
          <h3 style="margin:0 0 8px 0;">Scan Key Shares (Optional)</h3>
          <p style="margin:0 0 8px 0; font-size:14px; color:#ccc;">Aim camera at an MVKEY QR (one at a time).</p>
          <video id="paperCam" playsinline style="width:100%; max-height:240px; background:#000; display:none;"></video>
          <div class="modal-buttons" style="gap:8px;">
            <button onclick="startKeyCam()">Start Camera</button>
            <button onclick="stopKeyCam()">Stop Camera</button>
            <button onclick="scanFromVideoOnce()">Scan Key</button>
          </div>
        </div>
        <div id="paperStatus" style="width:100%; text-align:left; font-size:14px; color:#ccc;"></div>
        <div class="modal-buttons" style="margin-top:10px;">
          <button onclick="closePaperDecrypt()">Close</button>
          <button id="rebuildBtn" onclick="rebuildLiteFromPaper()" disabled>Rebuild Lite ZIP</button>
        </div>
      </div>
    </div>

    <!-- Canonical dashboard canvas & overlay -->
    <canvas id="matrix"></canvas>
    <div class="overlay"></div>

    <!-- Dashboard CTAs to flows -->
    <div class="button-group" style="margin-top:24px;">
      <button class="button" onclick="showPage('create')">Create Vault (Choose Count)</button>
      <button class="button" onclick="showPage('setup')">Setup Questions</button>
      <button class="button" onclick="showPage('answers')">Answer Questions</button>
      <button class="button" onclick="showPage('build')">Build Vault</button>
    </div>
  </section>

  <!-- =======================
       PAGE: HOW IT WORKS
       ======================= -->
  <section id="page-how" class="page" aria-current="false">
    <canvas id="matrixHow"></canvas>
    <div class="overlay" id="overlay-how"></div>

    <div class="content">
      <h1>How Memoro Vault Works</h1>

      <h2>TL;DR</h2>
      <p>Memoro Vault is an offline, self-contained encryption tool… (text preserved from your paste).</p>

      <h2>Why Memoro Vault Is Necessary</h2>
      <p>In the digital age… (text preserved).</p>

      <h2>How the Encryption Works</h2>
      <p>When you build a vault… (text preserved).</p>

      <h2>Red Herrings and Required Order</h2>
      <p>To further strengthen security… (text preserved).</p>

      <h2>File and Vault Integrity</h2>
      <p>Every file inside the vault… (text preserved).</p>

      <h2>Physical Backups Using QR Codes</h2>
      <p>Memoro Vault also supports… (text preserved).</p>

      <h2>Practical Applications</h2>
      <p>Memoro Vault can safeguard… (text preserved).</p>

      <p><strong>There are no backdoors and no exceptions.</strong> … (text preserved).</p>

      <div class="button-container">
        <button class="button" onclick="backToDashboard()">Return to Dashboard</button>
      </div>
    </div>
  </section>

  <!-- =======================
       PAGE: CREATE (choose count)
       ======================= -->
  <section id="page-create" class="page" aria-current="false">
    <canvas id="matrixCreate"></canvas>
    <div class="overlay" id="overlay-create"></div>

    <div class="content">
      <h1>Select the number of security questions</h1>
      <div class="slider-section">
        <span id="questionCount">14</span>
        <input type="range" id="questionSlider" min="4" max="25" value="14" oninput="updateQuestionCount()" />
      </div>

      <div class="button-container">
        <button class="button" onclick="backToDashboard()">← Back</button>
        <button class="button" onclick="startVaultSetup()">Next</button>
      </div>
    </div>
  </section>

  <!-- =======================
       PAGE: SETUP QUESTIONS
       ======================= -->
  <section id="page-setup" class="page" aria-current="false">
    <canvas id="matrixSetup"></canvas>
    <div class="matrix-overlay" id="matrix-overlay-setup"></div>

    <h1>Setup Your Security Questions</h1>
    <p class="instruction">
      You can use the default questions or edit them.<br>
      Select exactly <b>two</b> questions to act as your first line of defense.
      <br>
      <a href="#" onclick="openHelpModal()" style="color:#00ff99; text-decoration: underline; font-size: 15px;">How does unlocking work?</a>
    </p>

    <!-- Help Modal (setup-specific) -->
    <div id="helpModal" class="modal" style="display:none;">
      <div class="modal-content">
        <h2>How Unlocking Works</h2>
        <p style="text-align: left; color: #ccc; font-size: 15px; line-height: 1.6;">
          (content preserved)
        </p>
        <div class="modal-buttons">
          <button onclick="closeHelpModal()">Close</button>
        </div>
      </div>
    </div>

    <div class="question-list" id="questionList"></div>

    <div class="button-container">
      <button class="button" onclick="backToDashboard()">Back</button>
      <button class="button" onclick="showDisclaimer()">Continue</button>
    </div>

    <!-- Edit Question Modal -->
    <div id="editModal" class="modal" style="display:none;">
      <div class="modal-content">
        <h2>Edit Question</h2>
        <div style="margin-bottom: 10px;">
          <input type="text" id="editInput">
        </div>
        <div style="margin-top: 20px; margin-bottom: 15px;">
          <label style="font-size:16px; color:#00ff99; font-family:'Fira Code', monospace;">Suggestions:</label>
          <select id="categoryDropdown">
            <option value="">-- Select Category --</option>
            <option value="home">Home</option>
            <option value="family">Family</option>
            <option value="life">Life Events</option>
            <option value="Pets">Pets</option>
            <option value="favorites">Favorites</option>
            <option value="random">Random</option>
            <option value="school">School</option>
            <option value="career">Career</option>
            <option value="travel">Travel</option>
            <option value="hobbies">Hobbies</option>
            <option value="special">Special Memories</option>
          </select>
        </div>
        <div id="suggestionsList" style="max-height: 150px; overflow-y: auto; margin-bottom:15px;"></div>
        <div class="modal-buttons">
          <button onclick="saveModalEdit()">Save</button>
          <button onclick="closeModal()">Cancel</button>
        </div>
      </div>
    </div>

    <!-- Disclaimer Modal (setup-specific) -->
    <div id="disclaimerModal" class="modal" style="display:none;">
      <div class="modal-content">
        <h2>Before You Continue</h2>
        <p style="font-size:16px; color:#ccc; margin-top: 15px; margin-bottom: 20px;">
          (content preserved)
        </p>
        <div class="modal-buttons">
          <button onclick="proceedToAnswers()">I Understand — Continue</button>
        </div>
      </div>
    </div>
  </section>

  <!-- =======================
       PAGE: ANSWER QUESTIONS
       ======================= -->
  <section id="page-answers" class="page" aria-current="false">
    <canvas id="matrixAnswers" style="position: fixed; top:0; left:0; width:100vw; height:100vh; z-index:0; background:black;"></canvas>

    <h1>Answer Your Questions and Upload Files</h1>
    <div id="countdown"></div>

    <form class="question-form" id="answerForm"></form>
    <div id="extraSeedsSection" style="margin-top: 30px; width: 100%; max-width: 900px;"></div>

    <div id="totalEntropyContainer" style="margin: 30px auto 0; width: fit-content; text-align: center; border: 1px solid #0f0; padding: 12px 24px; border-radius: 8px; background-color: #111; box-shadow: 0 0 8px #0f0;">
      <p style="font-size: 16px; color: #ccc;">
        Estimated Vault Strength:
        <span id="totalEntropyBits" style="color:#00ff99;">0.0</span> bits —
        <span id="entropyAssessment" style="color:#ff3333;">Very Weak</span>
        <br>
        <span style="color:#ccc; font-size: 14px;">Total Combinations: <span id="totalCombinations" style="color:#00ff99;">0</span></span>
        <span style="color:#aaa; font-size: 13px;">
          Estimated Crack Time: <span id="estimatedCrackTime" style="color:#ff9933;">Instantly crackable</span><br>
          <em style="color:#777;">(assuming 1 trillion guesses/sec)</em>
        </span>
        <br>
        <span id="crackabilityTier" style="display: block; margin-top: 8px; font-size: 14px; color: #ff3333;"></span>
        <span style="color: #888; font-size: 13px; display: block; margin-top: 4px;">
          This estimation does not factor in phishing or social engineering.
        </span>
      </p>
    </div>

    <details style="margin-top: 30px; color: #0f0;">
      <summary style="cursor: pointer; font-size: 16px;">What is entropy and how is my vault protected?</summary>
      <div style="margin-top: 15px; font-size: 15px; color: #ccc; line-height: 1.6;">
        (entropy section preserved)
      </div>
    </details>

    <!-- Multi-seed input -->
    <div id="multiSeedSection" style="margin-top: 40px; width: 100%; max-width: 900px;">
      <h2 style="color:#0f0;">Saved Seed or Password Files</h2>
      <div class="input-group">
        <label for="newSeedName">Seed File/Password Name:</label>
        <input type="text" id="newSeedName" placeholder="e.g. Primary Wallet" />
      </div>
      <div class="input-group" style="margin-top:10px;">
        <label for="newSeedContent">Seed Phrase or Password:</label>
        <textarea id="newSeedContent" rows="3" placeholder="type or paste seed phrase or private passphrase here"></textarea>
      </div>
      <button class="button" type="button" onclick="saveNamedSeed()">Save Password/Seed File</button>
      <div id="namedSeedsList" style="margin-top: 20px;"></div>
    </div>

    <div class="input-group" style="margin-top: 40px; width: 100%; max-width: 900px;">
      <label for="fileUpload" style="font-size: 18px;">Optional: Upload Documents to Include in Your Vault</label>
      <div style="display: flex; align-items: center; gap: 12px;">
        <input type="file" id="fileUpload" multiple hidden />
        <label for="fileUpload" id="fileUploadLabel">Choose Files</label>
        <span id="fileUploadStatus" style="color: #0f0; font-size: 16px;">No files uploaded</span>
      </div>
      <p style="font-size: 14px; color: #aaa; margin-top: 5px;">You can upload text, images, videos, or scans.</p>
    </div>

    <div id="uploadedFileList" style="margin-top: 20px; width: 100%; max-width: 900px;"></div>

    <div class="input-group" style="margin-top: 40px; width: 100%; max-width: 900px;">
      <label for="finalMessage" style="font-size: 18px;">Optional: Final Message for Yourself or Your Family</label>
      <textarea id="finalMessage" rows="4" placeholder="Example: 'Looks like someone was ACTUALLY listening…'"></textarea>
      <p style="font-size: 14px; color: #aaa; margin-top: 5px;">This message will be stored securely with your vault.</p>
    </div>

    <div class="button-container">
      <button class="button" type="button" onclick="showPage('setup')">← Back</button>
      <button class="button" type="button" onclick="submitAnswers()">Create Vault</button>
      <button class="button" type="button" onclick="startSecurityTimer()">Reset Timer</button>
    </div>

    <!-- Hint Modal (answers-specific, unique id) -->
    <div id="hintModalAnswers" class="modal" style="display:none;">
      <div class="modal-content">
        <h2>Hint Options</h2>
        <div class="input-group" style="margin-bottom: 14px;">
          <label><input type="checkbox" id="showLength" checked> Show answer length during unlock</label>
        </div>
        <div class="input-group">
          <label>Reveal specific letters from the answer</label>
          <select id="numLetters" onchange="buildLetterSelectors()"></select>
        </div>
        <div id="letterSelectors" class="input-group" style="margin-top: 15px;"></div>
        <div class="input-group" style="margin-top: 20px;">
          <label>Optional: Custom Hint Text</label>
          <textarea id="customHintText" rows="2" placeholder="Example: 'At the park'..."></textarea>
        </div>
        <div class="modal-buttons">
          <button onclick="saveCustomHint()">Save</button>
          <button onclick="document.getElementById('hintModalAnswers').style.display='none'">Cancel</button>
        </div>
      </div>
    </div>
  </section>

  <!-- =======================
       PAGE: BUILD VAULT
       ======================= -->
  <section id="page-build" class="page" aria-current="false">
    <canvas id="matrixBuild"></canvas>

    <div id="vaultContainer">
      <!-- Keep one canvas per page; removed duplicates -->
      <div id="mainContainer">
        <img id="memoroLogo" src="assets/memoro-logo-with-words.png" alt="Memoro Vault Logo" />

        <div id="progressBarWrapper">
          <div class="progress-label" id="progressLabel">Initializing vault builder...</div>
          <div class="progress-bar-container">
            <div class="progress-bar-fill" id="progressFill">
              <!-- 20 blocks -->
              <div class="progress-block"></div><div class="progress-block"></div><div class="progress-block"></div>
              <div class="progress-block"></div><div class="progress-block"></div><div class="progress-block"></div>
              <div class="progress-block"></div><div class="progress-block"></div><div class="progress-block"></div>
              <div class="progress-block"></div><div class="progress-block"></div><div class="progress-block"></div>
              <div class="progress-block"></div><div class="progress-block"></div><div class="progress-block"></div>
              <div class="progress-block"></div><div class="progress-block"></div><div class="progress-block"></div>
              <div class="progress-block"></div><div class="progress-block"></div>
            </div>
          </div>
        </div>

        <div id="actionButtons">
          <button onclick="preserveAndGoBack()">Back to Answers</button>
          <button onclick="retryDownload()">Retry Download</button>
          <button onclick="backToDashboard()">Return to Dashboard</button>
        </div>
      </div>

      <div id="powPanel" class="pow-panel">
        <div class="pow-panel-wrapper"></div>
      </div>
    </div>

    <!-- Final Instructions Modal -->
    <div id="postBuildModal" style="display:none; position: fixed; inset: 0; background: rgba(0,0,0,0.96); z-index: 5000; color: #0f0; font-family: 'Fira Code', monospace; padding: 40px; box-sizing: border-box; overflow-y: auto;">
      <div style="max-width: 800px; width: 100%; border: 1px solid #0f0; padding: 30px; background: #000; box-shadow: 0 0 20px #0f0; margin: auto;">
        <h2 style="color: #00ff99; text-shadow: 0 0 10px #0f0;">Please Read Carefully</h2>
        <p>Your Memoro Vault has been successfully built and downloaded.</p>
        <p>Bit rot… (content preserved)</p>
        <h3 style="margin-top: 25px; color: #88ffcc;">What to Do Next</h3>
        <ol style="margin-left: 20px;">
          <li>Create a folder …</li>
          <li>Place both of the following …</li>
          <li><strong>Duplicate that folder …</strong></li>
          <li><strong>Create a paper backup …</strong></li>
          <li>Test access on another device …</li>
          <li>Repeat when you update …</li>
        </ol>
        <h3 style="margin-top: 25px; color: #88ffcc;">Why M-DISC?</h3>
        <p>(content preserved)</p>
        <h3 style="margin-top: 25px; color: #88ffcc;">Final Advice</h3>
        <ul style="margin-left: 20px;">
          <li>Do <strong>not</strong> rely on a single copy.</li>
          <li>Do <strong>not</strong> trust cloud providers to exist forever.</li>
          <li>Do <strong>not</strong> assume your future self will remember every step.</li>
        </ul>
        <p>A copy of these instructions is also included as <code>Vault_Builder_Instructions.txt</code>.</p>
        <div style="text-align: center; margin-top: 30px;">
          <button onclick="closePostBuildModal()" style="padding: 10px 20px; font-size: 14px; background: #111; border: 1px solid #0f0; color: #0f0; cursor: pointer;">Got it</button>
        </div>
      </div>
    </div>

    <!-- Lite Picker Modal -->
    <div id="litePickerModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.96); z-index:6000; color:#0f0; font-family:'Fira Code',monospace; overflow-y:auto; padding:16px 0;">
      <div style="max-width:600px; margin:40px auto; border:1px solid #0f0; background:#000; box-shadow:0 0 20px #0f0; max-height:calc(100vh - 80px); overflow:auto; border-radius:10px;">
        <div style="padding:18px 22px; border-bottom:1px solid #0f0; display:flex; align-items:center; gap:10px;">
          <h2 style="margin:0; color:#00ff99;">Choose what to include in your Paper Backup (≤ 150 KB)</h2>
        </div>
        <div style="display:flex; flex-wrap:wrap; gap:22px; padding:22px;">
          <div style="flex:1 1 380px; min-width:300px;">
            <h3 style="margin:0 0 10px 0; color:#88ffcc;">Seeds & Final Message</h3>
            <div id="liteSeedsList" style="border:1px solid #0f0; padding:10px; border-radius:8px; max-height:220px; overflow:auto;"></div>
            <div style="margin-top:18px;">
              <label style="display:flex; align-items:center; gap:8px;">
                <input id="litePickFinalMsg" type="checkbox" />
                <span>Include final message (as <code>final-message.txt</code>)</span>
              </label>
            </div>
            <h3 style="margin:18px 0 10px 0; color:#88ffcc;">Uploads</h3>
            <div id="liteUploadsList" style="border:1px solid #0f0; padding:10px; border-radius:8px; max-height:280px; overflow:auto;"></div>
          </div>
          <div style="flex:1 1 260px; min-width:240px;">
            <h3 style="margin:0 0 10px 0; color:#88ffcc;">Summary</h3>
            <div style="border:1px solid #0f0; border-radius:8px; padding:12px;">
              <div style="margin-bottom:8px;">Total selected (raw): <strong id="liteTotalBytes">0</strong> bytes</div>
              <div style="font-size:12px; color:#b8ffd9;">Limit: 153,600 bytes (≈ 150 KB).</div>
              <hr style="border:none; border-top:1px solid #0f0; margin:12px 0;">
              <div id="litePickerError" style="color:#ff6; min-height:18px;"></div>
              <div style="display:flex; gap:10px; margin-top:10px;">
                <button id="litePickerConfirm" style="background:#0f0; color:#000; border:1px solid #0f0; padding:10px 14px; border-radius:6px; cursor:pointer;">Build Paper Backup</button>
                <button id="litePickerCancel" style="background:#111; border:1px solid #0f0; color:#0f0; padding:10px 14px; border-radius:6px; cursor:pointer;">Cancel</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- =======================
       PAGE: RECOVER (integrated earlier)
       ======================= -->
  <section id="page-recover" class="page" aria-current="false">
    <h1>Recover Your Vault</h1>

    <div class="button-container">
      <button class="button" onclick="backToDashboard()">Return to Dashboard</button>
    </div>

    <form class="recovery-form" id="recoveryForm"></form>

    <div class="button-container">
      <button class="button" onclick="submitRecovery()">Recover Vault</button>
    </div>

    <div id="seedModal" class="modal" style="display:none;">
      <div class="modal-content">
        <div class="pow-section">
          <div class="donation-heading">Support Memoro Vault</div>
          <img src="assets/Screenshot (691).png" alt="Monero Donation QR"
               style="margin-top: 10px; width: 150px; border: 2px solid #0f0; border-radius: 8px; box-shadow: 0 0 8px #0f0;">
          <p style="color: #00ff99; font-family: 'Fira Code', monospace; font-size: 15px; line-height: 1.6; text-shadow: 0 0 6px #00ff99; margin: 10px 0;">
            <span style="font-weight: bold;">Thanks for using Memoro Vault.</span><br>
            If you find it valuable, consider sending a small tip in XMR or your preferred cryptocurrency.
          </p>
          <button onclick="window.memoroAPI?.openExternalLink && window.memoroAPI.openExternalLink('https://trocador.app/en/anonpay/?ticker_to=xmr&network_to=Mainnet&address=83czGNh6SKbhmjg3wPzeiDRQbN7gkLLqTYSvfMGRQRmKQf1SyQTG88Db67NoBdEvpCii6Qzcxq3BxNt94FDeJutmJ3xBXc6&donation=True&amount=0.1&name=Kasmaristo+Delvakto&description=Memoro+Vault+is+funded+by+donations+only.+Thanks+for+your+support!&ticker_from=xmr&network_from=Mainnet&bgcolor=')"
                  style="background-color: #111; color: #0f0; border: 1px solid #0f0; padding: 8px 16px; border-radius: 6px; cursor: pointer;">
            Donate with preferred crypto
          </button>
          <div style="display: flex; flex-direction: column; align-items: center; gap: 12px; margin-top: 16px;">
            <p style="font-size: 13px; color: #0f0; margin: 0;">Offline? Paste it into your browser later.</p>
            <button onclick="copyDonationLink()"
                    style="background-color: #111; color: #0f0; border: 1px solid #0f0; padding: 8px 16px; border-radius: 6px; cursor: pointer;">
              Copy Donation Link
            </button>
          </div>
        </div>

        <div class="pow-section">
          <h2 style="font-size: 28px; color: #00ff99; text-align: center; text-shadow: 0 0 8px #00ff99; font-family: 'Fira Code', monospace; margin-bottom: 10px;">
            Vault Recovered!
          </h2>
          <pre id="recoveredSeed" style="white-space: pre-wrap; color: #0f0; margin-top: 10px;"></pre>
          <pre id="finalMessage" style="white-space: pre-wrap; color: #88ff88; margin-top: 15px;"></pre>
          <div class="modal-buttons">
            <button onclick="closeSeedModal()">Return to Dashboard</button>
          </div>
        </div>
      </div>
    </div>

    <div id="previewModal" class="modal" style="display:none;">
      <div class="modal-content">
        <h2>File Preview</h2>
        <div id="previewContent" style="margin-top: 20px;"></div>
        <div class="modal-buttons">
          <button onclick="closePreview()">Close</button>
        </div>
      </div>
    </div>

    <div id="powOverlay" style="display:none;">
      <div id="powMessage">Checking answers... please wait</div>
      <div id="powTerminal"></div>
      <div class="progress-label">Processing...</div>
      <div class="progress-bar-container">
        <div class="progress-bar-fill" id="progressBar"></div>
      </div>
    </div>

    <div id="redHerringModal" class="modal" style="display:none;">
      <div class="modal-content">
        <h2 style="color:#00ff99; margin-bottom: 20px; text-shadow: 0 0 10px #00ff99;">Pay Attention Before You Begin</h2>
        <p style="font-size: 16px; line-height: 1.7; color: #00ff99;">
          One of these questions might be a <span style="color: #88ffcc;">Red Herring</span> — leave it blank.
        </p>
        <div class="modal-buttons">
          <button onclick="closeRedHerringModal()">Got it</button>
        </div>
      </div>
    </div>

    <canvas id="matrixRecover"></canvas>
    <div class="overlay" id="overlay-recover"></div>
    <div id="vaultCrackOverlay"></div>
    <div id="crackOverlay"></div>
    <div id="burstFlash"></div>
    <div id="toast"></div>
  </section>

  <!-- =======================
       ROUTER & BASIC STUBS
       ======================= -->
  <script>
    // Router
    function showPage(name) {
      document.querySelectorAll('.page').forEach(p => {
        const on = (p.id === 'page-' + name);
        p.setAttribute('aria-current', on ? 'page' : 'false');
        p.style.display = on ? 'block' : 'none';
      });
    }
    function backToDashboard() { showPage('dashboard'); }
</script>

<script>
const loadedVaults = {};
let currentUnlockVaultId = null;
let nextAction = null;
let confirmYesCallback = null;
let countdownInterval = null;
let failedAttempts = 0;
let lockoutUntil = 0;

  // Message Modal
  function showMessageModal(title, message) {
  document.getElementById('messageModalTitle').innerText = title;
  document.getElementById('messageModalText').innerText = message;
  document.getElementById('messageModal').style.display = 'flex';
}
function closeMessageModal() {
  document.getElementById('messageModal').style.display = 'none';
}

  // Confirm Modal
  function showConfirmModal(message, yesCallback) {
    document.getElementById('confirmModalText').innerText = message;
    document.getElementById('confirmModal').style.display = 'flex';
    confirmYesCallback = yesCallback;
  }

  function confirmNo() {
    document.getElementById('confirmModal').style.display = 'none';
    confirmYesCallback = null;
  }

  function confirmYes() {
    document.getElementById('confirmModal').style.display = 'none';
    if (typeof confirmYesCallback === 'function') {
      confirmYesCallback();
      confirmYesCallback = null;
    }
  }

function saveVaultsToLocalStorage() {
  try {
    const index = Object.entries(loadedVaults).map(([vaultId, v]) => ({
      vaultId,
      fileName: v.fileName || 'Memoro Vault',
      // keep minimal metadata for display/restoration
      createdAt: Date.now(),
    }));
    localStorage.setItem('memoroVaultIndex', JSON.stringify(index));
    // no huge binary here — that’s what IndexedDB is for
  } catch (err) {
    console.error('❌ Failed to write vault index to localStorage:', err);
  }
}

  function loadVaultsFromLocalStorage() {
  const saved = localStorage.getItem('savedVaults');
  if (!saved) return;

  const vaultArray = JSON.parse(saved);
  vaultArray.forEach(({ vaultId, fileName, vaultData }) => {
    loadFilesFromIndexedDB(vaultId).then(fileMapRaw => {
      const reconstructedMap = {};
      const reconstructedRaw = {};

      for (const [name, fileObj] of Object.entries(fileMapRaw || {})) {
        const blob = new Blob([new Uint8Array(fileObj.data)], { type: fileObj.type });
        reconstructedMap[name] = blob;
        reconstructedRaw[name] = {
          type: fileObj.type,
          data: fileObj.data
        };
      }

      loadedVaults[vaultId] = {
        fileName,
        vaultData,
        fileMap: reconstructedMap,
        fileMapRaw: reconstructedRaw
      };

      addVaultToList(vaultId, fileName, vaultData, true);
    }).catch(err => {
      console.error(`Failed to load fileMapRaw for vault ${vaultId}:`, err);
      showMessageModal("Load Error", `Could not load vault files for "${fileName}".`);
    });
  });
}

  function addVaultToList(vaultId, fileName, vaultData, skipSaving = false) {
    const vaultList = document.getElementById('vaultList');
    const vaultItem = document.createElement('div');
    vaultItem.className = 'vault-item';
    vaultItem.id = vaultId;
    vaultItem.innerHTML = `
      <div style="width:100%; display:flex; justify-content:space-between; align-items:center;">
        <h2 id="title-${vaultId}" style="margin:0;">${fileName}</h2>
        <div style="position:relative;">
          <button class="three-dots" onclick="toggleMenu('${vaultId}')">⋮</button>
          <div class="vault-menu" id="menu-${vaultId}">
            <button onclick="renameVault('${vaultId}')">Rename</button>
            <button onclick="deleteVault('${vaultId}')">Delete</button>
          </div>
        </div>
      </div>
      <p>Status:Locked</p>
      <button class="unlock-button" onclick="openUnlockModal('${vaultId}')">Unlock Vault</button>
    `;
    vaultList.appendChild(vaultItem);
    if (!skipSaving) {
  saveVaultsToLocalStorage();
}
  }

  function toggleMenu(vaultId) {
    const menu = document.getElementById(`menu-${vaultId}`);
    menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
    document.querySelectorAll('.vault-menu').forEach(m => {
      if (m.id !== `menu-${vaultId}`) m.style.display = 'none';
    });
  }

  let currentRenameVaultId = null;

  function renameVault(vaultId) {
    currentRenameVaultId = vaultId;
    const vault = loadedVaults[vaultId];
    if (!vault) {
      showMessageModal('Error', 'Vault not found.');
      return;
    }
    document.getElementById('renameInput').value = vault.fileName;
    document.getElementById('renameModal').style.display = 'flex';
  }

  function cancelRename() {
    currentRenameVaultId = null;
    document.getElementById('renameModal').style.display = 'none';
  }

  function submitRename() {
    const newName = document.getElementById('renameInput').value.trim();
    if (!newName) {
      showMessageModal('Missing Name', 'Please enter a new name.');
      return;
    }
    if (currentRenameVaultId && loadedVaults[currentRenameVaultId]) {
      loadedVaults[currentRenameVaultId].fileName = newName;
      document.getElementById(`title-${currentRenameVaultId}`).innerText = newName;
      saveVaultsToLocalStorage();
    }
    cancelRename();
  }

  function deleteVault(vaultId) {
    showConfirmModal('Are you sure you want to delete this vault?', () => {
      delete loadedVaults[vaultId];
      document.getElementById(vaultId).remove();
      saveVaultsToLocalStorage();
    });
  }

  function openUnlockModal(vaultId) {
  clearInterval(countdownInterval);

  currentUnlockVaultId = vaultId;
  const vault = loadedVaults[vaultId];
  const prompts = vault.vaultData.questionPrompts || ["Question 1:", "Question 2:"];

  document.getElementById('question1Label').innerText = prompts[0];
  document.getElementById('question2Label').innerText = prompts[1];

  document.getElementById('answer1Input').value = '';
  document.getElementById('answer2Input').value = '';
  document.getElementById('answer1Input').disabled = false;
  document.getElementById('answer2Input').disabled = false;

  document.getElementById('lockoutSection').style.display = 'none';
  document.getElementById('lockoutProgress').style.width = '100%';

  const unlockButton = document.getElementById('unlockButton');
  unlockButton.disabled = false;
  unlockButton.textContent = 'Unlock';

  document.getElementById('unlockModal').style.display = 'flex';
  setTimeout(() => document.getElementById('answer1Input').focus(), 100);

  failedAttempts = Number(localStorage.getItem(`failedAttempts_${vaultId}`)) || 0;
  lockoutUntil = Number(localStorage.getItem(`lockoutUntil_${vaultId}`)) || 0;
  checkIfLocked();
}

function cancelUnlock() {
  currentUnlockVaultId = null;
  document.getElementById('unlockModal').style.display = 'none';
  clearInterval(countdownInterval);
}


function checkIfLocked() {
  if (Date.now() < lockoutUntil) {
    startCountdown();
  }
}

function startCountdown() {
  clearInterval(countdownInterval);
  const now = Date.now();
  const totalTime = lockoutUntil - now;
  const lockoutSection = document.getElementById('lockoutSection');
  const timerText = document.getElementById('lockoutTimerText');
  const progressBar = document.getElementById('lockoutProgress');
  const unlockButton = document.getElementById('unlockButton');

  lockoutSection.style.display = 'block';
  document.getElementById('answer1Input').disabled = true;
  document.getElementById('answer2Input').disabled = true;
  unlockButton.disabled = true;
  unlockButton.textContent = 'Locked';

  countdownInterval = setInterval(() => {
    const nowInner = Date.now();
    const remaining = lockoutUntil - nowInner;

    if (remaining <= 0) {
      clearInterval(countdownInterval);
      document.getElementById('answer1Input').disabled = false;
      document.getElementById('answer2Input').disabled = false;
      lockoutSection.style.display = 'none';
      unlockButton.disabled = false;
      unlockButton.textContent = 'Unlock';
      return;
    }

    const seconds = Math.ceil(remaining / 1000);
    timerText.innerText = `Locked for ${seconds}s`;

    const percent = (remaining / totalTime) * 100;
    progressBar.style.width = `${percent}%`;
  }, 200);
}

  function promptOfflineWarning(action) {
    nextAction = action;
    document.getElementById('offlineWarning').style.display = 'flex';
  }

  function proceedAfterOfflineWarning() {
  document.getElementById('offlineWarning').style.display = 'none';
  if (nextAction === 'create') {
    window.location.href = "create-vault.html";
  } else if (nextAction === 'load') {
    document.getElementById('vaultZipInput').click(); // ✅ THIS IS MISSING
  }
  nextAction = null;
}

  function cancelOfflineWarning() {
    document.getElementById('offlineWarning').style.display = 'none';
    nextAction = null;
  }

  function goToHowItWorks() {
    window.location.href = "how-it-works.html";
  }

async function handleVaultZip(event) {
  const file = event.target.files?.[0];
  if (!file || !file.name.toLowerCase().endsWith('.zip')) {
    showMessageModal('Invalid File', 'Please select a valid .zip vault file.');
    return;
  }

  const vaultId  = 'vault-' + Date.now();
  const fileName = file.name.replace(/\.zip$/i, '');

  let zipReader;
  try {
    // Open without materializing the whole thing
    zipReader = new zip.ZipReader(new zip.BlobReader(file));

    // Read central directory
    const entries = await zipReader.getEntries();

    // Helper to find an entry by (case-insensitive) name
    const find = (n) => entries.find(e => e.filename.toLowerCase() === n);

    const eJson = find('vault.json');
    const eEnc  = find('vault.enc');
    const eMeta = find('vault.meta');

    if (!eJson || !eEnc || !eMeta) {
      throw new Error('ZIP is missing one or more required files: vault.json, vault.enc, vault.meta');
    }

    // Extract only what we need, and do it efficiently
    // vault.json → text
    const vaultJsonBlob = await eJson.getData(new zip.BlobWriter('application/json'));
    const vaultData     = JSON.parse(await vaultJsonBlob.text());

    // vault.enc → bytes (leave as Uint8Array)
    const vaultEncBlob = await eEnc.getData(new zip.BlobWriter('application/octet-stream'));
    const vaultEncU8   = new Uint8Array(await vaultEncBlob.arrayBuffer());

    // vault.meta → bytes
    const vaultMetaBlob = await eMeta.getData(new zip.BlobWriter('application/octet-stream'));
    const vaultMetaU8   = new Uint8Array(await vaultMetaBlob.arrayBuffer());

    // Build minimal in‑memory structures (no full file map mirror)
    const fileMap = {
      'vault.json': vaultJsonBlob,
      'vault.enc':  new Blob([vaultEncU8], { type: 'application/octet-stream' }),
      'vault.meta': new Blob([vaultMetaU8], { type: 'application/octet-stream' }),
    };

    // Raw (compact) representation — keep Uint8Array, not big JS arrays
    const fileMapRaw = {
      'vault.json': { type: 'application/json',              data: new TextEncoder().encode(JSON.stringify(vaultData)) },
      'vault.enc':  { type: 'application/octet-stream',      data: vaultEncU8 },
      'vault.meta': { type: 'application/octet-stream',      data: vaultMetaU8 },
    };

    // Keep a handle to the original ZIP for pass‑through to recover.html
    loadedVaults[vaultId] = {
      fileName,
      vaultData,
      fileMap,
      fileMapRaw,
      zipBlob: file
    };

    // Persist the heavy bits in IndexedDB (not localStorage)
    await saveFilesToIndexedDB(vaultId, {
      'vault.json': { type: 'application/json',         data: fileMapRaw['vault.json'].data },
      'vault.enc':  { type: 'application/octet-stream', data: fileMapRaw['vault.enc'].data  },
      'vault.meta': { type: 'application/octet-stream', data: fileMapRaw['vault.meta'].data },
    });

    // Add to UI (and store only lightweight metadata in localStorage)
    addVaultToList(vaultId, fileName, vaultData);
    saveVaultsToLocalStorage(); // this will now write only small metadata

    showMessageModal('Success', 'Vault imported successfully!');

  } catch (err) {
    console.error('ZIP Load Error:', err);
    showMessageModal('Load Failed', err.message || 'Could not load the vault ZIP file.');
  } finally {
    try { await zipReader?.close(); } catch {}
    // Reset the file input so selecting the same file again re‑fires change
    event.target.value = '';
  }
}
</script>


<script>
async function deriveKey(password, saltHex = null, vaultData = null) {
  const encoder = new TextEncoder();
  const passwordBytes = encoder.encode(password);
  const salt = saltHex 
    ? Uint8Array.from(saltHex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)))
    : new Uint8Array(await crypto.subtle.digest("SHA-256", passwordBytes));

  const settings = vaultData?.argonSettings || {
    time: 10,
    mem: 65536,
    parallelism: 4,
    type: "Argon2id",
    hashLen: 32
  };

  const argonResult = await argon2.hash({
    pass: password,
    salt,
    time: settings.time,
    mem: settings.mem,
    parallelism: settings.parallelism,
    type: argon2.ArgonType[settings.type] || argon2.ArgonType.Argon2id,
    hashLen: settings.hashLen || 32
  });

  const keyBytes = new Uint8Array(argonResult.hash);
  return crypto.subtle.importKey(
    "raw",
    keyBytes,
    { name: "AES-GCM" },
    false,
    ["encrypt", "decrypt"]
  );
}

async function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function decryptAES(ciphertextArray, ivArray, key) {
  try {
    const iv = new Uint8Array(ivArray);
    const ciphertext = new Uint8Array(ciphertextArray);

    const decryptedBuffer = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      ciphertext
    );

    const decoded = new TextDecoder().decode(decryptedBuffer);

    // ✅ Ensure full JSON was returned for large payloads
    if (!decoded.startsWith('{') || !decoded.endsWith('}')) {
      throw new Error("Decryption returned incomplete JSON. Data may be too large or corrupted.");
    }

    return decoded;
  } catch (err) {
    console.error("❌ Decryption failed:", err);
    throw new Error("Decryption failed: Incorrect key or corrupted vault.enc.");
  }
}

async function submitUnlock() {
  if (Date.now() < lockoutUntil) return;

  const answer1 = document.getElementById('answer1Input').value.trim().toLowerCase();
  const answer2 = document.getElementById('answer2Input').value.trim().toLowerCase();

  if (!answer1 || !answer2) {
    showMessageModal('Missing Answers', 'Please answer both questions.');
    return;
  }

  const vault = loadedVaults[currentUnlockVaultId];
  if (!vault || !vault.vaultData || !vault.fileMapRaw || !vault.zipBlob) {
    showMessageModal('Vault Error', 'Vault is missing required data.');
    return;
  }

  const vaultEncRaw = vault.fileMapRaw["vault.enc"];
  const vaultMetaRaw = vault.fileMapRaw["vault.meta"];
  if (!vaultEncRaw || !vaultEncRaw.data|| !vaultMetaRaw || !vaultMetaRaw.data) {
    showMessageModal('Vault Error', 'Required encrypted files are missing or incomplete.');
    return;
  }

  try {
    console.log("🔑 Unlock attempt with answers:", answer1, answer2);

    const vaultData = vault.vaultData;
    const layer1Salt = vaultData.layer1Salt;
    if (!layer1Salt) {
      throw new Error("Vault metadata is incomplete: layer1Salt not found.");
    }

    const vaultEncText = new TextDecoder().decode(Uint8Array.from(vaultEncRaw.data));
    const vaultEncJson = JSON.parse(vaultEncText);
    const { ciphertext, iv } = vaultEncJson;

    const aesKey = await deriveKey(answer1 + answer2, layer1Salt, vaultData);

    const decryptedBuffer = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv: new Uint8Array(iv) },
      aesKey,
      new Uint8Array(ciphertext)
    );
    const decrypted = new TextDecoder().decode(decryptedBuffer);
    const fullVaultData = JSON.parse(decrypted);

    // Inject metadata
    fullVaultData.finalMessageIv = vaultData.finalMessageIv || null;
    fullVaultData.vaultMetaIv = vaultData.vaultMetaIv;

    // Serialize fileMap
    const serializedMap = {};
    for (const [filename, blob] of Object.entries(vault.fileMap)) {
      const buffer = await blob.arrayBuffer();
      serializedMap[filename] = {
        type: blob.type || 'application/octet-stream',
        data: Array.from(new Uint8Array(buffer))
      };
    }

    // ✅ Use the original imported ZIP blob
    const vaultBlob = new Uint8Array(await vault.zipBlob.arrayBuffer());
    if (vaultBlob.length === 0) throw new Error("Original vault ZIP blob is empty.");

    const transferObject = {
      vaultJson: vaultData,
      decryptedVaultData: fullVaultData,
      baseKey: answer1 + answer2,
      fileMapRaw: serializedMap,
      vaultEncRaw,
      vaultMetaRaw,
      vaultId: currentUnlockVaultId,
      fullSalt: vaultData.fullSalt,
      vaultBlob: vaultBlob.buffer
    };

    // Save to IndexedDB
    await new Promise((resolve, reject) => {
      const req = indexedDB.open("memoroVaultVaultStorage", 1);
      req.onupgradeneeded = function (event) {
        const db = event.target.result;
        if (!db.objectStoreNames.contains("vaultFiles")) {
          db.createObjectStore("vaultFiles", { keyPath: "vaultId" });
        }
      };
      req.onsuccess = function (event) {
        const db = event.target.result;
        const tx = db.transaction("vaultFiles", "readwrite");
        const store = tx.objectStore("vaultFiles");

        store.put({ vaultId: currentUnlockVaultId + "-transfer", data: transferObject });

        tx.oncomplete = () => {
          console.log("📦 IndexedDB write completed:", currentUnlockVaultId + "-transfer");
          resolve();
        };
        tx.onerror = (e) => reject("❌ IndexedDB write error: " + e.target.error.message);
      };
      req.onerror = (e) => reject("❌ Failed to open IndexedDB: " + e.target.error.message);
    });

    // Reset lockout state
    clearInterval(countdownInterval);
    localStorage.removeItem(`failedAttempts_${currentUnlockVaultId}`);
    localStorage.removeItem(`lockoutUntil_${currentUnlockVaultId}`);
    localStorage.setItem("lastVaultId", currentUnlockVaultId);

    await delay(500); // Optional delay

    window.location.href = "recover.html";
  } catch (err) {
    console.warn("❌ Unlock failed:", err.message);
    failedAttempts++;
    const lockDelay = 15000 * Math.pow(2, failedAttempts - 1);
    lockoutUntil = Date.now() + lockDelay;

    localStorage.setItem(`failedAttempts_${currentUnlockVaultId}`, failedAttempts);
    localStorage.setItem(`lockoutUntil_${currentUnlockVaultId}`, lockoutUntil);

    showMessageModal("Unlock Failed", `Incorrect answers. Attempts: ${failedAttempts}`);
    startCountdown();
  }
}

// Expose globally
window.submitUnlock = submitUnlock;
  // Expose to global scope for onclick handler
  window.submitUnlock = submitUnlock;

window.addEventListener("DOMContentLoaded", () => {
  sessionStorage.removeItem("memoroTransfer");
  Object.keys(loadedVaults).forEach(key => delete loadedVaults[key]); // 💥 flush stale in-memory blobs
  loadVaultsFromLocalStorage();  // 🧠 this rehydrates cleanly from saved localStorage
});

// 🧼 Force input to lowercase as user types
document.addEventListener("input", (e) => {
  if (e.target.id === "answer1Input" || e.target.id === "answer2Input") {
    e.target.value = e.target.value.toLowerCase();
  }
});

function saveFilesToIndexedDB(vaultId, fileMapRaw, transferObject = null) {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open("memoroVaultVaultStorage", 1);
    req.onupgradeneeded = function (event) {
      const db = event.target.result;
      if (!db.objectStoreNames.contains("vaultFiles")) {
        db.createObjectStore("vaultFiles", { keyPath: "vaultId" });
      }
    };
    req.onsuccess = function (event) {
      const db = event.target.result;
      const tx = db.transaction("vaultFiles", "readwrite");
      const store = tx.objectStore("vaultFiles");

      // Always store fileMapRaw for dashboard hydration
      store.put({ vaultId, fileMapRaw });
      console.log("Saved fileMapRaw for vaultId:", vaultId);

      // Store transfer object if provided
      if (transferObject) {
        store.put({ vaultId: vaultId + "-transfer", ...transferObject });
        console.log("Saved transfer object for vaultId:", vaultId + "-transfer");
      }

      tx.oncomplete = () => {
        console.log("IndexedDB transaction completed for vaultId:", vaultId);
        resolve();
      };
      tx.onerror = (e) => {
        console.error("IndexedDB transaction error:", e.target.error);
        reject("IndexedDB write failed: " + e.target.error.message);
      };
    };
    req.onerror = (e) => reject("Failed to open IndexedDB: " + e.target.error.message);
  });
}

function loadFilesFromIndexedDB(vaultId) {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open("memoroVaultVaultStorage", 1);
    req.onsuccess = function (event) {
      const db = event.target.result;
      const tx = db.transaction("vaultFiles", "readonly");
      const store = tx.objectStore("vaultFiles");
      const getReq = store.get(vaultId);
      getReq.onsuccess = () => resolve(getReq.result?.fileMapRaw || {});
      getReq.onerror = () => reject("Failed to retrieve vault file blobs.");
    };
    req.onerror = () => reject("IndexedDB load failed.");
  });
}

</script>

<canvas id="matrixCanvas"></canvas>
<div class="matrix-overlay"></div>

<script>
  const canvas = document.getElementById("matrixCanvas");
  const ctx = canvas.getContext("2d");

  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890@$%&'.split('');
  const fontSize = 14;
  const columns = Math.floor(canvas.width / fontSize);
  const drops = Array(columns).fill(0);

  function drawMatrix() {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#00ff99';
    ctx.font = `${fontSize}px monospace`;

    for (let i = 0; i < drops.length; i++) {
      const text = letters[Math.floor(Math.random() * letters.length)];
      ctx.fillText(text, i * fontSize, drops[i] * fontSize);
      drops[i]++;
      if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
        drops[i] = 0;
      }
    }
  }

  setInterval(drawMatrix, 66); // ~15fps like "How It Works"
  window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  });

  document.addEventListener('click', (e) => {
  const menus = document.querySelectorAll('.vault-menu');
  const isMenuButton = e.target.classList.contains('three-dots');

  // If clicked outside all menus and not the ⋮ button, hide all
  if (!isMenuButton && !e.target.closest('.vault-menu')) {
    menus.forEach(menu => menu.style.display = 'none');
  }
});

async function nukeEverything() {
  try {
    localStorage.clear();
    sessionStorage.clear();
    if (indexedDB.databases) {
      const dbs = await indexedDB.databases();
      for (const db of dbs) {
        indexedDB.deleteDatabase(db.name);
      }
    } else {
      indexedDB.deleteDatabase("memoroVaultVaultStorage");
      indexedDB.deleteDatabase("memoroVaultDB");
    }
    console.log("Memoro Vault: Local memory wiped.");
  } catch (err) {
    console.warn("Memoro Vault wipe failed:", err);
  }
}

// ==============================
// Memoro Physical Backup — Dashboard
// Scans MVKEY (hex), MVHDR (b64(JSON)), MVCT tiles → reassembles memoro-lite.zip
// ==============================

// ---------- State & element refs ----------
const paperState = {
  header: null,            // { v, iv:number[], size:number, sha256:string }
  keyHex: null,            // 64 hex chars (32 bytes)
  tiles: {},               // { 1: "b64...", 2: "b64...", ... }
  totalTiles: null,        // integer
  seenPayloads: new Set(), // dedupe across PDF & camera (raw strings)
};

const paperEls = {
  modal:      () => document.getElementById('paperDecryptModal'),
  files:      () => document.getElementById('paperFiles'),
  status:     () => document.getElementById('paperStatus'),
  barHost:    () => document.getElementById('paperProgressHost'),
  barText:    () => document.getElementById('paperProgressText'),
  bar:        () => document.getElementById('paperProgressBar'),
  rebuildBtn: () => document.getElementById('rebuildBtn') || document.getElementById('rebuildLiteBtn'),
  camVideo:   () => document.getElementById('paperCam'),
};

// ========== PDF scanner (robust 3-col, KEY+HEADER+CT) ==========
async function scanPdfFile(file) {
  const buf = new Uint8Array(await file.arrayBuffer());
  const pdf = await pdfjsLib.getDocument({ data: buf }).promise;

  // ---- Layout constants (match builder) ----
  const COLS_PT   = 3;    // 3 columns in the paper backup
  const MARGIN_PT = 24;
  const GAP_PT    = 12;
  const LABEL_PT  = 14;
  const BANNER_PT = 72;

  // crop inflation (tolerance for render differences)
  const PAD_PCT   = 0.10; // 10% padding around each tile box

  // Prefer native BD, then ZXing polyfill, then jsQR
  const hasNativeBD = 'BarcodeDetector' in window && String(BarcodeDetector).indexOf('Polyfill') === -1;
  const BD_NATIVE   = hasNativeBD ? new BarcodeDetector({ formats: ['qr_code'] }) : null;
  const BD_ZXING    = (typeof window.BarcodeDetectorPolyfill === 'function')
    ? new window.BarcodeDetectorPolyfill({ formats: ['qr_code'] })
    : null;

  async function decodeCanvas(sub) {
    // Native
    if (BD_NATIVE) {
      try {
        const bmp = await createImageBitmap(sub);
        const codes = await BD_NATIVE.detect(bmp);
        if (codes?.length) return codes.map(c => (c.rawValue || '').trim()).filter(Boolean);
      } catch {}
    }
    // ZXing polyfill
    if (BD_ZXING) {
      try {
        const bmp = await createImageBitmap(sub);
        const codes = await BD_ZXING.detect(bmp);
        if (codes?.length) return codes.map(c => (c.rawValue || '').trim()).filter(Boolean);
      } catch {}
    }
    // jsQR fallback
    try {
      const sctx = sub.getContext('2d', { willReadFrequently: true });
      const img  = sctx.getImageData(0, 0, sub.width, sub.height);
      const qr   = jsQR(img.data, sub.width, sub.height, { inversionAttempts: 'attemptBoth' });
      if (qr?.data) return [qr.data.trim()];
    } catch {}
    return [];
  }

  async function decodeRegion(srcCanvas, x, y, w, h) {
    // clamp & round
    x = Math.max(0, Math.floor(x));
    y = Math.max(0, Math.floor(y));
    w = Math.max(1, Math.floor(Math.min(srcCanvas.width  - x, w)));
    h = Math.max(1, Math.floor(Math.min(srcCanvas.height - y, h)));

    const sub = document.createElement('canvas');
    sub.width = w; sub.height = h;
    const sctx = sub.getContext('2d', { willReadFrequently: true });
    sctx.imageSmoothingEnabled = false;
    sctx.drawImage(srcCanvas, x, y, w, h, 0, 0, w, h);
    return decodeCanvas(sub);
  }

  // Track found CT indices while scanning
  const haveCT = () => Object.keys(paperState.tiles || {}).length || 0;

  for (let p = 1; p <= pdf.numPages; p++) {
    const page = await pdf.getPage(p);

    // Use the page's own point size; compute scale in X and Y separately
    // (Some PDFs render at slightly non-uniform scales.)
    const raw = page.view; // [xMin, yMin, xMax, yMax] in pt
    const pageWpt = (raw?.[2] ?? 612) - (raw?.[0] ?? 0); // Letter is 612x792 pt
    const pageHpt = (raw?.[3] ?? 792) - (raw?.[1] ?? 0);

    const viewport = page.getViewport({ scale: 4.0 }); // ~288 dpi for crisp QR
    const canvas = document.createElement('canvas');
    canvas.width = Math.floor(viewport.width);
    canvas.height = Math.floor(viewport.height);
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    ctx.imageSmoothingEnabled = false;
    await page.render({ canvasContext: ctx, viewport }).promise;

    const Wpx = canvas.width, Hpx = canvas.height;
    const sx = Wpx / pageWpt;
    const sy = Hpx / pageHpt;

    // Compute centered 3-col layout *in points*, then map to px
    const innerWpt = pageWpt - 2 * MARGIN_PT;
    const tilePt   = Math.floor((innerWpt - GAP_PT * (COLS_PT - 1)) / COLS_PT);
    const usedWpt  = COLS_PT * tilePt + (COLS_PT - 1) * GAP_PT;
    const startXpt = MARGIN_PT + Math.floor((innerWpt - usedWpt) / 2);

    const rowHeightPt = LABEL_PT + tilePt;

    function toPxX(pt) { return pt * sx; }
    function toPxY(pt) { return pt * sy; }

    async function cropAndDecodePt(xPt, yPt, wPt, hPt, tag) {
      // Inflate by PAD_PCT in *pixels* after mapping to px
      let x = toPxX(xPt), y = toPxY(yPt), w = toPxX(wPt), h = toPxY(hPt);
      const padX = w * PAD_PCT, padY = h * PAD_PCT;
      x -= padX; y -= padY; w += padX * 2; h += padY * 2;
      const vals = await decodeRegion(canvas, x, y, w, h);
      for (const v of vals) ingestQR(v, tag);
      return vals.length > 0;
    }

    // ----- Deterministic pass: each expected cell -----
    let rowsScanned = 0;
    for (let yPt = MARGIN_PT + BANNER_PT + LABEL_PT;
         yPt + tilePt <= pageHpt - MARGIN_PT;
         yPt += rowHeightPt) {

      for (let c = 0; c < COLS_PT; c++) {
        const xPt = startXpt + c * (tilePt + GAP_PT);

        if (p === 1 && rowsScanned === 0) {
          // First row of page 1: KEY | HEADER | CT 1
          if (c === 0) { await cropAndDecodePt(xPt, yPt, tilePt, tilePt, 'pdf-key'); }
          else if (c === 1) { await cropAndDecodePt(xPt, yPt, tilePt, tilePt, 'pdf-hdr'); }
          else { await cropAndDecodePt(xPt, yPt, tilePt, tilePt, 'pdf-ct'); }
        } else {
          await cropAndDecodePt(xPt, yPt, tilePt, tilePt, 'pdf-ct');
        }
      }
      rowsScanned++;

      // Early stop if we have everything
      if (paperState.header && paperState.keyHex &&
          paperState.totalTiles && haveCT() >= paperState.totalTiles) break;
    }

    // ----- Targeted fallback: for each missing CT, sweep a small window around its expected column -----
    // Works even if labels nudged rows slightly.
    if (paperState.totalTiles && haveCT() < paperState.totalTiles) {
      const missing = [];
      for (let i = 1; i <= paperState.totalTiles; i++) {
        if (!paperState.tiles?.[i]) missing.push(i);
      }

      // Columns repeat left→right; CT 1 is col #3 on page 1 first row; afterward it’s normal grid fill
      // We’ll just sweep each column band across the printable height.
      const colBands = [];
      for (let c = 0; c < COLS_PT; c++) {
        const xPt = startXpt + c * (tilePt + GAP_PT);
        colBands.push({ xPt });
      }

      const winPtW = tilePt * 1.25;
      const winPtH = tilePt * 1.25;
      const stepPt = tilePt * 0.70;

      for (const band of colBands) {
        for (let yPt = MARGIN_PT + BANNER_PT;
             yPt + winPtH <= pageHpt - MARGIN_PT;
             yPt += stepPt) {
          await cropAndDecodePt(band.xPt - (winPtW - tilePt)/2, yPt, winPtW, winPtH, 'pdf-fallback');
          if (haveCT() >= (paperState.totalTiles || 0)) break;
        }
        if (haveCT() >= (paperState.totalTiles || 0)) break;
      }
    }

    updatePaperProgress();
    // Yield to UI
    await new Promise(r => setTimeout(r, 0));
  }
}

// ---------- Image file scanner (layout-aware → sweeps → upscale; BD → ZXing → jsQR) ----------
async function scanImageFile(file) {
  const img = new Image();
  img.src = URL.createObjectURL(file);
  await new Promise(r => (img.onload = r));

  const MAX = 3000;
  const ratio = Math.min(MAX / img.width, MAX / img.height, 1);
  const canvas = document.createElement('canvas');
  canvas.width  = Math.floor(img.width  * ratio);
  canvas.height = Math.floor(img.height * ratio);
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

    const found = await findQRCodesFastForCamera(canvas);  if (!found.length) {
    setPaperMsg(`No QR detected in ${file.name}.`);
  } else {
    for (const t of found) ingestQR(t, `Image ${file.name}`);
  }
  updatePaperProgress();
}

// ---------- Canvas sweep (4-col aware) with BD → ZXing-polyfill → jsQR + upscale ----------
async function findAllQRCodesOnCanvas(canvas) {
  const results = new Set();
  const ctx = canvas.getContext('2d', { willReadFrequently: true });

  const hasNativeBD = 'BarcodeDetector' in window && String(BarcodeDetector).indexOf('Polyfill') === -1;
  const BD_NATIVE   = hasNativeBD ? new BarcodeDetector({ formats: ['qr_code'] }) : null;
  const BD_ZXING    = (typeof window.BarcodeDetectorPolyfill === 'function')
    ? new window.BarcodeDetectorPolyfill({ formats: ['qr_code'] })
    : null;

  const add = (s) => { if (s) results.add(s.trim()); };

  async function decodeRegion(x, y, w, h) {
    if (w <= 0 || h <= 0) return false;

    const sub = document.createElement('canvas');
    sub.width = w; sub.height = h;
    const sctx = sub.getContext('2d', { willReadFrequently: true });
    sctx.imageSmoothingEnabled = false;
    sctx.drawImage(canvas, x, y, w, h, 0, 0, w, h);

    // 1) Native BD
    if (BD_NATIVE) {
      try {
        const bmp = await createImageBitmap(sub);
        const codes = await BD_NATIVE.detect(bmp);
        let any = false;
        for (const c of (codes || [])) {
          const v = (c.rawValue || '').trim();
          if (v) { add(v); any = true; }
        }
        if (any) return true;
      } catch {}
    }

    // 2) ZXing via polyfill (separate pass even if native exists)
    if (BD_ZXING) {
      try {
        const bmp = await createImageBitmap(sub);
        const codes = await BD_ZXING.detect(bmp);
        let any = false;
        for (const c of (codes || [])) {
          const v = (c.rawValue || '').trim();
          if (v) { add(v); any = true; }
        }
        if (any) return true;
      } catch {}
    }

    // 3) jsQR
    try {
      const img = sctx.getImageData(0, 0, w, h);
      const qr = jsQR(img.data, w, h, { inversionAttempts: 'attemptBoth' });
      if (qr?.data) { add(qr.data); return true; }
    } catch {}

    return false;
  }

  // Pass 0: full frame
  await decodeRegion(0, 0, canvas.width, canvas.height);

  // Pass 1: 4-column grid (M=6pt, G=6pt, L=6pt, B=60pt at 300dpi)
  {
    const DPI = 300, PT_PER_IN = 72, pt2px = DPI / PT_PER_IN;
    const MARGIN = Math.round(6  * pt2px);
    const GAP    = Math.round(6  * pt2px);
    const LABEL  = Math.round(6  * pt2px);
    const BANNER = Math.round(60 * pt2px);
    const COLS   = 4;

    const W = canvas.width, H = canvas.height;
    const innerW = W - 2 * MARGIN;
    const tile   = Math.floor((innerW - GAP * (COLS - 1)) / COLS);
    const usedW  = COLS * tile + GAP * (COLS - 1);
    const startX = MARGIN + Math.floor((innerW - usedW) / 2);
    const rowH   = LABEL + tile + GAP;

    let y = MARGIN + BANNER + LABEL;
    while (y + tile <= H - MARGIN) {
      for (let c = 0; c < COLS; c++) {
        const x = startX + c * (tile + GAP);
        if (x + tile > W - MARGIN) break;
        await decodeRegion(x, y, tile, tile);
      }
      y += rowH;
    }
  }

  // Pass 2: sweeps (coarse → fine with overlap)
  async function sweep(grid, overlap = 0) {
    const stepX = Math.floor(canvas.width / grid);
    const stepY = Math.floor(canvas.height / grid);
    const oxs = overlap ? [0, Math.floor(stepX / 2)] : [0];
    const oys = overlap ? [0, Math.floor(stepY / 2)] : [0];
    for (const ox of oxs) for (const oy of oys) {
      for (let gy = 0; gy < grid; gy++) for (let gx = 0; gx < grid; gx++) {
        const x = gx * stepX + ox;
        const y = gy * stepY + oy;
        const w = Math.min(stepX, canvas.width  - x);
        const h = Math.min(stepY, canvas.height - y);
        await decodeRegion(x, y, w, h);
      }
    }
  }
  await sweep(4, 0);
  await sweep(6, 1);

  // Pass 3: upscale retry (1.5× full + 3×3 subtiles)
  {
    const scale = 1.5;
    const tmp = document.createElement('canvas');
    tmp.width  = Math.floor(canvas.width  * scale);
    tmp.height = Math.floor(canvas.height * scale);
    const tctx = tmp.getContext('2d', { willReadFrequently: true });
    tctx.imageSmoothingEnabled = false;
    tctx.drawImage(canvas, 0, 0, tmp.width, tmp.height);

    // full upscaled
    await (async () => {
      // Native BD
      if (BD_NATIVE) {
        try {
          const bmp = await createImageBitmap(tmp);
          const codes = await BD_NATIVE.detect(bmp);
          for (const c of (codes || [])) add((c.rawValue || '').trim());
        } catch {}
      }
      // ZXing polyfill
      if (BD_ZXING) {
        try {
          const bmp = await createImageBitmap(tmp);
          const codes = await BD_ZXING.detect(bmp);
          for (const c of (codes || [])) add((c.rawValue || '').trim());
        } catch {}
      }
      // jsQR
      try {
        const img = tctx.getImageData(0, 0, tmp.width, tmp.height);
        const qr = jsQR(img.data, tmp.width, tmp.height, { inversionAttempts: 'attemptBoth' });
        if (qr?.data) add(qr.data.trim());
      } catch {}
    })();

    // 3×3 subtiles
    const sx = Math.floor(tmp.width  / 3);
    const sy = Math.floor(tmp.height / 3);
    for (let gy = 0; gy < 3; gy++) for (let gx = 0; gx < 3; gx++) {
      const x = gx * sx, y = gy * sy;
      try {
        const sub = tctx.getImageData(x, y, sx, sy);
        const qr2 = jsQR(sub.data, sx, sy, { inversionAttempts: 'attemptBoth' });
        if (qr2?.data) add(qr2.data.trim());
      } catch {}
    }
  }

  return Array.from(results);
}

// ---------- File picker ----------
async function handlePaperFiles(e) {
  const files = Array.from(e.target.files || []);
  if (!files.length) return;

  // reset state
  Object.assign(paperState, {
    header: null, keyHex: null, tiles: {}, totalTiles: null, seenPayloads: new Set()
  });
  const status = paperEls.status();
  if (status) status.innerHTML = "";
  setPaperMsg(`Processing ${files.length} file(s)...`);
  updatePaperProgress();

  for (const f of files) {
    const name = (f.name || '').toLowerCase();
    if (f.type === 'application/pdf' || name.endsWith('.pdf')) {
      await scanPdfFile(f);
    } else {
      await scanImageFile(f);
    }
  }
  updatePaperProgress();
}

// ===== Simple camera loop just for MVKEY/MVHDR/MVCT scanning =====
let __mvCamStream = null;
let __mvCamLoop = null;

async function startPaperCamera() {
  // Prefer rear camera; 720p to keep decoding fast
  const constraints = {
    video: {
      facingMode: { ideal: 'environment' },
      width:  { ideal: 1280 },
      height: { ideal: 720 }
    },
    audio: false
  };

  // Stop any existing camera first
  stopPaperCamera();

  const v = document.getElementById('paperCam');
  if (!v) return;

  // Start stream
  __mvCamStream = await navigator.mediaDevices.getUserMedia(constraints);
  v.srcObject = __mvCamStream;
  v.playsInline = true;
  v.style.display = 'block';
  await v.play();

  // Apply autofocus/zoom/fps/torch where supported (Fix #2)
  await applyCameraTuning(__mvCamStream);

  // Lightweight decode path selector:
  // If you added findQRCodesFastForCamera(), use it; otherwise fall back to the heavy one.
  const decodeFn = (typeof findQRCodesFastForCamera === 'function')
    ? findQRCodesFastForCamera
    : findAllQRCodesOnCanvas;

  // Canvas for frame sampling
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d', { willReadFrequently: true });

  let ticking = false;
  __mvCamLoop = setInterval(async () => {
    // Skip if a decode is already running or video not ready
    if (ticking || !v.videoWidth || !v.videoHeight) return;

    ticking = true;
    try {
      canvas.width  = v.videoWidth;
      canvas.height = v.videoHeight;
      ctx.drawImage(v, 0, 0, canvas.width, canvas.height);

      const found = await decodeFn(canvas);

      // Short-circuit as soon as anything is found (Fix #3)
      if (found && found.length) {
        for (const t of found) ingestQR(t, 'camera');
        updatePaperProgress();
        ticking = false; // release quickly so UI can update immediately
        return;
      }
    } catch (e) {
      console.warn('scan frame failed:', e);
    } finally {
      ticking = false;
    }
  }, 250); // fast, but safe for most devices
}

function stopPaperCamera() {
  if (__mvCamLoop) { clearInterval(__mvCamLoop); __mvCamLoop = null; }
  if (__mvCamStream) {
    for (const tr of __mvCamStream.getTracks()) tr.stop();
    __mvCamStream = null;
  }
  const v = document.getElementById('paperCam');
  if (v) {
    v.pause();
    v.removeAttribute('srcObject');
    v.srcObject = null;
    v.style.display = 'none';
  }
}

// Small wrappers used by your HTML buttons
async function startKeyCam(){ await startPaperCamera(); }
function stopKeyCam(){ stopPaperCamera(); }

async function scanFromVideoOnce(){
  const v = document.getElementById('paperCam');
  if (!v || !v.videoWidth) return;
  const c = document.createElement('canvas');
  c.width = v.videoWidth;
  c.height = v.videoHeight;
  const cx = c.getContext('2d', { willReadFrequently: true });
  cx.drawImage(v, 0, 0);
  const found = await findAllQRCodesOnCanvas(c);
  for (const t of found) ingestQR(t, 'camera-once');
  updatePaperProgress();
}

// expose for inline onclick
window.startKeyCam = startKeyCam;
window.stopKeyCam = stopKeyCam;
window.scanFromVideoOnce = scanFromVideoOnce;

// ---------- Small helpers ----------
function setPaperMsg(msg) {
  const el = paperEls.status();
  if (!el) return;
  const line = `[${new Date().toLocaleTimeString()}] ${msg}`;
  el.innerHTML += (el.innerHTML ? "<br>" : "") + line;
  el.scrollTop = el.scrollHeight;
}

function b64ToU8Direct(b64) {
  // decode a base64 string (may include CR/LF/spaces) → Uint8Array
  const clean = b64.replace(/\s+/g, '');
  const bin = atob(clean);
  const u8 = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) u8[i] = bin.charCodeAt(i);
  return u8;
}

function sha256Hex(u8) {
  return crypto.subtle.digest("SHA-256", u8).then(buf => {
    const h = new Uint8Array(buf);
    return Array.from(h).map(b => b.toString(16).padStart(2,'0')).join('');
  });
}

// Compute decoded length from raw base64 length
function base64DecodedLen(b64) {
  const s = b64.replace(/\s+/g, '');
  const pad = (s.endsWith('==') ? 2 : s.endsWith('=') ? 1 : 0);
  return Math.floor(s.length / 4) * 3 - pad;
}

// ---------- Parse MV payloads (single-file spec) ----------
// MVKEY|<hex-64>
// MVHDR|<base64(JSON:{v,iv,size,sha256})>
// MVCT|<index>/<total>|<base64-chunk>
function parseQRText(txt) {
  if (!txt || typeof txt !== 'string') return null;
  txt = txt.trim();

  if (txt.startsWith("MVKEY|")) {
    const hex = txt.slice(6).trim().toLowerCase();
    if (!/^[0-9a-f]{64}$/.test(hex)) return null;   // 32 bytes as hex
    return { type: "MVKEY", hex };
  }

  if (txt.startsWith("MVHDR|")) {
    const jsonB64 = txt.slice(6).trim();
    try {
      const raw = atob(jsonB64.replace(/\s+/g, ''));
      let json;
      try {
        json = JSON.parse(raw);
      } catch {
        // Fallback for btoa(unescape(encodeURIComponent(...))) style
        const esc = Array.prototype.map.call(raw, ch => '%' + ch.charCodeAt(0).toString(16).padStart(2,'0')).join('');
        json = JSON.parse(decodeURIComponent(esc));
      }
      if (!json || !Array.isArray(json.iv) || typeof json.size !== 'number' || typeof json.sha256 !== 'string') return null;
      return { type: "MVHDR", data: json };
    } catch { return null; }
  }

  if (txt.startsWith("MVCT|")) {
    const m = txt.match(/^MVCT\|(\d+)\/(\d+)\|([A-Za-z0-9+/=\s]+)$/);
    if (!m) return null;
    const idx   = parseInt(m[1],10);
    const total = parseInt(m[2],10);
    const b64   = m[3].trim();
    if (!idx || !total || idx < 1 || idx > total) return null;
    return { type: "MVCT", idx, total, b64 };
  }

  return null;
}

function updatePaperProgress() {
  const haveHdr = !!paperState.header;
  const haveKey = !!paperState.keyHex;
  const haveCt  = Object.keys(paperState.tiles).length;
  const total   = paperState.totalTiles || "?";

  const txtEl = paperEls.barText();
  if (txtEl) {
    txtEl.textContent = `Status — Header: ${haveHdr ? "yes" : "no"} | Tiles: ${haveCt}/${total} | KEY: ${haveKey ? "yes" : "no"}`;
  }

  const pct = (() => {
    let p = 0;
    if (haveHdr) p += 25;
    if (haveKey) p += 25;
    if (paperState.totalTiles) p += Math.min(50, Math.round(50 * (haveCt / paperState.totalTiles)));
    return Math.min(100, p);
  })();

  const bar = paperEls.bar();
  if (bar) bar.style.width = pct + "%";

  const ready = haveHdr && haveKey && paperState.totalTiles && haveCt === paperState.totalTiles;
  const btn = paperEls.rebuildBtn();
  if (btn) {
    btn.disabled = !ready;
    btn.style.opacity = ready ? '1' : '.4';
    btn.style.filter = ready ? 'none' : 'grayscale(100%)';
    btn.style.pointerEvents = ready ? 'auto' : 'none';
  }

  // 🔁 Auto-rebuild once when everything is ready
  if (ready && !window.__mvAutoRebuildDone) {
    window.__mvAutoRebuildDone = true;
    setPaperMsg("All pieces captured — rebuilding ZIP automatically…");
    // slight microtask delay to allow UI update before heavy work
    setTimeout(() => rebuildLiteFromPaper().catch(console.error), 50);
  }
}

// ---------- Intake a decoded QR payload ----------
function ingestQR(raw, src = "QR") {
  if (!raw || paperState.seenPayloads.has(raw)) return;
  paperState.seenPayloads.add(raw);

  const p = parseQRText(raw);
  if (!p) return;

  if (p.type === "MVKEY") {
    if (!paperState.keyHex) {
      paperState.keyHex = p.hex;
      setPaperMsg(`Captured MVKEY (key).`);
    }
  } else if (p.type === "MVHDR") {
    if (!paperState.header) {
      paperState.header = p.data;
      setPaperMsg(`Captured MVHDR (header).`);
    }
  } else if (p.type === "MVCT") {
    // Lock in total once seen; detect conflicts
    if (!paperState.totalTiles) {
      paperState.totalTiles = p.total;
    } else if (paperState.totalTiles !== p.total) {
      setPaperMsg(`⚠️ Conflicting CT totals seen (was ${paperState.totalTiles}, now ${p.total}). Keeping first.`);
    }
    if (!paperState.tiles[p.idx]) {
      paperState.tiles[p.idx] = p.b64;
      setPaperMsg(`Captured MVCT tile ${p.idx}/${paperState.totalTiles || p.total}.`);
    }
  }

  updatePaperProgress();
}



// ==============================
// Open/Close modal + wiring (updated)
// ==============================
function openPaperDecrypt() {
  // Insert progress UI once
  if (!paperEls.barHost()) {
    const host = document.createElement('div');
    host.id = 'paperProgressHost';
    host.style.cssText = 'width:100%;text-align:left;margin:6px 0;';
    host.innerHTML = `
      <div id="paperProgressText" style="font-size:14px;color:#ccc;margin-bottom:6px;">
        Status — waiting for uploads…
      </div>
      <div style="background:#222;border:1px solid #0f0;border-radius:6px;overflow:hidden;height:12px;">
        <div id="paperProgressBar" style="height:12px;width:0%;background:#00ff99;"></div>
      </div>`;
    const modal = paperEls.modal();
    const status = paperEls.status();
    modal.querySelector('.modal')?.insertBefore(host, status) || modal.insertBefore(host, status);
  }

  // Reset capture state
  Object.assign(paperState, { header:null, keyHex:null, tiles:{}, totalTiles:null, seenPayloads:new Set() });
  const statusEl = paperEls.status();
  if (statusEl) statusEl.innerHTML = "Waiting for uploads...";

  // Reset button look
  const btn = paperEls.rebuildBtn();
  if (btn) { 
    btn.disabled = true; 
    btn.style.opacity = '.4'; 
    btn.style.filter = 'grayscale(100%)'; 
    btn.style.pointerEvents = 'none'; 
  }

  // Bind file input
  const files = paperEls.files();
  if (files) files.onchange = handlePaperFiles;

  // Show modal
  const m = paperEls.modal();
  if (m) m.style.display = 'flex';

  // ❌ Removed auto-start of camera here.
  // ✅ Camera will now only start when the user clicks "Start Camera" (startKeyCam → startPaperCamera).

  // Reset auto-rebuild latch
  window.__mvAutoRebuildDone = false;

  updatePaperProgress();
}

function closePaperDecrypt() {
  stopPaperCamera();
  const m = paperEls.modal();
  if (m) m.style.display = 'none';
}

async function rebuildLiteFromPaper() {
  try {
    const { header, keyHex, tiles, totalTiles } = paperState;
    if (!header) throw new Error("Missing header (MVHDR).");
    if (!keyHex) throw new Error("Missing key (MVKEY).");
    if (!totalTiles) throw new Error("Tiles not detected yet.");

    // 1) Pre-size the ciphertext buffer
    let totalCtBytes = 0;
    for (let i = 1; i <= totalTiles; i++) {
      const part = tiles[i];
      if (!part) throw new Error(`Missing ciphertext tile ${i}/${totalTiles}.`);
      totalCtBytes += base64DecodedLen(part);
    }
    const ctBytes = new Uint8Array(totalCtBytes);

    // 2) Decode each chunk directly into the buffer
    let offset = 0;
    for (let i = 1; i <= totalTiles; i++) {
      const chunkU8 = b64ToU8Direct(tiles[i]);
      ctBytes.set(chunkU8, offset);
      offset += chunkU8.length;
    }

    // 3) Decrypt
    const keyU8 = new Uint8Array(keyHex.match(/.{1,2}/g).map(h => parseInt(h, 16)));
    const aesKey = await crypto.subtle.importKey("raw", keyU8, "AES-GCM", false, ["decrypt"]);
    const ivU8  = new Uint8Array(header.iv);
    const zipBytes = new Uint8Array(
      await crypto.subtle.decrypt({ name: "AES-GCM", iv: ivU8 }, aesKey, ctBytes)
    );

    // 4) Verify
    if (zipBytes.length !== header.size) {
      throw new Error(`Size mismatch (expected ${header.size}, got ${zipBytes.length}).`);
    }
    const gotSha = await sha256Hex(zipBytes);
    if (gotSha !== header.sha256) {
      throw new Error(`SHA-256 mismatch. Expected ${header.sha256}, got ${gotSha}.`);
    }

    // 5) Download + optional auto-import
    const blob = new Blob([zipBytes], { type: "application/zip" });
    const name = "memoro-lite.zip";
    const url  = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url; a.download = name;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);

    setPaperMsg(`✅ Rebuild complete. Download started: ${name}`);

    // Optional auto-import into dashboard vault list
    if (typeof handleVaultZip === 'function') {
      const dt = new DataTransfer();
      dt.items.add(new File([blob], name, { type: "application/zip" }));
      const fakeInput = document.createElement('input');
      fakeInput.type = 'file';
      fakeInput.files = dt.files;
      await handleVaultZip({ target: fakeInput });
      setPaperMsg("ZIP auto-imported into your vault list.");
    }

    // Clean up & close after a short grace period
    stopPaperCamera();
    setTimeout(() => {
      try { URL.revokeObjectURL(url); } catch {}
      closePaperDecrypt();
    }, 5000);

  } catch (err) {
    console.error(err);
    setPaperMsg(`❌ Rebuild failed: ${err.message}`);
    alert(`Rebuild failed: ${err.message}`);
    // allow another auto attempt if user keeps scanning/adding pages
    window.__mvAutoRebuildDone = false;
  }
}

// Fast camera decoder: try Native BD → ZXing polyfill → jsQR on full frame,
// then a tiny 2x2 grid. No sweeps, no upscale.
async function findQRCodesFastForCamera(canvas) {
  const results = new Set();
  const ctx = canvas.getContext('2d', { willReadFrequently: true });

  const hasNativeBD = 'BarcodeDetector' in window && String(BarcodeDetector).indexOf('Polyfill') === -1;
  const BD_NATIVE   = hasNativeBD ? new BarcodeDetector({ formats: ['qr_code'] }) : null;
  const BD_ZXING    = (typeof window.BarcodeDetectorPolyfill === 'function')
    ? new window.BarcodeDetectorPolyfill({ formats: ['qr_code'] })
    : null;

  const add = (s) => { if (s) results.add(s.trim()); };

  // 0) Full frame first
  async function tryCanvas(sub) {
    // Native BD
    if (BD_NATIVE) {
      try {
        const bmp = await createImageBitmap(sub);
        const codes = await BD_NATIVE.detect(bmp);
        for (const c of (codes || [])) add(c.rawValue || '');
        if (results.size) return true;
      } catch {}
    }
    // ZXing polyfill
    if (BD_ZXING) {
      try {
        const bmp = await createImageBitmap(sub);
        const codes = await BD_ZXING.detect(bmp);
        for (const c of (codes || [])) add(c.rawValue || '');
        if (results.size) return true;
      } catch {}
    }
    // jsQR fallback
    try {
      const img = ctx.getImageData(0, 0, sub.width, sub.height);
      const qr  = jsQR(img.data, sub.width, sub.height, { inversionAttempts: 'attemptBoth' });
      if (qr?.data) { add(qr.data); return true; }
    } catch {}
    return false;
  }

  await tryCanvas(canvas);
  if (results.size) return Array.from(results);

  // 1) Small 2x2 grid
  const w = canvas.width, h = canvas.height;
  const subW = Math.floor(w / 2), subH = Math.floor(h / 2);
  for (let gy = 0; gy < 2; gy++) for (let gx = 0; gx < 2; gx++) {
    const sub = document.createElement('canvas');
    sub.width = subW; sub.height = subH;
    const sctx = sub.getContext('2d', { willReadFrequently: true });
    sctx.imageSmoothingEnabled = false;
    sctx.drawImage(canvas, gx*subW, gy*subH, subW, subH, 0, 0, subW, subH);
    // Try just once per subtile; keep it fast
    // Native/Polyfill
    try {
      if (BD_NATIVE) {
        const bmp = await createImageBitmap(sub);
        const codes = await BD_NATIVE.detect(bmp);
        for (const c of (codes || [])) add(c.rawValue || '');
      } else if (BD_ZXING) {
        const bmp = await createImageBitmap(sub);
        const codes = await BD_ZXING.detect(bmp);
        for (const c of (codes || [])) add(c.rawValue || '');
      } else {
        const img = sctx.getImageData(0, 0, subW, subH);
        const qr  = jsQR(img.data, subW, subH, { inversionAttempts: 'attemptBoth' });
        if (qr?.data) add(qr.data);
      }
      if (results.size) return Array.from(results);
    } catch {}
  }

  return Array.from(results);
}

// Enables continuous autofocus, mild zoom, decent fps, and torch (if available)
async function applyCameraTuning(stream) {
  try {
    const track = stream?.getVideoTracks?.()[0];
    if (!track) return;

    const caps = track.getCapabilities?.() || {};
    const cons = track.getConstraints?.() || {};
    const adv  = [...(cons.advanced || [])];

    if (caps.focusMode && caps.focusMode.includes('continuous')) {
      adv.push({ focusMode: 'continuous' });
    }
    if (caps.zoom) {
      const z = caps.zoom.min + (caps.zoom.max - caps.zoom.min) * 0.33; // ~1/3 into the range
      adv.push({ zoom: Math.round(z * 100) / 100 });
    }
    if (caps.frameRate) {
      const maxFps = (typeof caps.frameRate === 'object' && 'max' in caps.frameRate)
        ? caps.frameRate.max : 30;
      adv.push({ frameRate: Math.min(30, maxFps || 30) });
    }
    if (caps.torch) {
      // Turn on LED if present; feel free to remove if you don't want default torch
      adv.push({ torch: true });
    }

    if (adv.length) {
      await track.applyConstraints({ advanced: adv });
    }
  } catch (e) {
    console.debug('Camera tuning not applied:', e);
  }
}

// Expose for UI
window.openPaperDecrypt = openPaperDecrypt;
window.closePaperDecrypt = closePaperDecrypt;
window.rebuildLiteFromPaper = rebuildLiteFromPaper;
window.startKeyCam = startKeyCam;
window.stopKeyCam  = stopKeyCam;

</script>

<script>
    const canvas = document.getElementById('matrix');
    const ctx = canvas.getContext('2d');
    const letters = "01ABCDEFGHIJKLMNOPQRSTUVWXYZ#$%^&*";
    const fontSize = 14;
    let columns, drops;

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      columns = Math.floor(canvas.width / fontSize);
      drops = Array(columns).fill(1);
    }

    function drawMatrix() {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#00ff99';
      ctx.font = fontSize + "px monospace";

      for (let i = 0; i < drops.length; i++) {
        const text = letters[Math.floor(Math.random() * letters.length)];
        ctx.fillText(text, i * fontSize, drops[i] * fontSize);
        if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) drops[i] = 0;
        drops[i]++;
      }
    }

    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    setInterval(drawMatrix, 33);

    function updateQuestionCount() {
      document.getElementById('questionCount').textContent = document.getElementById('questionSlider').value;
    }

    function startVaultSetup() {
      const questionCount = document.getElementById('questionSlider').value;
      localStorage.setItem('customQuestionCount', questionCount);
      window.location.href = "setup-questions.html";
    }

    function goBack() {
      window.history.back();
    }

    window.onload = () => {
      const saved = localStorage.getItem('customQuestionCount');
      if (saved) {
        document.getElementById('questionSlider').value = saved;
        updateQuestionCount();
      }
    };
  </script>

  <script>
let questions = [];
let currentEditIndex = null;

const defaultQuestions = [
  "What is my full name?",
  "What is the name of my favorite childhood dog?",
  "What is my wife's maiden name?",
  "What city was I born in?",
  "In what city did my wife and I compete in our first Ironman?",
  "What is the name of my wife's favorite childhood dog?",
  "What is the first name of my wife's biological brother?",
  "What is the mascot of the 2nd high school I attended?",
  "What is my father's middle name?",
  "In what city did my wife and I go on our first date?",
  "Journey before... (complete the phrase)",
  "What was the name of my yellow Suzuki V-Strom 650 motorcycle?",
  "What is the name of my childhood best friend?",
  "Was my wife my first kiss? (y/n)",
  "Was I her first kiss? (y/n)",
  "Do I like mustard? (y/n)",
  "I play the guitar AND piano (t/f)",
  "My wife was a collegiate dancer for Auburn (t/f)",
  "We had our first child in 2019 (t/f)",
  "I have played league tennis (t/f)",
  "I played tennis in high school (t/f)",
  "My wife and I met in high school (t/f)",
  "My wife is left-handed (t/f)",
  "I am left-handed (t/f)",
  "I have travelled overseas AND am bilingual (t/f)"
];

function loadQuestions() {
  const vaultType = localStorage.getItem('selectedVaultType');
let numberOfQuestions;

if (vaultType === 'monero') numberOfQuestions = 25;
else if (vaultType === 'monero-polyseed') numberOfQuestions = 16;
else if (vaultType === 'bitcoin') numberOfQuestions = 24;
else if (vaultType === 'bitcoin-legacy') numberOfQuestions = 12;
else {
  const customCount = parseInt(localStorage.getItem('customQuestionCount'));
  numberOfQuestions = isNaN(customCount) ? 12 : customCount;
}


  // Save it again just to ensure continuity
  localStorage.setItem('questionCount', numberOfQuestions);

  const savedQuestions = JSON.parse(localStorage.getItem('questions'));
  questions = (savedQuestions && savedQuestions.length >= numberOfQuestions)
    ? savedQuestions.slice(0, numberOfQuestions)
    : defaultQuestions.slice(0, numberOfQuestions);

  const questionList = document.getElementById('questionList');
  questionList.innerHTML = "";

  for (let i = 0; i < numberOfQuestions; i++) {
    const div = document.createElement('div');
    div.className = 'question-item';
    div.innerHTML = `
      <div class="question-text" id="question-${i}"><b>${i + 1}.</b> ${questions[i]}</div>
<div class="action-row">
  <button class="edit-button" onclick="openModal(${i})">Edit</button>
  <input type="checkbox" class="unlock-checkbox" id="unlock-${i}" onchange="limitSelection()">
</div>
    `;
    questionList.appendChild(div);
  }
}

function openModal(index) {
  currentEditIndex = index;

  const input = document.getElementById('editInput');
  if (input) {
    input.value = questions[index] || '';
  }

  const dropdown = document.getElementById('categoryDropdown');
  if (dropdown) {
    dropdown.removeEventListener("change", populateSuggestions); // Prevent duplicate listeners
    dropdown.addEventListener("change", populateSuggestions);
  }

  document.getElementById('editModal').style.display = 'flex';
}


function closeModal() {
  document.getElementById('editModal').style.display = 'none';
  currentEditIndex = null;
}

function saveModalEdit() {
  const newQuestion = document.getElementById('editInput').value.trim();
  if (newQuestion && currentEditIndex !== null) {
    questions[currentEditIndex] = newQuestion;
    document.getElementById(`question-${currentEditIndex}`).innerHTML = `<b>${currentEditIndex + 1}.</b> ${newQuestion}`;
    localStorage.setItem('questions', JSON.stringify(questions));
  }
  closeModal();
}

function limitSelection() {
  const checkboxes = document.querySelectorAll('.unlock-checkbox');
  const checked = Array.from(checkboxes).filter(cb => cb.checked);
  if (checked.length >= 2) {
    checkboxes.forEach(cb => { if (!cb.checked) cb.disabled = true; });
  } else {
    checkboxes.forEach(cb => cb.disabled = false);
  }
}

function showDisclaimer() {
  const checkboxes = document.querySelectorAll('.unlock-checkbox');
  const selected = Array.from(checkboxes).filter(cb => cb.checked);
  if (selected.length !== 2) {
    showMessageModal('Selection Error', 'Please select exactly TWO unlock questions.');
    return;
  }
  document.getElementById('disclaimerModal').style.display = 'flex';
}

function proceedToAnswers() {
  const checkboxes = document.querySelectorAll('.unlock-checkbox');
  const selectedIndexes = [];
  checkboxes.forEach((cb, idx) => { if (cb.checked) selectedIndexes.push(idx); });

  localStorage.setItem('questions', JSON.stringify(questions));
  localStorage.setItem('unlockQuestions', JSON.stringify(selectedIndexes));

  window.location.href = "answer-questions.html";
}

function goBack() {
  window.history.back();
}

function showMessageModal(title, message) {
  document.getElementById('messageModalTitle').innerText = title;
  document.getElementById('messageModalText').innerText = message;
  document.getElementById('messageModal').style.display = 'flex';
}

function closeMessageModal() {
  document.getElementById('messageModal').style.display = 'none';
}

window.onload = loadQuestions;
</script>

<script>
  const suggestionBank = {
    home:[
  "What was the name of the first street you lived on?",
  "What color was your childhood home?",
  "What was the name of your childhood best friend?",
  "What was the name of your first neighborhood?",
  "What was the first park you remember playing in?",
  "What landmark was closest to your childhood home?",
  "What was the name of your first grade teacher?",
  "What was your favorite hiding place as a child?",
  "What tree or plant do you remember from your backyard?",
  "What was the number of your childhood house?",
  "What was your favorite game to play outside?",
  "Who lived across the street from you growing up?",
  "What kind of fence (or no fence) did your house have?",
  "What was the name of a nearby lake or river you visited?",
  "What was your childhood bedroom color?",
  "What was the nickname of your childhood home?",
  "What road did you take to school as a kid?",
  "What local business do you remember near your home?"
],
    family: [
  "What is your mother's maiden name?",
  "What was your grandfather's first name?",
  "What was your grandmother’s nickname for you?",
  "Which relative had the most unique hobby?",
  "What was the city your parents first met in?",
  "What was your sibling’s childhood nickname?",
  "What was your family dog’s name growing up?",
  "Where did your family go for reunions?",
  "What was your father’s first car?",
  "What was your mother’s favorite song?",
  "Who was the oldest cousin in your family?",
  "What tradition did your family have every year?",
  "What family recipe was handed down?",
  "What family member did you resemble most as a child?",
  "What state did your grandparents retire to?",
  "What was the middle name of your favorite aunt?",
  "What holiday was most celebrated in your family?",
  "Who had the loudest laugh in your family?"
],
    Pets: [
  "What was the name of your first pet?",
  "What species was your first pet?",
  "What was the nickname you called your first pet?",
  "What trick did your first pet know?",
  "Where did you get your first pet from?",
  "What was your pet’s favorite toy?",
  "What was your pet's favorite sleeping spot?",
  "What was the color of your first pet?",
  "What unusual habit did your pet have?",
  "What was the breed of your childhood dog or cat?",
  "What was your pet’s favorite treat?",
  "What was the pet’s vet’s name?",
  "Where did your pet like to hide?",
  "What was the most mischievous thing your pet did?",
  "What was the name of the pet you wished you had?"
],
    life: [
  "What was the first vacation you remember?",
  "What was your childhood home’s street number?",
  "What time did your school bus pick you up?",
  "What was the name of your childhood doctor?",
  "What chore did you hate the most growing up?",
  "What was your first broken bone or injury?",
  "What was the name of your kindergarten teacher?",
  "What was the first movie you saw in a theater?",
  "What was your favorite school subject?",
  "What was your bedtime routine as a child?",
  "What game did you play most at recess?",
  "What was your first Halloween costume?",
  "What was the first major news event you remember?",
  "What was your favorite childhood weekend activity?",
  "What was the name of your neighborhood or subdivision?"
],
    favorites: [
  "What was your favorite book growing up?",
  "What was your favorite movie as a teenager?",
  "What was your favorite band in high school?",
  "What was your favorite childhood toy?",
  "What was your favorite sports team as a kid?",
  "What was your favorite outdoor activity?",
  "What was your favorite indoor game?",
  "What was your favorite holiday tradition?",
  "What was your favorite TV show growing up?",
  "What was your favorite subject in school?",
  "What was your favorite place to visit as a child?",
  "What was your favorite restaurant when you were young?",
  "What was your favorite color in elementary school?",
  "What was your favorite cartoon character?",
  "What was your favorite video game growing up?"
],
    random: [
  "What was the name of your imaginary friend?",
  "What was your favorite hiding spot as a child?",
  "What was the first movie you remember seeing in a theater?",
  "What did you want to be when you grew up at age 5?",
  "What was your favorite board game growing up?",
  "What unusual pet did you want but never had?",
  "What was your favorite recess game?",
  "What costume did you wear for Halloween most often?",
  "What weird collection did you have as a kid?",
  "What was your favorite subject in elementary school?",
  "What fictional world did you wish was real?",
  "What was the first prize you ever won?",
  "What secret hiding place did you use as a kid?",
  "What song reminds you of your childhood?",
  "What superstition did you believe as a child?"
],
    school: [
  "What was the name of your elementary school?",
  "Who was your favorite high school teacher?",
  "What was your favorite subject in middle school?",
  "What sport did you play at school?",
  "What was your favorite school event?",
  "Who was your childhood best friend at school?",
  "What was the mascot of your school?",
  "What was the first book you remember reading for class?",
  "What song reminds you of your school days?",
  "What was your favorite field trip?",
  "What was the first language class you took?",
  "What award did you first win at school?",
  "Who was your first school crush?",
  "What was the name of your bus driver?",
  "What was the color of your locker?",
  "What elective class did you enjoy the most?",
  "What was your school’s rival team name?",
  "What lunch item did you always trade?"
],
    career: [
  "What was the name of your first boss?",
  "What was your very first job?",
  "Where did you earn your first paycheck?",
  "What was your dream job as a teenager?",
  "What company gave you your first job offer?",
  "What was your job title at your first job?",
  "What was the name of your favorite coworker at your first job?",
  "What tool or equipment did you first learn to use at work?",
  "What skill did you first learn on the job?",
  "What was the biggest mistake you made at your first job?",
  "What uniform did you wear at your first job?",
  "Where did you have your first job interview?",
  "What was the first career you seriously considered?",
  "What industry was your first job in?",
  "What was your first promotion at work?"
],
    travel: [
  "What was your first vacation destination?",
  "What was the first country you visited?",
  "What is your favorite national park?",
  "What was the name of the first hotel you stayed in?",
  "Which beach do you remember visiting first?",
  "Where did you go on your first solo trip?",
  "What city did you love visiting most as a child?",
  "What was the first flight number you remember taking?",
  "Where did you go for a childhood road trip?",
  "What was the name of the amusement park you visited?",
  "What mode of transport do you associate with your first trip?",
  "What’s the name of a memorable airport you flew through?",
  "Which relative’s house did you visit farthest away?",
  "What river cruise or boat ride do you remember?",
  "What was your favorite souvenir from a trip?"
],
  hobbies:[
  "What was your favorite childhood hobby?",
  "What hobby did you spend the most time on as a teenager?",
  "What instrument did you first learn to play?",
  "What was the first sport you participated in?",
  "What craft or art project did you enjoy as a kid?",
  "What was your favorite type of puzzle growing up?",
  "What collection did you start as a child?",
  "What board game did you always want to win?",
  "What was your favorite thing to build with Legos?",
  "What outdoor activity did you love most as a kid?",
  "What was your favorite arcade or video game growing up?",
  "What book series did you become obsessed with?",
  "What was your favorite science experiment you tried?",
  "What dance or performance hobby did you enjoy?",
  "What hobby have you always wanted to master?"
],
  special: [
  "What holiday holds the most meaning to you?",
  "What tradition is most important to you?",
  "What event in your life made you feel truly proud?",
  "What family heirloom means the most to you?",
  "What was the most memorable gift you ever received?",
  "What location holds a special place in your heart?",
  "What song reminds you of home?",
  "What was your happiest childhood memory?",
  "What teacher had the biggest impact on your life?",
  "What was the most meaningful piece of advice you received?",
  "What special trip do you cherish the most?",
  "What was your first major personal achievement?",
  "What keepsake have you held onto the longest?",
  "What moment made you feel most connected to your family?",
  "What book or story changed your perspective growing up?"
],
  };
  
  
  function openHelpModal() {
  document.getElementById('helpModal').style.display = 'flex';
}

function closeHelpModal() {
  document.getElementById('helpModal').style.display = 'none';
}

  function populateSuggestions() {
    const category = document.getElementById('categoryDropdown').value;
    const listDiv = document.getElementById('suggestionsList');
    listDiv.innerHTML = '';
  
    if (category && suggestionBank[category]) {
      suggestionBank[category].forEach(q => {
        const btn = document.createElement('button');
        btn.textContent = q;
        btn.style.cssText = `
          display:block; width:100%; text-align:left; 
          background:#333; border:none; color:white; 
          padding:8px; margin-top:5px; border-radius:6px;
          font-size:15px; cursor:pointer;
        `;
        btn.onclick = () => {
          document.getElementById('editInput').value = q;
        };
        listDiv.appendChild(btn);
      });
    }
  }
  
  function saveEditedQuestion() {
    const newQuestion = document.getElementById('editInput').value.trim();
    if (newQuestion && currentEditIndex !== null) {
      questions[currentEditIndex] = newQuestion;
      document.getElementById(`question-${currentEditIndex}`).innerHTML = `<b>${currentEditIndex + 1}.</b> ${newQuestion}`;
      localStorage.setItem('questions', JSON.stringify(questions));
    }
    closeModal();
  }

  document.addEventListener("DOMContentLoaded", () => {
  loadQuestions();
  document.getElementById("categoryDropdown").addEventListener("change", populateSuggestions);
});

  </script>
  
  <script>
  const canvas = document.getElementById("matrixCanvas");
  const ctx = canvas.getContext("2d");

  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890@$%&'.split('');
  const fontSize = 14;
  const columns = Math.floor(canvas.width / fontSize);
  const drops = Array(columns).fill(0);

  function drawMatrix() {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#00ff99';
    ctx.font = `${fontSize}px monospace`;

    for (let i = 0; i < drops.length; i++) {
      const text = letters[Math.floor(Math.random() * letters.length)];
      ctx.fillText(text, i * fontSize, drops[i] * fontSize);
      drops[i]++;
      if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
        drops[i] = 0;
      }
    }
  }

  setInterval(drawMatrix, 66);
  window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  });

  async function nukeEverything() {
  try {
    localStorage.clear();
    sessionStorage.clear();
    if (indexedDB.databases) {
      const dbs = await indexedDB.databases();
      for (const db of dbs) {
        indexedDB.deleteDatabase(db.name);
      }
    } else {
      indexedDB.deleteDatabase("memoroVaultVaultStorage");
      indexedDB.deleteDatabase("memoroVaultDB");
    }
    console.log("Memoro Vault: Local memory wiped.");
  } catch (err) {
    console.warn("Memoro Vault wipe failed:", err);
  }
}

</script>
</body>
</html>
