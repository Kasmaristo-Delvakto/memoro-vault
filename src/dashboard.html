<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Memoro Vault - Dashboard</title>
<script src="libs/zip.min.js"></script>
<script src="libs/argon2-browser.min.js"></script> <!-- Argon2 lib -->
<script src="libs/secrets.min.js"></script>

<!-- PDF.js core -->
<script src="libs/pdf.min.js"></script>
<script>
  // Configure PDF.js to use the worker from your local libs folder
  if (window['pdfjsLib']) {
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'libs/pdf.worker.min.js';
  }
</script>

<!-- QR decoder -->
<script src="libs/jsqr.min.js"></script>

<style>
:root {
  --bg:#000;
  --fg:#00ff99;
  --fg-strong:#0f0;
  --border:#00ff99;
  --border-dim:rgba(0,255,153,.28);

  --panel:#111;
  --radius:12px;
  --radius-xs:8px;

  --gap:clamp(10px,2.2vw,18px);
  --pad:clamp(12px,2.2vw,22px);
  --pad-lg:clamp(16px,2.8vw,28px);
}

/* ---------- Base ---------- */
* { box-sizing:border-box; }
html,body { height:100%; }
body {
  margin:0;
  padding:min(3vh,28px);
  background:var(--bg);
  color:var(--fg);
  font-family:"Fira Code", monospace;
  display:flex; flex-direction:column; align-items:center;
}

/* Canvas layers */
canvas { position:fixed; inset:0; z-index:-2; }
#matrixCanvas { position:fixed; inset:0; width:100vw; height:100vh; z-index:-3; }
.matrix-overlay { position:fixed; inset:0; background:rgba(0,0,0,.82); z-index:-2; }

/* ---------- Typography ---------- */
h1,h2,h3 { margin:0; line-height:1.12; }
h1 { color:var(--fg); font-size:clamp(28px,4.6vw,52px); }
h2 { color:var(--fg-strong); font-size:clamp(18px,2.2vw,26px); }
h3 { color:var(--fg-strong); font-size:clamp(16px,2vw,22px); }
p  { margin:0; color:var(--fg); text-align:center; font-size:clamp(14px,1.8vw,18px); }

/* ---------- Typewriter Hero ---------- */
.mv-hero {
  display:flex; flex-direction:column; align-items:center;
  gap:8px; margin-top:6px; margin-bottom:10px; text-align:center;
}

/* Typewriter effect */
.typewriter-text {
  display:inline-block;
  overflow:hidden;
  white-space:nowrap;
  border-right:2px solid transparent;
  color:transparent;
  animation:
    revealText 0s forwards,
    typing 2s steps(40,end) forwards 0.05s,
    blink-caret 0.75s step-end 7 2s forwards;
}

@keyframes revealText { to { color:#00ff99; border-right-color:#00ff99; } }
@keyframes typing     { from { width:0 } to { width:100% } }
@keyframes blink-caret{ 0%,100%{border-color:transparent} 50%{border-color:#00ff99} }

/* Buttons fade in after typing */
.button-group {
  opacity:0; transform:translateY(6px);
  animation: fadeInUp .5s ease-out forwards;
  animation-delay:3.5s; /* adjust depending on line timing */
}
@keyframes fadeInUp { from{opacity:0; transform:translateY(10px);} to{opacity:1; transform:none;} }

/* ---------- Buttons (full rewrite, same look; better on all screens) ---------- */
.button,
.modal-buttons button,
.unlock-button,
.three-dots {
  background: #111;
  color: var(--fg);
  border: 1px solid var(--border);
  border-radius: var(--radius-xs);
  padding: 12px 20px;
  font-size: clamp(14px, 1.6vw, 18px);
  cursor: pointer;
  transition: transform .12s, box-shadow .16s, background .18s;
  box-shadow: 0 0 6px var(--fg);
}

/* keep the hover/active/focus styling exactly as you had */
.button:hover,
.modal-buttons button:hover,
.unlock-button:hover {
  background: #1a1a1a;
  transform: translateY(-1px);
}
.button:focus-visible {
  outline: 0;
  box-shadow: 0 0 0 3px rgba(0,255,153,.3);
}
.button:active { transform: translateY(0); }
.button[disabled] { opacity: .5; filter: grayscale(100%); cursor: not-allowed; }

/* ensure real buttons have a sensible minimum; do NOT affect the three-dots icon */
.button,
.modal-buttons button,
.unlock-button {
  min-width: 220px;
}

/* ---------- Buttons (full rewrite, same look; better on all screens) ---------- */
.button,
.modal-buttons button,
.unlock-button,
.three-dots {
  background: #111;
  color: var(--fg);
  border: 1px solid var(--border);
  border-radius: var(--radius-xs);
  padding: 12px 20px;
  font-size: clamp(14px, 1.6vw, 18px);
  cursor: pointer;
  transition: transform .12s, box-shadow .16s, background .18s;
  box-shadow: 0 0 6px var(--fg);
}

/* keep the hover/active/focus styling exactly as you had */
.button:hover,
.modal-buttons button:hover,
.unlock-button:hover {
  background: #1a1a1a;
  transform: translateY(-1px);
}
.button:focus-visible {
  outline: 0;
  box-shadow: 0 0 0 3px rgba(0,255,153,.3);
}
.button:active { transform: translateY(0); }
.button[disabled] { opacity: .5; filter: grayscale(100%); cursor: not-allowed; }

/* ensure real buttons have a sensible minimum; do NOT affect the three-dots icon */
.button,
.modal-buttons button,
.unlock-button {
  min-width: 220px;
}

/* ---------- Buttons (unchanged visual style) ---------- */
.button,
.modal-buttons button,
.unlock-button,
.three-dots {
  background:#111;
  color:var(--fg);
  border:1px solid var(--border);
  border-radius:var(--radius-xs);
  padding:12px 20px;
  font-size:clamp(14px,1.6vw,18px);
  cursor:pointer;
  transition:transform .12s, box-shadow .16s, background .18s;
  box-shadow:0 0 6px var(--fg);
}
.button:hover,
.modal-buttons button:hover,
.unlock-button:hover { background:#1a1a1a; transform:translateY(-1px); }
.button:focus-visible { outline:0; box-shadow:0 0 0 3px rgba(0,255,153,.3); }
.button:active { transform:translateY(0); }
.button[disabled] { opacity:.5; filter:grayscale(100%); cursor:not-allowed; }

/* keep real buttons from squishing; they fill their grid track */
.button,
.modal-buttons button,
.unlock-button {
  min-width: 220px;
  width: 100%;
}

/* ---------- CTA row (discrete layouts only) ---------- */
.button-group{
  display:grid;
  gap:14px 16px;
  justify-content:center;       /* center the grid block */
  align-content:center;
  margin:14px auto 0;
  padding:12px 16px;
  background:rgba(0,255,153,.05);
  border:1px solid var(--border-dim);
  border-radius:16px;
  width:auto;
  max-width:96vw;               /* avoid horizontal overflow in tight windows */
}

/* 1×4 row — wide screens */
@media (min-width: 1100px){
  .button-group{
    grid-template-columns: repeat(4, minmax(220px, max-content));
  }
}

/* 2×2 grid — medium screens */
@media (min-width: 600px) and (max-width: 1099px){
  .button-group{
    grid-template-columns: repeat(2, minmax(220px, 1fr));
  }
}

/* 1×N column — small screens */
@media (max-width: 599px){
  .button-group{
    grid-template-columns: 1fr;
  }
}

/* ---------- Vault Grid ---------- */
.vault-list {
  width:min(900px,100%);
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(280px,1fr));
  gap:var(--gap);
  margin-top:24px;
}
.vault-item {
  background:var(--panel);
  border:1px solid var(--border-dim);
  border-radius:var(--radius);
  padding:var(--pad-lg);
  display:flex; flex-direction:column; gap:10px;
  box-shadow:0 0 14px rgba(0,255,153,.12);
}
.vault-item h2 { font-size:clamp(18px,2.1vw,22px); color:#b9ffd9; }
.vault-item p  { font-size:clamp(13px,1.6vw,16px); color:#b9ffd9; text-align:left; }

/* ---------- Modals ---------- */
.modal-overlay {
  display:none; position:fixed; inset:0; z-index:9999;
  background:rgba(0,0,0,.78);
  align-items:center; justify-content:center; padding:20px;
}
.modal {
  background:#111; color:var(--fg);
  width:92%; max-width:520px;
  padding:40px 32px 28px;
  border:1px solid var(--border);
  border-radius:12px;
  box-shadow:0 0 16px rgba(0,255,153,.18);
  max-height:calc(100vh - 80px); overflow-y:auto;
  display:flex; flex-direction:column; gap:16px; text-align:center;
}
.modal h2 { font-size:26px; color:var(--fg-strong); }
.modal p  { font-size:15px; line-height:1.6; color:var(--fg); }
.modal input {
  width:100%; padding:10px 12px; min-height:44px;
  border-radius:8px; border:1px solid var(--border);
  background:#000; color:var(--fg);
  font-family:'Fira Code', monospace; font-size:15px;
}
.modal-buttons { display:flex; flex-wrap:wrap; gap:12px; justify-content:center; }

/* ---------- Scrollbars ---------- */
*::-webkit-scrollbar{ width:10px; height:10px; }
*::-webkit-scrollbar-thumb{ background:linear-gradient(#00ff99,#0b7f55); border-radius:10px; }
*::-webkit-scrollbar-track{ background:#0d0d0d; }
</style>


</head>

<body>
  <input type="file" id="vaultZipInput" accept=".zip" style="display:none;" onchange="handleVaultZip(event)">
<div style="display: flex; justify-content: center;">
  <h1><span class="typewriter-text" style="animation-delay: 0s;">Memoro Vault</span></h1>
</div>
<div style="position: relative; width: 100%; display: flex; justify-content: center;">
  <p class="typewriter-text" style="animation-delay: 1.3s; margin-bottom: 0.3em; pointer-events: none;">
    What matters most.
  </p>
</div>
<div style="position: relative; width: 100%; display: flex; justify-content: center;">
  <p class="typewriter-text" style="animation-delay: 2.5s; margin-top: 0; pointer-events: none;">
    Hidden in plain sight.
  </p>
</div>


<div class="button-group">
  <button class="button" style="animation-delay: 3.5s;" onclick="promptOfflineWarning('create')">+ Create New Vault</button>
  <button class="button" style="animation-delay: 5.5s;" onclick="promptOfflineWarning('load')">Load Vault File</button>
  <button class="button" style="animation-delay: 9.5s;" onclick="openPaperDecrypt()">Restore Physical Backup</button>
  <button class="button" style="animation-delay: 7.5s;" onclick="goToHowItWorks()">How Memoro Works</button>
</div>

<div class="vault-list" id="vaultList"></div>

<!-- Unlock Vault Modal -->
<div class="modal-overlay" id="unlockModal">
  <div class="modal">
    <h2>Unlock Vault</h2>
    <h3 id="question1Label"></h3>
    <input type="text" id="answer1Input" placeholder="Answer 1">
    <h3 id="question2Label"></h3>
    <input type="text" id="answer2Input" placeholder="Answer 2">

    <!-- Lockout Visuals -->
    <div id="lockoutSection" style="display:none; width:100%; margin-top:10px; text-align:center;">
      <p id="lockoutTimerText" style="margin:5px 0; font-size:16px; color:#ccc;">Locked for 15s</p>
      <div style="background-color:#444; width:100%; height:10px; border-radius:5px; overflow:hidden;">
      <div id="lockoutProgress" style="background-color:#00ff99; width:100%; height:10px;"></div>
      </div>
    </div>

    <div class="modal-buttons">
      <button id="unlockButton" onclick="submitUnlock()">Unlock</button>
      <button onclick="cancelUnlock()">Cancel</button>
    </div>
  </div>
</div>

<!-- Offline Warning Modal -->
<div class="modal-overlay" id="offlineWarning">
  <div class="modal">
    <h2>Offline Mode Recommended</h2>
    <p>We recommend disabling your internet connection temporarily for maximum security.</p>
    <div class="modal-buttons">
      <button onclick="proceedAfterOfflineWarning()">Continue</button>
      <button onclick="cancelOfflineWarning()">Cancel</button>
    </div>
  </div>
</div>

<!-- Message Modal -->
<div class="modal-overlay" id="messageModal">
  <div class="modal">
    <h2 id="messageModalTitle">Title</h2>
    <p id="messageModalText">Message goes here.</p>
    <div class="modal-buttons">
      <button onclick="closeMessageModal()">OK</button>
    </div>
  </div>
</div>

<!-- Confirm Modal -->
<div class="modal-overlay" id="confirmModal">
  <div class="modal">
    <h2>Confirm</h2>
    <p id="confirmModalText">Are you sure?</p>
    <div class="modal-buttons">
      <button onclick="confirmNo()">No</button>
      <button onclick="confirmYes()">Yes</button>
    </div>
  </div>
</div>

<!-- Rename Vault Modal -->
<div class="modal-overlay" id="renameModal">
  <div class="modal">
    <h2>Rename Vault</h2>
    <input type="text" id="renameInput" placeholder="New vault name">
    <div class="modal-buttons">
      <button onclick="submitRename()">Rename</button>
      <button onclick="cancelRename()">Cancel</button>
    </div>
  </div>
</div>

<!-- Paper Decrypt Modal -->
<div class="modal-overlay" id="paperDecryptModal">
  <div class="modal" style="max-width: 720px;">
    <h2>Restore Physical Backup</h2>
    <p style="white-space: normal; text-align:left;">
        Upload the full PDF or individual page images. We’ll extract:<br>
        • 1× <code>MVKEY</code> (single key QR)<br>
        • 1× <code>MVHDR</code> (header) and all <code>MVCT</code> tiles (ciphertext)<br>
        Then we rebuild <code>memoro-lite.zip</code>.
      </p>


    <!-- File input -->
    <input id="paperFiles" type="file" accept=".pdf,image/*" multiple
           style="width:100%; margin-bottom:12px;">

    <!-- Optional: simple camera for key shares -->
    <div style="width:100%; border:1px solid #0f0; padding:10px; border-radius:8px; margin:8px 0;">
      <h3 style="margin:0 0 8px 0;">Scan Key Shares (Optional)</h3>
      <p style="margin:0 0 8px 0; font-size:14px; color:#ccc;">
        If you prefer, aim the camera at an MVKEY QR (one at a time). We still recommend uploading a page/PDF for the tiles.
      </p>
      <video id="paperCam" playsinline style="width:100%; max-height:240px; background:#000; display:none;"></video>
      <div class="modal-buttons" style="gap:8px;">
        <button onclick="startKeyCam()">Start Camera</button>
        <button onclick="stopKeyCam()">Stop Camera</button>
        <button onclick="scanFromVideoOnce()">Scan Key</button>
      </div>
    </div>

    <div id="paperStatus" style="width:100%; text-align:left; font-size:14px; color:#ccc;"></div>

    <div class="modal-buttons" style="margin-top:10px;">
      <button onclick="closePaperDecrypt()">Close</button>
      <button id="rebuildBtn" onclick="rebuildLiteFromPaper()" disabled>Rebuild Lite ZIP</button>
    </div>
  </div>
</div>

<script>
const loadedVaults = {};
let currentUnlockVaultId = null;
let nextAction = null;
let confirmYesCallback = null;
let countdownInterval = null;
let failedAttempts = 0;
let lockoutUntil = 0;

  // Message Modal
  function showMessageModal(title, message) {
  document.getElementById('messageModalTitle').innerText = title;
  document.getElementById('messageModalText').innerText = message;
  document.getElementById('messageModal').style.display = 'flex';
}
function closeMessageModal() {
  document.getElementById('messageModal').style.display = 'none';
}

  // Confirm Modal
  function showConfirmModal(message, yesCallback) {
    document.getElementById('confirmModalText').innerText = message;
    document.getElementById('confirmModal').style.display = 'flex';
    confirmYesCallback = yesCallback;
  }

  function confirmNo() {
    document.getElementById('confirmModal').style.display = 'none';
    confirmYesCallback = null;
  }

  function confirmYes() {
    document.getElementById('confirmModal').style.display = 'none';
    if (typeof confirmYesCallback === 'function') {
      confirmYesCallback();
      confirmYesCallback = null;
    }
  }

function saveVaultsToLocalStorage() {
  try {
    const index = Object.entries(loadedVaults).map(([vaultId, v]) => ({
      vaultId,
      fileName: v.fileName || 'Memoro Vault',
      // keep minimal metadata for display/restoration
      createdAt: Date.now(),
    }));
    localStorage.setItem('memoroVaultIndex', JSON.stringify(index));
    // no huge binary here — that’s what IndexedDB is for
  } catch (err) {
    console.error('❌ Failed to write vault index to localStorage:', err);
  }
}

  function loadVaultsFromLocalStorage() {
  const saved = localStorage.getItem('savedVaults');
  if (!saved) return;

  const vaultArray = JSON.parse(saved);
  vaultArray.forEach(({ vaultId, fileName, vaultData }) => {
    loadFilesFromIndexedDB(vaultId).then(fileMapRaw => {
      const reconstructedMap = {};
      const reconstructedRaw = {};

      for (const [name, fileObj] of Object.entries(fileMapRaw || {})) {
        const blob = new Blob([new Uint8Array(fileObj.data)], { type: fileObj.type });
        reconstructedMap[name] = blob;
        reconstructedRaw[name] = {
          type: fileObj.type,
          data: fileObj.data
        };
      }

      loadedVaults[vaultId] = {
        fileName,
        vaultData,
        fileMap: reconstructedMap,
        fileMapRaw: reconstructedRaw
      };

      addVaultToList(vaultId, fileName, vaultData, true);
    }).catch(err => {
      console.error(`Failed to load fileMapRaw for vault ${vaultId}:`, err);
      showMessageModal("Load Error", `Could not load vault files for "${fileName}".`);
    });
  });
}

  function addVaultToList(vaultId, fileName, vaultData, skipSaving = false) {
    const vaultList = document.getElementById('vaultList');
    const vaultItem = document.createElement('div');
    vaultItem.className = 'vault-item';
    vaultItem.id = vaultId;
    vaultItem.innerHTML = `
      <div style="width:100%; display:flex; justify-content:space-between; align-items:center;">
        <h2 id="title-${vaultId}" style="margin:0;">${fileName}</h2>
        <div style="position:relative;">
          <button class="three-dots" onclick="toggleMenu('${vaultId}')">⋮</button>
          <div class="vault-menu" id="menu-${vaultId}">
            <button onclick="deleteVault('${vaultId}')">Delete</button>
            <button onclick="renameVault('${vaultId}')">Rename</button>
          </div>
        </div>
      </div>
      <p>Status:Locked</p>
      <button class="unlock-button" onclick="openUnlockModal('${vaultId}')">Unlock Vault</button>
    `;
    vaultList.appendChild(vaultItem);
    if (!skipSaving) {
  saveVaultsToLocalStorage();
}
  }

  function toggleMenu(vaultId) {
    const menu = document.getElementById(`menu-${vaultId}`);
    menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
    document.querySelectorAll('.vault-menu').forEach(m => {
      if (m.id !== `menu-${vaultId}`) m.style.display = 'none';
    });
  }

  let currentRenameVaultId = null;

  function renameVault(vaultId) {
    currentRenameVaultId = vaultId;
    const vault = loadedVaults[vaultId];
    if (!vault) {
      showMessageModal('Error', 'Vault not found.');
      return;
    }
    document.getElementById('renameInput').value = vault.fileName;
    document.getElementById('renameModal').style.display = 'flex';
  }

  function cancelRename() {
    currentRenameVaultId = null;
    document.getElementById('renameModal').style.display = 'none';
  }

  function submitRename() {
    const newName = document.getElementById('renameInput').value.trim();
    if (!newName) {
      showMessageModal('Missing Name', 'Please enter a new name.');
      return;
    }
    if (currentRenameVaultId && loadedVaults[currentRenameVaultId]) {
      loadedVaults[currentRenameVaultId].fileName = newName;
      document.getElementById(`title-${currentRenameVaultId}`).innerText = newName;
      saveVaultsToLocalStorage();
    }
    cancelRename();
  }

  function deleteVault(vaultId) {
    showConfirmModal('Are you sure you want to delete this vault?', () => {
      delete loadedVaults[vaultId];
      document.getElementById(vaultId).remove();
      saveVaultsToLocalStorage();
    });
  }

  function openUnlockModal(vaultId) {
  clearInterval(countdownInterval);

  currentUnlockVaultId = vaultId;
  const vault = loadedVaults[vaultId];
  const prompts = vault.vaultData.questionPrompts || ["Question 1:", "Question 2:"];

  document.getElementById('question1Label').innerText = prompts[0];
  document.getElementById('question2Label').innerText = prompts[1];

  document.getElementById('answer1Input').value = '';
  document.getElementById('answer2Input').value = '';
  document.getElementById('answer1Input').disabled = false;
  document.getElementById('answer2Input').disabled = false;

  document.getElementById('lockoutSection').style.display = 'none';
  document.getElementById('lockoutProgress').style.width = '100%';

  const unlockButton = document.getElementById('unlockButton');
  unlockButton.disabled = false;
  unlockButton.textContent = 'Unlock';

  document.getElementById('unlockModal').style.display = 'flex';
  setTimeout(() => document.getElementById('answer1Input').focus(), 100);

  failedAttempts = Number(localStorage.getItem(`failedAttempts_${vaultId}`)) || 0;
  lockoutUntil = Number(localStorage.getItem(`lockoutUntil_${vaultId}`)) || 0;
  checkIfLocked();
}

function cancelUnlock() {
  currentUnlockVaultId = null;
  document.getElementById('unlockModal').style.display = 'none';
  clearInterval(countdownInterval);
}


function checkIfLocked() {
  if (Date.now() < lockoutUntil) {
    startCountdown();
  }
}

function startCountdown() {
  clearInterval(countdownInterval);
  const now = Date.now();
  const totalTime = lockoutUntil - now;
  const lockoutSection = document.getElementById('lockoutSection');
  const timerText = document.getElementById('lockoutTimerText');
  const progressBar = document.getElementById('lockoutProgress');
  const unlockButton = document.getElementById('unlockButton');

  lockoutSection.style.display = 'block';
  document.getElementById('answer1Input').disabled = true;
  document.getElementById('answer2Input').disabled = true;
  unlockButton.disabled = true;
  unlockButton.textContent = 'Locked';

  countdownInterval = setInterval(() => {
    const nowInner = Date.now();
    const remaining = lockoutUntil - nowInner;

    if (remaining <= 0) {
      clearInterval(countdownInterval);
      document.getElementById('answer1Input').disabled = false;
      document.getElementById('answer2Input').disabled = false;
      lockoutSection.style.display = 'none';
      unlockButton.disabled = false;
      unlockButton.textContent = 'Unlock';
      return;
    }

    const seconds = Math.ceil(remaining / 1000);
    timerText.innerText = `Locked for ${seconds}s`;

    const percent = (remaining / totalTime) * 100;
    progressBar.style.width = `${percent}%`;
  }, 200);
}

  function promptOfflineWarning(action) {
    nextAction = action;
    document.getElementById('offlineWarning').style.display = 'flex';
  }

  function proceedAfterOfflineWarning() {
  document.getElementById('offlineWarning').style.display = 'none';
  if (nextAction === 'create') {
    window.location.href = "create-vault.html";
  } else if (nextAction === 'load') {
    document.getElementById('vaultZipInput').click(); // ✅ THIS IS MISSING
  }
  nextAction = null;
}

  function cancelOfflineWarning() {
    document.getElementById('offlineWarning').style.display = 'none';
    nextAction = null;
  }

  function goToHowItWorks() {
    window.location.href = "how-it-works.html";
  }

async function handleVaultZip(event) {
  const file = event.target.files?.[0];
  if (!file || !file.name.toLowerCase().endsWith('.zip')) {
    showMessageModal('Invalid File', 'Please select a valid .zip vault file.');
    return;
  }

  const vaultId  = 'vault-' + Date.now();
  const fileName = file.name.replace(/\.zip$/i, '');

  let zipReader;
  try {
    // Open without materializing the whole thing
    zipReader = new zip.ZipReader(new zip.BlobReader(file));

    // Read central directory
    const entries = await zipReader.getEntries();

    // Helper to find an entry by (case-insensitive) name
    const find = (n) => entries.find(e => e.filename.toLowerCase() === n);

    const eJson = find('vault.json');
    const eEnc  = find('vault.enc');
    const eMeta = find('vault.meta');

    if (!eJson || !eEnc || !eMeta) {
      throw new Error('ZIP is missing one or more required files: vault.json, vault.enc, vault.meta');
    }

    // Extract only what we need, and do it efficiently
    // vault.json → text
    const vaultJsonBlob = await eJson.getData(new zip.BlobWriter('application/json'));
    const vaultData     = JSON.parse(await vaultJsonBlob.text());

    // vault.enc → bytes (leave as Uint8Array)
    const vaultEncBlob = await eEnc.getData(new zip.BlobWriter('application/octet-stream'));
    const vaultEncU8   = new Uint8Array(await vaultEncBlob.arrayBuffer());

    // vault.meta → bytes
    const vaultMetaBlob = await eMeta.getData(new zip.BlobWriter('application/octet-stream'));
    const vaultMetaU8   = new Uint8Array(await vaultMetaBlob.arrayBuffer());

    // Build minimal in‑memory structures (no full file map mirror)
    const fileMap = {
      'vault.json': vaultJsonBlob,
      'vault.enc':  new Blob([vaultEncU8], { type: 'application/octet-stream' }),
      'vault.meta': new Blob([vaultMetaU8], { type: 'application/octet-stream' }),
    };

    // Raw (compact) representation — keep Uint8Array, not big JS arrays
    const fileMapRaw = {
      'vault.json': { type: 'application/json',              data: new TextEncoder().encode(JSON.stringify(vaultData)) },
      'vault.enc':  { type: 'application/octet-stream',      data: vaultEncU8 },
      'vault.meta': { type: 'application/octet-stream',      data: vaultMetaU8 },
    };

    // Keep a handle to the original ZIP for pass‑through to recover.html
    loadedVaults[vaultId] = {
      fileName,
      vaultData,
      fileMap,
      fileMapRaw,
      zipBlob: file
    };

    // Persist the heavy bits in IndexedDB (not localStorage)
    await saveFilesToIndexedDB(vaultId, {
      'vault.json': { type: 'application/json',         data: fileMapRaw['vault.json'].data },
      'vault.enc':  { type: 'application/octet-stream', data: fileMapRaw['vault.enc'].data  },
      'vault.meta': { type: 'application/octet-stream', data: fileMapRaw['vault.meta'].data },
    });

    // Add to UI (and store only lightweight metadata in localStorage)
    addVaultToList(vaultId, fileName, vaultData);
    saveVaultsToLocalStorage(); // this will now write only small metadata

    showMessageModal('Success', 'Vault imported successfully!');

  } catch (err) {
    console.error('ZIP Load Error:', err);
    showMessageModal('Load Failed', err.message || 'Could not load the vault ZIP file.');
  } finally {
    try { await zipReader?.close(); } catch {}
    // Reset the file input so selecting the same file again re‑fires change
    event.target.value = '';
  }
}
</script>


<script>
async function deriveKey(password, saltHex = null, vaultData = null) {
  const encoder = new TextEncoder();
  const passwordBytes = encoder.encode(password);
  const salt = saltHex 
    ? Uint8Array.from(saltHex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)))
    : new Uint8Array(await crypto.subtle.digest("SHA-256", passwordBytes));

  const settings = vaultData?.argonSettings || {
    time: 10,
    mem: 65536,
    parallelism: 4,
    type: "Argon2id",
    hashLen: 32
  };

  const argonResult = await argon2.hash({
    pass: password,
    salt,
    time: settings.time,
    mem: settings.mem,
    parallelism: settings.parallelism,
    type: argon2.ArgonType[settings.type] || argon2.ArgonType.Argon2id,
    hashLen: settings.hashLen || 32
  });

  const keyBytes = new Uint8Array(argonResult.hash);
  return crypto.subtle.importKey(
    "raw",
    keyBytes,
    { name: "AES-GCM" },
    false,
    ["encrypt", "decrypt"]
  );
}

async function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function decryptAES(ciphertextArray, ivArray, key) {
  try {
    const iv = new Uint8Array(ivArray);
    const ciphertext = new Uint8Array(ciphertextArray);

    const decryptedBuffer = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      ciphertext
    );

    const decoded = new TextDecoder().decode(decryptedBuffer);

    // ✅ Ensure full JSON was returned for large payloads
    if (!decoded.startsWith('{') || !decoded.endsWith('}')) {
      throw new Error("Decryption returned incomplete JSON. Data may be too large or corrupted.");
    }

    return decoded;
  } catch (err) {
    console.error("❌ Decryption failed:", err);
    throw new Error("Decryption failed: Incorrect key or corrupted vault.enc.");
  }
}

async function submitUnlock() {
  if (Date.now() < lockoutUntil) return;

  const answer1 = document.getElementById('answer1Input').value.trim().toLowerCase();
  const answer2 = document.getElementById('answer2Input').value.trim().toLowerCase();

  if (!answer1 || !answer2) {
    showMessageModal('Missing Answers', 'Please answer both questions.');
    return;
  }

  const vault = loadedVaults[currentUnlockVaultId];
  if (!vault || !vault.vaultData || !vault.fileMapRaw || !vault.zipBlob) {
    showMessageModal('Vault Error', 'Vault is missing required data.');
    return;
  }

  const vaultEncRaw = vault.fileMapRaw["vault.enc"];
  const vaultMetaRaw = vault.fileMapRaw["vault.meta"];
  if (!vaultEncRaw || !vaultEncRaw.data|| !vaultMetaRaw || !vaultMetaRaw.data) {
    showMessageModal('Vault Error', 'Required encrypted files are missing or incomplete.');
    return;
  }

  try {
    console.log("🔑 Unlock attempt with answers:", answer1, answer2);

    const vaultData = vault.vaultData;
    const layer1Salt = vaultData.layer1Salt;
    if (!layer1Salt) {
      throw new Error("Vault metadata is incomplete: layer1Salt not found.");
    }

    const vaultEncText = new TextDecoder().decode(Uint8Array.from(vaultEncRaw.data));
    const vaultEncJson = JSON.parse(vaultEncText);
    const { ciphertext, iv } = vaultEncJson;

    const aesKey = await deriveKey(answer1 + answer2, layer1Salt, vaultData);

    const decryptedBuffer = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv: new Uint8Array(iv) },
      aesKey,
      new Uint8Array(ciphertext)
    );
    const decrypted = new TextDecoder().decode(decryptedBuffer);
    const fullVaultData = JSON.parse(decrypted);

    // Inject metadata
    fullVaultData.finalMessageIv = vaultData.finalMessageIv || null;
    fullVaultData.vaultMetaIv = vaultData.vaultMetaIv;

    // Serialize fileMap
    const serializedMap = {};
    for (const [filename, blob] of Object.entries(vault.fileMap)) {
      const buffer = await blob.arrayBuffer();
      serializedMap[filename] = {
        type: blob.type || 'application/octet-stream',
        data: Array.from(new Uint8Array(buffer))
      };
    }

    // ✅ Use the original imported ZIP blob
    const vaultBlob = new Uint8Array(await vault.zipBlob.arrayBuffer());
    if (vaultBlob.length === 0) throw new Error("Original vault ZIP blob is empty.");

    const transferObject = {
      vaultJson: vaultData,
      decryptedVaultData: fullVaultData,
      baseKey: answer1 + answer2,
      fileMapRaw: serializedMap,
      vaultEncRaw,
      vaultMetaRaw,
      vaultId: currentUnlockVaultId,
      fullSalt: vaultData.fullSalt,
      vaultBlob: vaultBlob.buffer
    };

    // Save to IndexedDB
    await new Promise((resolve, reject) => {
      const req = indexedDB.open("memoroVaultVaultStorage", 1);
      req.onupgradeneeded = function (event) {
        const db = event.target.result;
        if (!db.objectStoreNames.contains("vaultFiles")) {
          db.createObjectStore("vaultFiles", { keyPath: "vaultId" });
        }
      };
      req.onsuccess = function (event) {
        const db = event.target.result;
        const tx = db.transaction("vaultFiles", "readwrite");
        const store = tx.objectStore("vaultFiles");

        store.put({ vaultId: currentUnlockVaultId + "-transfer", data: transferObject });

        tx.oncomplete = () => {
          console.log("📦 IndexedDB write completed:", currentUnlockVaultId + "-transfer");
          resolve();
        };
        tx.onerror = (e) => reject("❌ IndexedDB write error: " + e.target.error.message);
      };
      req.onerror = (e) => reject("❌ Failed to open IndexedDB: " + e.target.error.message);
    });

    // Reset lockout state
    clearInterval(countdownInterval);
    localStorage.removeItem(`failedAttempts_${currentUnlockVaultId}`);
    localStorage.removeItem(`lockoutUntil_${currentUnlockVaultId}`);
    localStorage.setItem("lastVaultId", currentUnlockVaultId);

    await delay(500); // Optional delay

    window.location.href = "recover.html";
  } catch (err) {
    console.warn("❌ Unlock failed:", err.message);
    failedAttempts++;
    const lockDelay = 15000 * Math.pow(2, failedAttempts - 1);
    lockoutUntil = Date.now() + lockDelay;

    localStorage.setItem(`failedAttempts_${currentUnlockVaultId}`, failedAttempts);
    localStorage.setItem(`lockoutUntil_${currentUnlockVaultId}`, lockoutUntil);

    showMessageModal("Unlock Failed", `Incorrect answers. Attempts: ${failedAttempts}`);
    startCountdown();
  }
}

// Expose globally
window.submitUnlock = submitUnlock;
  // Expose to global scope for onclick handler
  window.submitUnlock = submitUnlock;

window.addEventListener("DOMContentLoaded", () => {
  sessionStorage.removeItem("memoroTransfer");
  Object.keys(loadedVaults).forEach(key => delete loadedVaults[key]); // 💥 flush stale in-memory blobs
  loadVaultsFromLocalStorage();  // 🧠 this rehydrates cleanly from saved localStorage
});

// 🧼 Force input to lowercase as user types
document.addEventListener("input", (e) => {
  if (e.target.id === "answer1Input" || e.target.id === "answer2Input") {
    e.target.value = e.target.value.toLowerCase();
  }
});

function saveFilesToIndexedDB(vaultId, fileMapRaw, transferObject = null) {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open("memoroVaultVaultStorage", 1);
    req.onupgradeneeded = function (event) {
      const db = event.target.result;
      if (!db.objectStoreNames.contains("vaultFiles")) {
        db.createObjectStore("vaultFiles", { keyPath: "vaultId" });
      }
    };
    req.onsuccess = function (event) {
      const db = event.target.result;
      const tx = db.transaction("vaultFiles", "readwrite");
      const store = tx.objectStore("vaultFiles");

      // Always store fileMapRaw for dashboard hydration
      store.put({ vaultId, fileMapRaw });
      console.log("Saved fileMapRaw for vaultId:", vaultId);

      // Store transfer object if provided
      if (transferObject) {
        store.put({ vaultId: vaultId + "-transfer", ...transferObject });
        console.log("Saved transfer object for vaultId:", vaultId + "-transfer");
      }

      tx.oncomplete = () => {
        console.log("IndexedDB transaction completed for vaultId:", vaultId);
        resolve();
      };
      tx.onerror = (e) => {
        console.error("IndexedDB transaction error:", e.target.error);
        reject("IndexedDB write failed: " + e.target.error.message);
      };
    };
    req.onerror = (e) => reject("Failed to open IndexedDB: " + e.target.error.message);
  });
}

function loadFilesFromIndexedDB(vaultId) {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open("memoroVaultVaultStorage", 1);
    req.onsuccess = function (event) {
      const db = event.target.result;
      const tx = db.transaction("vaultFiles", "readonly");
      const store = tx.objectStore("vaultFiles");
      const getReq = store.get(vaultId);
      getReq.onsuccess = () => resolve(getReq.result?.fileMapRaw || {});
      getReq.onerror = () => reject("Failed to retrieve vault file blobs.");
    };
    req.onerror = () => reject("IndexedDB load failed.");
  });
}

</script>

<canvas id="matrixCanvas"></canvas>
<div class="matrix-overlay"></div>

<script>
  const canvas = document.getElementById("matrixCanvas");
  const ctx = canvas.getContext("2d");

  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890@$%&'.split('');
  const fontSize = 14;
  const columns = Math.floor(canvas.width / fontSize);
  const drops = Array(columns).fill(0);

  function drawMatrix() {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#00ff99';
    ctx.font = `${fontSize}px monospace`;

    for (let i = 0; i < drops.length; i++) {
      const text = letters[Math.floor(Math.random() * letters.length)];
      ctx.fillText(text, i * fontSize, drops[i] * fontSize);
      drops[i]++;
      if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
        drops[i] = 0;
      }
    }
  }

  setInterval(drawMatrix, 66); // ~15fps like "How It Works"
  window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  });

  document.addEventListener('click', (e) => {
  const menus = document.querySelectorAll('.vault-menu');
  const isMenuButton = e.target.classList.contains('three-dots');

  // If clicked outside all menus and not the ⋮ button, hide all
  if (!isMenuButton && !e.target.closest('.vault-menu')) {
    menus.forEach(menu => menu.style.display = 'none');
  }
});

async function nukeEverything() {
  try {
    localStorage.clear();
    sessionStorage.clear();
    if (indexedDB.databases) {
      const dbs = await indexedDB.databases();
      for (const db of dbs) {
        indexedDB.deleteDatabase(db.name);
      }
    } else {
      indexedDB.deleteDatabase("memoroVaultVaultStorage");
      indexedDB.deleteDatabase("memoroVaultDB");
    }
    console.log("Memoro Vault: Local memory wiped.");
  } catch (err) {
    console.warn("Memoro Vault wipe failed:", err);
  }
}

// ==============================
// Memoro Physical Backup — Dashboard
// Scans MVKEY (hex), MVHDR (b64(JSON)), MVCT tiles → reassembles memoro-lite.zip
// ==============================

// ---------- State & element refs ----------
const paperState = {
  header: null,            // { v, iv:number[], size:number, sha256:string }
  keyHex: null,            // 64 hex chars (32 bytes)
  tiles: {},               // { 1: "b64...", 2: "b64...", ... }
  totalTiles: null,        // integer
  seenPayloads: new Set(), // dedupe across PDF & camera (raw strings)
};

const paperEls = {
  modal:      () => document.getElementById('paperDecryptModal'),
  files:      () => document.getElementById('paperFiles'),
  status:     () => document.getElementById('paperStatus'),
  barHost:    () => document.getElementById('paperProgressHost'),
  barText:    () => document.getElementById('paperProgressText'),
  bar:        () => document.getElementById('paperProgressBar'),
  rebuildBtn: () => document.getElementById('rebuildBtn') || document.getElementById('rebuildLiteBtn'),
  camVideo:   () => document.getElementById('paperCam'),
};

let camStream = null;
let camLoopId = null;

// ---------- Small helpers ----------
function setPaperMsg(msg) {
  const el = paperEls.status();
  if (!el) return;
  const line = `[${new Date().toLocaleTimeString()}] ${msg}`;
  el.innerHTML += (el.innerHTML ? "<br>" : "") + line;
  el.scrollTop = el.scrollHeight;
}

function b64ToU8Direct(b64) {
  // decode a base64 string (may include CR/LF/spaces) → Uint8Array
  const clean = b64.replace(/\s+/g, '');
  const bin = atob(clean);
  const u8 = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) u8[i] = bin.charCodeAt(i);
  return u8;
}

function sha256Hex(u8) {
  return crypto.subtle.digest("SHA-256", u8).then(buf => {
    const h = new Uint8Array(buf);
    return Array.from(h).map(b => b.toString(16).padStart(2,'0')).join('');
  });
}

// Compute decoded length from raw base64 length
function base64DecodedLen(b64) {
  const s = b64.replace(/\s+/g, '');
  const pad = (s.endsWith('==') ? 2 : s.endsWith('=') ? 1 : 0);
  return Math.floor(s.length / 4) * 3 - pad;
}

// ---------- Parse MV payloads (single-file spec) ----------
// MVKEY|<hex-64>
// MVHDR|<base64(JSON:{v,iv,size,sha256})>
// MVCT|<index>/<total>|<base64-chunk>
function parseQRText(txt) {
  if (!txt || typeof txt !== 'string') return null;
  txt = txt.trim();

  if (txt.startsWith("MVKEY|")) {
    const hex = txt.slice(6).trim().toLowerCase();
    if (!/^[0-9a-f]{64}$/.test(hex)) return null;   // 32 bytes as hex
    return { type: "MVKEY", hex };
  }

  if (txt.startsWith("MVHDR|")) {
    const jsonB64 = txt.slice(6).trim();
    try {
      const raw = atob(jsonB64.replace(/\s+/g, ''));
      let json;
      try {
        json = JSON.parse(raw);
      } catch {
        // Fallback for btoa(unescape(encodeURIComponent(...))) style
        const esc = Array.prototype.map.call(raw, ch => '%' + ch.charCodeAt(0).toString(16).padStart(2,'0')).join('');
        json = JSON.parse(decodeURIComponent(esc));
      }
      if (!json || !Array.isArray(json.iv) || typeof json.size !== 'number' || typeof json.sha256 !== 'string') return null;
      return { type: "MVHDR", data: json };
    } catch { return null; }
  }

  if (txt.startsWith("MVCT|")) {
    const m = txt.match(/^MVCT\|(\d+)\/(\d+)\|([A-Za-z0-9+/=\s]+)$/);
    if (!m) return null;
    const idx   = parseInt(m[1],10);
    const total = parseInt(m[2],10);
    const b64   = m[3].trim();
    if (!idx || !total || idx < 1 || idx > total) return null;
    return { type: "MVCT", idx, total, b64 };
  }

  return null;
}

function updatePaperProgress() {
  const haveHdr = !!paperState.header;
  const haveKey = !!paperState.keyHex;
  const haveCt  = Object.keys(paperState.tiles).length;
  const total   = paperState.totalTiles || "?";

  const txtEl = paperEls.barText();
  if (txtEl) {
    txtEl.textContent = `Status — Header: ${haveHdr ? "yes" : "no"} | Tiles: ${haveCt}/${total} | KEY: ${haveKey ? "yes" : "no"}`;
  }

  const pct = (() => {
    let p = 0;
    if (haveHdr) p += 25;
    if (haveKey) p += 25;
    if (paperState.totalTiles) p += Math.min(50, Math.round(50 * (haveCt / paperState.totalTiles)));
    return Math.min(100, p);
  })();

  const bar = paperEls.bar();
  if (bar) bar.style.width = pct + "%";

  const ready = haveHdr && haveKey && paperState.totalTiles && haveCt === paperState.totalTiles;
  const btn = paperEls.rebuildBtn();
  if (btn) {
    btn.disabled = !ready;
    btn.style.opacity = ready ? '1' : '.4';
    btn.style.filter = ready ? 'none' : 'grayscale(100%)';
    btn.style.pointerEvents = ready ? 'auto' : 'none';
  }

  // 🔁 Auto-rebuild once when everything is ready
  if (ready && !window.__mvAutoRebuildDone) {
    window.__mvAutoRebuildDone = true;
    setPaperMsg("All pieces captured — rebuilding ZIP automatically…");
    // slight microtask delay to allow UI update before heavy work
    setTimeout(() => rebuildLiteFromPaper().catch(console.error), 50);
  }
}

// ---------- Intake a decoded QR payload ----------
function ingestQR(raw, src = "QR") {
  if (!raw || paperState.seenPayloads.has(raw)) return;
  paperState.seenPayloads.add(raw);

  const p = parseQRText(raw);
  if (!p) return;

  if (p.type === "MVKEY") {
    if (!paperState.keyHex) {
      paperState.keyHex = p.hex;
      setPaperMsg(`Captured MVKEY (key).`);
    }
  } else if (p.type === "MVHDR") {
    if (!paperState.header) {
      paperState.header = p.data;
      setPaperMsg(`Captured MVHDR (header).`);
    }
  } else if (p.type === "MVCT") {
    // Lock in total once seen; detect conflicts
    if (!paperState.totalTiles) {
      paperState.totalTiles = p.total;
    } else if (paperState.totalTiles !== p.total) {
      setPaperMsg(`⚠️ Conflicting CT totals seen (was ${paperState.totalTiles}, now ${p.total}). Keeping first.`);
    }
    if (!paperState.tiles[p.idx]) {
      paperState.tiles[p.idx] = p.b64;
      setPaperMsg(`Captured MVCT tile ${p.idx}/${paperState.totalTiles || p.total}.`);
    }
  }

  updatePaperProgress();
}

// ---------- PDF scanner (deterministic 3-col crop + mini-sweep fallback) ----------
async function scanPdfFile(file) {
  const buf = new Uint8Array(await file.arrayBuffer());
  const pdf = await pdfjsLib.getDocument({ data: buf }).promise;

  const MARGIN    = 24;   // pt (letter layout)
  const GAP       = 12;   // pt
  const LABEL_PAD = 14;   // pt
  const BANNER_H  = 72;   // pt
  const COLS      = 3;

  // small helper to keep UI responsive
  const tick = () => new Promise(r => setTimeout(r, 0));

  for (let p = 1; p <= pdf.numPages; p++) {
    // Early-exit if we already have everything
    if (paperState.header && paperState.keyHex &&
        paperState.totalTiles && Object.keys(paperState.tiles).length === paperState.totalTiles) {
      break;
    }

    const page = await pdf.getPage(p);

    // Render at a scale that yields ~300dpi for the QR tile (good for jsQR, not overkill)
    // Letter page width = 612pt; 300dpi = 300/72 px/pt ≈ 4.166
    // We use 4.2 but clamp in case of memory-starved devices.
    const viewport = page.getViewport({ scale: 4.2 });
    const canvas = document.createElement('canvas');
    canvas.width  = Math.floor(viewport.width);
    canvas.height = Math.floor(viewport.height);
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    ctx.imageSmoothingEnabled = false;
    await page.render({ canvasContext: ctx, viewport }).promise;

    const W = canvas.width, H = canvas.height;
    const s = W / 612; // uniform scale from points → pixels

    const marginX = Math.round(MARGIN * s);
    const marginY = Math.round(MARGIN * s);
    const gapX    = Math.round(GAP * s);
    const gapY    = Math.round(GAP * s);
    const banner  = Math.round(BANNER_H * s);
    const label   = Math.round(LABEL_PAD * s);

    const innerW  = W - 2 * marginX;
    const tile    = Math.floor((innerW - gapX * (COLS - 1)) / COLS);
    const usedW   = COLS * tile + gapX * (COLS - 1);
    const startX  = marginX + Math.floor((innerW - usedW) / 2);

    // decode helper (tight first, then padded if needed)
    const tryRect = (x, y, w, h, tag) => {
      const attempts = [
        () => {
          const inset = Math.round(Math.min(w, h) * 0.02);
          const x1 = Math.max(0, x + inset), y1 = Math.max(0, y + inset);
          const w1 = Math.max(0, Math.min(W - x1, w - inset * 2));
          const h1 = Math.max(0, Math.min(H - y1, h - inset * 2));
          if (w1 <= 0 || h1 <= 0) return false;
          const img = ctx.getImageData(x1, y1, w1, h1);
          const qr  = jsQR(img.data, w1, h1, { inversionAttempts: "attemptBoth" });
          if (qr?.data) { ingestQR(qr.data, tag + ":tight"); return true; }
          return false;
        },
        () => {
          const pad = Math.round(Math.min(w, h) * 0.08);
          const x0 = Math.max(0, x - pad), y0 = Math.max(0, y - pad);
          const w0 = Math.min(W - x0, w + pad * 2), h0 = Math.min(H - y0, h + pad * 2);
          if (w0 <= 0 || h0 <= 0) return false;
          const img = ctx.getImageData(x0, y0, w0, h0);
          const qr  = jsQR(img.data, w0, h0, { inversionAttempts: "attemptBoth" });
          if (qr?.data) { ingestQR(qr.data, tag + ":pad"); return true; }
          return false;
        }
      ];
      for (const attempt of attempts) if (attempt()) return true;
      return false;
    };

    // deterministic rows/cols like the builder
    let y = marginY + banner + label;
    const rowAdvance = label + tile + gapY;

    // First row of page 1 has KEY|HDR|CT1
    let rowsScanned = 0;
    let foundOnThisPage = 0;
    while (y + tile <= H - marginY) {
      for (let c = 0; c < COLS; c++) {
        const x = startX + c * (tile + gapX);
        if (p === 1 && rowsScanned === 0) {
          if      (c === 0) tryRect(x, y, tile, tile, "p1-key");
          else if (c === 1) tryRect(x, y, tile, tile, "p1-hdr");
          else              tryRect(x, y, tile, tile, "p1-ct");
        } else {
          if (tryRect(x, y, tile, tile, `p${p}-ct`)) foundOnThisPage++;
        }
      }
      rowsScanned++;
      y += rowAdvance;

      // yield after each row so UI/progress updates and camera can still run
      await tick();

      // Early-exit if we’ve got everything
      if (paperState.header && paperState.keyHex &&
          paperState.totalTiles && Object.keys(paperState.tiles).length === paperState.totalTiles) {
        break;
      }
    }

    // Mini-sweep fallback: probe 3×N overlapping windows to catch stragglers
    // (jsQR returns one code per call; these windows help discover missed tiles.)
    if ((!paperState.totalTiles || Object.keys(paperState.tiles).length < (paperState.totalTiles || Infinity)) ) {
      const cols = 3, rows = Math.max(6, Math.floor((H - (marginY + banner)) / (tile * 0.9)));
      const winW = Math.floor(tile * 1.2), winH = Math.floor(tile * 1.2);
      for (let r = 0; r < rows; r++) {
        const yy = Math.max(marginY, Math.min(H - winH - marginY, marginY + banner + Math.round(r * (tile * 0.8))));
        for (let c = 0; c < cols; c++) {
          const xx = Math.max(marginX, Math.min(W - winW - marginX, startX + Math.round(c * (tile + gapX) - tile * 0.1)));
          const img = ctx.getImageData(xx, yy, winW, winH);
          const qr  = jsQR(img.data, winW, winH, { inversionAttempts: 'attemptBoth' });
          if (qr?.data) {
            const before = Object.keys(paperState.tiles).length;
            ingestQR(qr.data, `p${p}-mini`);
            const after = Object.keys(paperState.tiles).length;
            if (after > before) foundOnThisPage += (after - before);
          }
        }
        await tick();
      }
    }

    // If a page produced nothing and we already have a good amount, don’t keep grinding
    if (foundOnThisPage === 0 && paperState.totalTiles && Object.keys(paperState.tiles).length > 0) {
      // nothing discovered here; continue to next page quickly
    }

    updatePaperProgress();
    await tick();
  }
}

async function scanImageFile(file) {
  const img = new Image();
  img.src = URL.createObjectURL(file);
  await new Promise(r => img.onload = r);

  const MAX = 2400;
  const ratio = Math.min(MAX / img.width, MAX / img.height, 1);
  const canvas = document.createElement('canvas');
  canvas.width = Math.floor(img.width * ratio);
  canvas.height = Math.floor(img.height * ratio);
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

  const found = await findAllQRCodesOnCanvas(canvas);
  if (!found.length) {
    setPaperMsg(`No QR detected in ${file.name}.`);
  } else {
    for (const t of found) ingestQR(t, `Image ${file.name}`);
  }
  updatePaperProgress();
}

// Robust page sweep with overlap + upscale
async function findAllQRCodesOnCanvas(canvas) {
  const results = new Set();
  const ctx = canvas.getContext('2d', { willReadFrequently: true });

  // Pass 0: full frame
  {
    const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const qr = jsQR(img.data, img.width, img.height, { inversionAttempts: 'attemptBoth' });
    if (qr?.data) results.add(qr.data.trim());
  }

  // Grid sweep helper
  function sweep(grid, overlap = 0) {
    const stepX = canvas.width / grid;
    const stepY = canvas.height / grid;
    const oxs = overlap ? [0, stepX/2] : [0];
    const oys = overlap ? [0, stepY/2] : [0];

    for (const ox of oxs) for (const oy of oys) {
      for (let gy=0; gy<grid; gy++) for (let gx=0; gx<grid; gx++) {
        const x = Math.max(0, Math.floor(gx * stepX + ox));
        const y = Math.max(0, Math.floor(gy * stepY + oy));
        const w = Math.floor(stepX);
        const h = Math.floor(stepY);
        if (x + w > canvas.width || y + h > canvas.height) continue;
        const img = ctx.getImageData(x, y, w, h);
        const qr = jsQR(img.data, w, h, { inversionAttempts: 'attemptBoth' });
        if (qr?.data) results.add(qr.data.trim());
      }
    }
  }

  sweep(4, 0);      // coarse
  sweep(6, 1);      // finer + overlap

  // Upscaled retry (helps tiny or slightly blurred codes)
  {
    const scale = 1.5;
    const tmp = document.createElement('canvas');
    tmp.width = Math.floor(canvas.width * scale);
    tmp.height = Math.floor(canvas.height * scale);
    const tctx = tmp.getContext('2d', { willReadFrequently: true });
    tctx.imageSmoothingEnabled = false;
    tctx.drawImage(canvas, 0, 0, tmp.width, tmp.height);

    const img = tctx.getImageData(0, 0, tmp.width, tmp.height);
    const qr = jsQR(img.data, img.width, img.height, { inversionAttempts: 'attemptBoth' });
    if (qr?.data) results.add(qr.data.trim());

    const stepX = Math.floor(tmp.width / 3);
    const stepY = Math.floor(tmp.height / 3);
    for (let gy = 0; gy < 3; gy++) for (let gx = 0; gx < 3; gx++) {
      const x = gx * stepX, y = gy * stepY, w = stepX, h = stepY;
      const sub = tctx.getImageData(x, y, w, h);
      const qr2 = jsQR(sub.data, w, h, { inversionAttempts: 'attemptBoth' });
      if (qr2?.data) results.add(qr2.data.trim());
    }
  }

  return Array.from(results);
}

// ---------- File picker ----------
async function handlePaperFiles(e) {
  const files = Array.from(e.target.files || []);
  if (!files.length) return;

  // reset state
  Object.assign(paperState, { header:null, keyHex:null, tiles:{}, totalTiles:null, seenPayloads:new Set() });
  const status = paperEls.status();
  if (status) status.innerHTML = "";
  setPaperMsg(`Processing ${files.length} file(s)...`);
  updatePaperProgress();

  for (const f of files) {
    if (f.type === "application/pdf" || f.name.toLowerCase().endsWith(".pdf")) {
      await scanPdfFile(f);
    } else {
      await scanImageFile(f);
    }
  }
  updatePaperProgress();
}

// ==============================
// Camera auto-scanner (continuous)
// ==============================
async function startPaperCamera() {
  await stopPaperCamera();
  try {
    camStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
    const video = paperEls.camVideo();
    video.srcObject = camStream;
    video.style.display = 'block';
    await video.play();
    setPaperMsg("Camera started. Hold KEY, HEADER, and CT tiles in view — capture is automatic.");

    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });

    const tick = () => {
      if (!camStream) return;

      const w = video.videoWidth || 640;
      const h = video.videoHeight || 480;
      if (w && h) {
        canvas.width = w;
        canvas.height = h;
        ctx.drawImage(video, 0, 0, w, h);

        // Full frame
        let img = ctx.getImageData(0, 0, w, h);
        let qr  = jsQR(img.data, w, h, { inversionAttempts: "attemptBoth" });
        if (qr?.data) ingestQR(qr.data);

        // Coarse 3×3 to catch off-center
        const GRID = 3;
        for (let gy = 0; gy < GRID; gy++) for (let gx = 0; gx < GRID; gx++) {
          const x = Math.floor((w * gx) / GRID);
          const y = Math.floor((h * gy) / GRID);
          const cw = Math.floor(w / GRID);
          const ch = Math.floor(h / GRID);
          const sub = ctx.getImageData(x, y, cw, ch);
          const q2 = jsQR(sub.data, cw, ch, { inversionAttempts: "attemptBoth" });
          if (q2?.data) ingestQR(q2.data);
        }
      }
      camLoopId = requestAnimationFrame(tick);
    };
    camLoopId = requestAnimationFrame(tick);
  } catch (e) {
    setPaperMsg("Camera error: " + e.message);
  }
  updatePaperProgress();
}

async function stopPaperCamera() {
  if (camLoopId) cancelAnimationFrame(camLoopId);
  camLoopId = null;
  if (camStream) {
    camStream.getTracks().forEach(t => t.stop());
    camStream = null;
  }
  const video = paperEls.camVideo();
  if (video) {
    video.pause();
    video.srcObject = null;
    video.style.display = 'none';
  }
}

// Legacy shims for existing HTML:
function startKeyCam(){ startPaperCamera(); }
function stopKeyCam(){ stopPaperCamera(); }
function snapKeyShare(){
  const video = paperEls.camVideo();
  if (!video || !camStream) return;
  const w = video.videoWidth || 640, h = video.videoHeight || 480;
  const cv = document.createElement('canvas'); cv.width = w; cv.height = h;
  const ctx = cv.getContext('2d', { willReadFrequently: true });
  ctx.drawImage(video, 0, 0, w, h);
  const img = ctx.getImageData(0, 0, w, h);
  const qr = jsQR(img.data, w, h, { inversionAttempts: "attemptBoth" });
  if (qr?.data) ingestQR(qr.data);
}

// ==============================
// Open/Close modal + wiring (updated)
// ==============================
function openPaperDecrypt() {
  // Insert progress UI once
  if (!paperEls.barHost()) {
    const host = document.createElement('div');
    host.id = 'paperProgressHost';
    host.style.cssText = 'width:100%;text-align:left;margin:6px 0;';
    host.innerHTML = `
      <div id="paperProgressText" style="font-size:14px;color:#ccc;margin-bottom:6px;">
        Status — waiting for uploads…
      </div>
      <div style="background:#222;border:1px solid #0f0;border-radius:6px;overflow:hidden;height:12px;">
        <div id="paperProgressBar" style="height:12px;width:0%;background:#00ff99;"></div>
      </div>`;
    const modal = paperEls.modal();
    const status = paperEls.status();
    modal.querySelector('.modal')?.insertBefore(host, status) || modal.insertBefore(host, status);
  }

  // Reset capture state
  Object.assign(paperState, { header:null, keyHex:null, tiles:{}, totalTiles:null, seenPayloads:new Set() });
  const statusEl = paperEls.status();
  if (statusEl) statusEl.innerHTML = "Waiting for uploads...";

  // Reset button look
  const btn = paperEls.rebuildBtn();
  if (btn) { 
    btn.disabled = true; 
    btn.style.opacity = '.4'; 
    btn.style.filter = 'grayscale(100%)'; 
    btn.style.pointerEvents = 'none'; 
  }

  // Bind file input
  const files = paperEls.files();
  if (files) files.onchange = handlePaperFiles;

  // Show modal
  const m = paperEls.modal();
  if (m) m.style.display = 'flex';

  // ❌ Removed auto-start of camera here.
  // ✅ Camera will now only start when the user clicks "Start Camera" (startKeyCam → startPaperCamera).

  // Reset auto-rebuild latch
  window.__mvAutoRebuildDone = false;

  updatePaperProgress();
}

function closePaperDecrypt() {
  stopPaperCamera();
  const m = paperEls.modal();
  if (m) m.style.display = 'none';
}

async function rebuildLiteFromPaper() {
  try {
    const { header, keyHex, tiles, totalTiles } = paperState;
    if (!header) throw new Error("Missing header (MVHDR).");
    if (!keyHex) throw new Error("Missing key (MVKEY).");
    if (!totalTiles) throw new Error("Tiles not detected yet.");

    // 1) Pre-size the ciphertext buffer
    let totalCtBytes = 0;
    for (let i = 1; i <= totalTiles; i++) {
      const part = tiles[i];
      if (!part) throw new Error(`Missing ciphertext tile ${i}/${totalTiles}.`);
      totalCtBytes += base64DecodedLen(part);
    }
    const ctBytes = new Uint8Array(totalCtBytes);

    // 2) Decode each chunk directly into the buffer
    let offset = 0;
    for (let i = 1; i <= totalTiles; i++) {
      const chunkU8 = b64ToU8Direct(tiles[i]);
      ctBytes.set(chunkU8, offset);
      offset += chunkU8.length;
    }

    // 3) Decrypt
    const keyU8 = new Uint8Array(keyHex.match(/.{1,2}/g).map(h => parseInt(h, 16)));
    const aesKey = await crypto.subtle.importKey("raw", keyU8, "AES-GCM", false, ["decrypt"]);
    const ivU8  = new Uint8Array(header.iv);
    const zipBytes = new Uint8Array(
      await crypto.subtle.decrypt({ name: "AES-GCM", iv: ivU8 }, aesKey, ctBytes)
    );

    // 4) Verify
    if (zipBytes.length !== header.size) {
      throw new Error(`Size mismatch (expected ${header.size}, got ${zipBytes.length}).`);
    }
    const gotSha = await sha256Hex(zipBytes);
    if (gotSha !== header.sha256) {
      throw new Error(`SHA-256 mismatch. Expected ${header.sha256}, got ${gotSha}.`);
    }

    // 5) Download + optional auto-import
    const blob = new Blob([zipBytes], { type: "application/zip" });
    const name = "memoro-lite.zip";
    const url  = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url; a.download = name;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);

    setPaperMsg(`✅ Rebuild complete. Download started: ${name}`);

    // Optional auto-import into dashboard vault list
    if (typeof handleVaultZip === 'function') {
      const dt = new DataTransfer();
      dt.items.add(new File([blob], name, { type: "application/zip" }));
      const fakeInput = document.createElement('input');
      fakeInput.type = 'file';
      fakeInput.files = dt.files;
      await handleVaultZip({ target: fakeInput });
      setPaperMsg("ZIP auto-imported into your vault list.");
    }

    // Clean up & close after a short grace period
    stopPaperCamera();
    setTimeout(() => {
      try { URL.revokeObjectURL(url); } catch {}
      closePaperDecrypt();
    }, 5000);

  } catch (err) {
    console.error(err);
    setPaperMsg(`❌ Rebuild failed: ${err.message}`);
    alert(`Rebuild failed: ${err.message}`);
    // allow another auto attempt if user keeps scanning/adding pages
    window.__mvAutoRebuildDone = false;
  }
}

// Expose for UI
window.openPaperDecrypt = openPaperDecrypt;
window.closePaperDecrypt = closePaperDecrypt;
window.rebuildLiteFromPaper = rebuildLiteFromPaper;
window.startKeyCam = startKeyCam;
window.stopKeyCam  = stopKeyCam;
window.snapKeyShare = snapKeyShare;

</script>

</body>
</html>
