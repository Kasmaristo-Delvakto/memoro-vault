<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Recover Your Vault - Memoro Vault</title>
  <script src="libs/zip.min.js"></script>
  <script type="module">
  import init, {
    sha256_hash,
    aes_gcm_encrypt,
    aes_gcm_decrypt,
    argon2_derive
  } from "./wasm/memoro_crypto.js";

  window.initCryptoWasm = async () => {
    await init();
    window.sha256Hash       = (u8) => Promise.resolve(sha256_hash(u8));
    window.aesEncryptRust   = (k,n,p) => Promise.resolve(aes_gcm_encrypt(k,n,p));
    window.aesDecryptRust   = (k,n,c) => Promise.resolve(aes_gcm_decrypt(k,n,c));
    window.argon2DeriveRust = (pwdBytes, saltBytes, t, m, p, len) =>
      argon2_derive(pwdBytes, saltBytes, t, m, p, len);
  };

  window.initCryptoWasm();
</script>

  <link id="theme-cypherpunk" rel="stylesheet" href="css/recover_cypherpunk.css">
  <link id="theme-clean"       rel="stylesheet" href="css/recover_clean.css" disabled>

<script>
  // Theme switcher for recover page
  function applyRecoverTheme(theme) {
    const cy = document.getElementById('theme-cypherpunk');
    const cl = document.getElementById('theme-clean');
    const isCypher = (theme === 'cypherpunk');

    if (cy) cy.disabled = !isCypher;
    if (cl) cl.disabled =  isCypher;

    const setBodyAttr = () => {
      if (document.body) {
        document.body.setAttribute('data-theme', isCypher ? 'cypherpunk' : 'clean');
      }
    };
    if (document.readyState === 'loading') {
      window.addEventListener('DOMContentLoaded', setBodyAttr, { once: true });
    } else {
      setBodyAttr();
    }

    // Matrix control (defined later at bottom of file)
    if (window.RecoverMatrix) {
      if (isCypher) RecoverMatrix.start();
      else RecoverMatrix.stop();
    }
  }

  (function initRecoverTheme(){
const saved =
  sessionStorage.getItem('theme') ??
  localStorage.getItem('theme') ??
  'cypherpunk';
  window.__savedRecoverTheme = saved;

  const cy = document.getElementById('theme-cypherpunk');
  const cl = document.getElementById('theme-clean');
  const isCypher = (saved === 'cypherpunk');
  if (cy) cy.disabled = !isCypher;
  if (cl) cl.disabled =  isCypher;
})();
</script>

</head>
<body>
  <!-- Main heading -->
<h1 id="pageTitle">Recover Your Vault</h1>

<!-- Button to return to dashboard -->
<div class="button-container">
  <button class="button" onclick="backToDashboard()">Return to Dashboard</button>
</div>

<!-- Form for entering recovery answers -->
<form class="recovery-form" id="recoveryForm"></form>

<!-- Button to submit recovery -->
<div class="button-container">
  <button class="button" onclick="submitRecovery()">Recover Vault</button>
</div>

<!-- Modal for displaying recovered vault contents and donation prompt -->
<div id="seedModal" class="modal">
  <div class="modal-content">
    <div class="pow-section">
      <div class="donation-heading">Support Memoro Vault</div>
      <img src="assets/Screenshot (691).png" alt="Monero Donation QR" class="donation-qr">
      <p class="donation-text">
        <span class="donation-strong">Thanks for using Memoro Vault.</span><br>
        If you find it valuable, consider sending a small tip in XMR or your preferred cryptocurrency.
      </p>
      <button class="donation-button"
        onclick="window.memoroAPI.openExternalLink('https://trocador.app/en/anonpay/?ticker_to=xmr&network_to=Mainnet&address=83czGNh6SKbhmjg3wPzeiDRQbN7gkLLqTYSvfMGRQRmKQf1SyQTG88Db67NoBdEvpCii6Qzcxq3BxNt94FDeJutmJ3xBXc6&donation=True&amount=0.1&name=Kasmaristo+Delvakto&description=Memoro+Vault+is+funded+by+donations+only.+Thanks+for+your+support!&ticker_from=xmr&network_from=Mainnet&bgcolor=')">
        Donate with preferred crypto
      </button>
      <div class="donation-subcontainer">
        <p class="donation-subtext">Offline? Paste it into your browser later.</p>
        <button class="donation-button" onclick="copyDonationLink()">Copy Donation Link</button>
      </div>
    </div>

    <div class="pow-section">
      <h2 id="vaultRecoveredHeading" class="vault-recovered">Vault Recovered!</h2>
      <pre id="recoveredSeed" class="recovered-seed"></pre>
      <pre id="finalMessage" class="final-message"></pre>
      <div class="modal-buttons">
        <button onclick="closeSeedModal()">Return to Dashboard</button>
      </div>
    </div>
  </div>
</div>

<!-- Modal for file preview -->
<div id="previewModal" class="modal">
  <div class="modal-content">
    <h2 id="previewTitle">File Preview</h2>
    <div id="previewContent" class="preview-content"></div>
    <div class="modal-buttons">
      <button onclick="closePreview()">Close</button>
    </div>
  </div>
</div>

<!-- Proof-of-work overlay -->
<div id="powOverlay">
  <div id="powMessage">Checking answers... please wait</div>
  <div id="powTerminal"></div>
  <div class="progress-label">Processing...</div>
  <div class="progress-bar-container">
    <div class="progress-bar-fill" id="progressBar"></div>
  </div>
</div>

<!-- Red Herring instruction modal -->
<div id="redHerringModal" class="modal">
  <div class="modal-content">
    <h2 id="redHerringTitle" class="red-herring-title">Pay Attention Before You Begin</h2>
    <p id="redHerringText" class="red-herring-text">
      One of these questions might be a 
      <span class="red-herring-highlight">Red Herring</span>
      —a trick question that’s <u class="underline-strong">not supposed to be answered correctly</u>.
      <br><br>
      If a Red Herring is present, you must 
      <span class="leave-blank">leave it blank</span>. 
      Entering an answer—even the real one—will prevent you from unlocking the vault.
      <br><br>
      <span class="red-herring-highlight">How do I spot it?</span><br>
      Look at the character hint beneath each question. 
      If the expected character count <u class="underline-strong">differs from the real answer by 2 or more characters</u>, it’s likely the Red Herring.
      <br><br>
      <span class="example-label">Example:</span> If your favorite dog’s name was 
      “<code class="example-code">Samantha</code>” (8 letters), but the hint only shows 4 characters, 
      <u class="underline-strong">do not answer that question</u>.
      <br><br>
      There is either 
      <span class="exactly-one">exactly one</span> Red Herring 
      or <span class="exactly-one">none at all</span>—never more than one.
    </p>
    <div class="modal-buttons">
      <button onclick="closeRedHerringModal()">Got it</button>
    </div>
  </div>
</div>

<!-- Matrix effect canvas and overlays -->
<canvas id="matrixCanvas"></canvas>
<div class="overlay" id="matrixOverlay"></div>
<div id="vaultCrackOverlay"></div>
<div id="crackOverlay"></div>
<div id="burstFlash"></div>

<!-- Toast notification -->
<div id="toast" class="toast"></div>

<!-- Spacers (unchanged) -->
<div class="spacer"></div><div class="spacer2"></div><div class="spacer3"></div><div class="spacer4"></div>
<div class="spacer5"></div><div class="spacer6"></div><div class="spacer7"></div><div class="spacer8"></div>
<div class="spacer9"></div><div class="spacer10"></div>


  <script type="module">
  // Initialize WebAssembly crypto module

  // Set up global crypto functions
  window.initCryptoWasm = async () => {
    await init();
    window.sha256Hash = sha256_hash;
    window.deriveKeyRust = derive_key;
    window.aesEncryptRust = aes_gcm_encrypt;
    window.aesDecryptRust = aes_gcm_decrypt;
  };

  window.initCryptoWasm();
  </script>

<script type="module">

  // Set up global crypto functions
  window.initCryptoWasm = async () => {
    await init();
    window.sha256Hash = sha256_hash;
    window.deriveKeyRust = derive_key;
    window.aesEncryptRust = aes_gcm_encrypt;
    window.aesDecryptRust = aes_gcm_decrypt;
  };

  window.initCryptoWasm();
  </script>

<script>
/**
 * BOOTSTRAP (recovery):
 * Reads memoroVaultVaultStorage / <lastVaultId>-transfer,
 * opens the original ZIP blob, and exposes:
 *   window.fileMap        // { [filename]: Blob }
 *   window.loadedVaultZip // adapter with .get(name) -> Blob
 *   window.baseKey
 *   window.vaultJson
 *   window.vaultData
 */
(function hydrateFromIndexedDB(){
  const DB_NAME = "memoroVaultVaultStorage";
  const STORE   = "vaultFiles";

  function openDB(){
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, 1);
      req.onupgradeneeded = (e) => {
        const db = e.target.result;
        if (!db.objectStoreNames.contains(STORE)) {
          db.createObjectStore(STORE, { keyPath: "vaultId" });
        }
      };
      req.onsuccess = (e) => resolve(e.target.result);
      req.onerror   = (e) => reject(new Error("IndexedDB open failed: " + e.target.error));
    });
  }

  function getTransfer(db, vaultId){
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE, "readonly");
      const store = tx.objectStore(STORE);
      const getReq = store.get(vaultId + "-transfer");
      getReq.onsuccess = () => {
        const rec = getReq.result;
        resolve(rec?.data || rec); // support both shapes
      };
      getReq.onerror = () => reject(new Error("Failed to read transfer payload"));
    });
  }

  (async () => {
    const lastId = localStorage.getItem("lastVaultId");
    if (!lastId) { alert("No vault selected for recovery (missing lastVaultId)."); return; }

    const db = await openDB();
    const data = await getTransfer(db, lastId);
    if (!data) { alert("Recovery payload not found. Unlock the vault from the dashboard again."); return; }

    // Expose basic metadata
    window.baseKey   = data.baseKey || "";
    window.vaultJson = data.vaultJson || {};
    window.vaultData = data.decryptedVaultData || {};

    // Rebuild from original ZIP blob if present (✅ preferred)
    const fileMap = {};
    if (data.vaultBlob) {
      // data.vaultBlob is an ArrayBuffer we saved; rewrap as a Blob
      const zipBlob = new Blob([data.vaultBlob], { type: "application/zip" });

      // Read all entries and cache as Blobs
      const zipReader = new zip.ZipReader(new zip.BlobReader(zipBlob));
      const entries   = await zipReader.getEntries();

      for (const entry of entries) {
        // store by exact name AND lowercased alias for tolerant lookup
        const blob = await entry.getData(new zip.BlobWriter());
        fileMap[entry.filename] = blob;
        fileMap[entry.filename.toLowerCase()] = blob;
      }
      await zipReader.close();
    }

    // Fallback: also hydrate anything that was serialized in fileMapRaw
    if (data.fileMapRaw) {
      for (const [name, rec] of Object.entries(data.fileMapRaw)) {
        const u8 = ArrayBuffer.isView(rec.data) ? new Uint8Array(rec.data)
              : Array.isArray(rec.data)        ? new Uint8Array(rec.data)
              : new Uint8Array(0);
        const blob = new Blob([u8], { type: rec.type || "application/octet-stream" });
        fileMap[name] = blob;
        fileMap[name.toLowerCase()] = blob;
      }
    }

    // Provide adapter used by the rest of recover.html
    window.fileMap = fileMap;
    window.loadedVaultZip = {
      async get(name){
        const b = fileMap[name] || fileMap[String(name || "").toLowerCase()];
        if (!b) throw new Error("Missing file: " + name);
        return b;
      }
    };

    console.log("[recover] hydrated", Object.keys(fileMap).length, "entries for", lastId);
  })().catch(err => {
    console.error("[recover] bootstrap failed:", err);
    alert("Could not load your vault from local storage: " + (err.message || err));
  });
})();
</script>

  <script>
    // Get reference to the proof-of-work terminal
    const terminal = document.getElementById("powTerminal");

    // Show a modal with a title and message
    function showMessageModal(title, message) {
      alert(`${title}: ${message}`);
    }

    // Print text to terminal slowly, character by character
    function printLineSlow(line, delay = 30) {
      return new Promise(resolve => {
        let i = 0;
        const interval = setInterval(() => {
          terminal.innerHTML += line[i] || '';
          terminal.scrollTop = terminal.scrollHeight;
          i++;
          if (i >= line.length) {
            clearInterval(interval);
            terminal.innerHTML += '<br>';
            resolve();
          }
        }, delay);
      });
    }

    // Print text to terminal instantly
    function printLineFast(line) {
      terminal.innerHTML += line + '<br>';
      terminal.scrollTop = terminal.scrollHeight;
    }

    // Flush a batch of lines to the terminal
    async function flushBatch(lines) {
      const terminal = document.getElementById("powTerminal");
      const output = lines.map(l => `<div>${l}</div>`).join('');
      terminal.insertAdjacentHTML('beforeend', output);
      const children = terminal.children;
      while (children.length > 50) {
        terminal.removeChild(children[0]);
      }
      terminal.scrollTop = terminal.scrollHeight;
      await new Promise(resolve => setTimeout(resolve, 0));
    }

    // Validate proof-of-work with user answers
    async function validateProofOfWorkWithAnswers(vaultJson, userAnswers) {
      if (!vaultJson?.powSalt || !vaultJson?.powChallengeSalt) {
        throw new Error("Vault is missing PoW salts.");
      }

      const fullConcat = userAnswers.map(a => a.trim().toLowerCase()).join("");
      const baseInput = vaultJson.powSalt + vaultJson.powChallengeSalt + fullConcat;
      const bakedDifficulty = vaultJson.powDifficulty;
      const attempt = window.powAttempt || 1;
      const dynamicDifficulty = getCurrentDifficulty(attempt);

      let batch = [];

      let nonce1 = 0;
      let dynamicSolved = false;

      while (!dynamicSolved) {
        const hashInput = baseInput + nonce1;
        const hash = Array.from(window.sha256Hash(new TextEncoder().encode(hashInput)))
          .map(b => b.toString(16).padStart(2, '0'))
          .join('');

        batch.push(`Nonce ${nonce1} → ${hash.slice(0, 16)}...`);

        if (hash.startsWith(dynamicDifficulty)) {
          dynamicSolved = true;
          await flushBatch(batch);
          await printLineSlow(`Dynamic PoW success at nonce ${nonce1}`);
        }

        nonce1++;
        if (batch.length >= 2500) {
          await flushBatch(batch);
          batch = [];
        }
      }

      vaultJson.powNonce = nonce1.toString();
      await printLineSlow(`[✓] Dynamic PoW complete.`);
    }

    // Convert blob to Uint8Array safely
    async function safeUint8ArrayFromBlob(blob) {
      const buffer = await blob.arrayBuffer();
      if (!buffer || buffer.byteLength < 12) throw new Error("Encrypted data too short to be valid.");
      return new Uint8Array(buffer);
    }

    // Show a single line in the terminal
    function showTerminalLine(text) {
      const terminal = document.getElementById("powTerminal");
      terminal.innerHTML += `> ${text}<br>`;
      if (terminal.innerHTML.split('<br>').length > 100) {
        terminal.innerHTML = terminal.innerHTML.split('<br>').slice(-100).join('<br>');
      }
      terminal.scrollTop = terminal.scrollHeight;
    }

 // Try all permutations of answers (not used in fix)
    async function tryAllAnswerPermutations(groupAnswers, remainingAnswers, groupIndices, remainingIndices, fullConcatSalt, vaultHash, vaultZip, onSuccess) {
      const permutations = getAllPermutations(groupAnswers);
      const encoder = new TextEncoder();

      for (let i = 0; i < permutations.length; i++) {
        const permutedGroup = permutations[i];

        // Build fullAnswers array in correct slot positions
        const fullAnswers = [];
        let g = 0, r = 0;

        for (let idx = 0; idx < groupAnswers.length + remainingAnswers.length; idx++) {
          if (groupIndices.includes(idx)) {
            fullAnswers[idx] = permutedGroup[g++];
          } else {
            fullAnswers[idx] = remainingAnswers[remainingIndices[r++]];
          }
        }

        const hashBytes = await window.sha256Hash(encoder.encode(fullKeyMaterial));
        const computedHash = Array.from(hashBytes).map(b => b.toString(16).padStart(2, '0')).join('');

        if (computedHash === vaultHash) {
          console.log(`✅ Found correct permutation on attempt ${i + 1}`);
          const fullKey = await deriveKey(fullKeyMaterial);

          const vaultJsonBlob = await vaultZip.get("vault.json");
          const vaultJsonText = await vaultJsonBlob.text();
          const vaultJson = JSON.parse(vaultJsonText);

          // Decrypt vault.meta and order.enc
          const { files, seedFiles, restoredOrder } = await decryptVaultMeta(fullKey, fullKey);
          onSuccess({ files, seedFiles, restoredOrder, fullKey, fullAnswers });
          return;
        }
      }

      throw new Error("❌ Failed to find valid permutation that matches vaultHash.");
    }

    
    // Load questions into the recovery form
function loadQuestions(questionList, gateIndices, remainingL2Indices, selectedL2Indices) {
  const orderedIndices = [
    ...gateIndices,
    ...remainingL2Indices,
    ...selectedL2Indices
  ];

  const form = document.getElementById("recoveryForm");
  form.innerHTML = "";

  orderedIndices.forEach((originalIdx, renderIdx) => {
    const q = questionList[originalIdx];
    const block = document.createElement("div");
    block.className = "question-block";
    block.innerHTML = `
      <label for="answer-${renderIdx}"><b>${renderIdx + 1}.</b> ${q.question}</label>
      <input type="text" id="answer-${renderIdx}" class="l2-answer answer-input" data-index="${originalIdx}" required />
      <div class="hint-display" id="hint-${renderIdx}"></div>
    `;
    form.appendChild(block);
    // ✅ Use render index for the DOM element, and pass both
    setTimeout(() => updateHint(renderIdx, originalIdx), 0);
  });

  // Force lowercase typing
  document.querySelectorAll('input.answer-input').forEach(input => {
    input.addEventListener('input', () => {
      input.value = input.value.toLowerCase();
    });
  });
}

// Force lowercase typing for all answer fields
document.querySelectorAll('input.answer-input').forEach(input => {
  input.addEventListener('input', () => {
    input.value = input.value.toLowerCase();
  });
});

function getAnswers(questionList) {
  // Collect answers in the same order as questionList
  const inputs = document.querySelectorAll('.l2-answer');
  const answersByIndex = [];
  inputs.forEach(input => {
    const index = parseInt(input.getAttribute("data-index"));
    if (!isNaN(index)) {
      answersByIndex[index] = input.value.trim().toLowerCase();
    }
  });
  return answersByIndex;
}


async function submitRecovery() {
  const overlay = document.getElementById("powOverlay");
  const terminal = document.getElementById("powTerminal");
  const progressBar = document.getElementById("progressBar");
  const message = document.getElementById("powMessage");

  function bufferToHex(buffer) {
    return Array.from(buffer).map(b => b.toString(16).padStart(2, '0')).join('');
  }

  try {
    overlay.style.display = "flex";
    overlay.style.opacity = "1";
    overlay.style.transition = "none";
    terminal.innerHTML = "";
    progressBar.innerHTML = "";
    message.innerText = "Trying permutations...";

    await printLineSlow("[*] Loading vault...");
    const vaultZip = window.loadedVaultZip;
    if (!vaultZip) throw new Error("No vault ZIP loaded.");

    const vaultJson = JSON.parse(await (await vaultZip.get("vault.json")).text());
    const fullSalt = vaultJson.fullSalt;
    const layer1Salt = vaultJson.layer1Salt;
    const vaultMetaIv = new Uint8Array(vaultJson.vaultMetaIv);
    const argonSettings = vaultJson.argonSettings || {
      time: 3,
      mem: 16384,
      parallelism: 1,
      type: "Argon2id",
      hashLen: 32
};

    const encData = JSON.parse(await (await vaultZip.get("vault.enc")).text());
    const encBytes = new Uint8Array(encData.ciphertext);
    const encIv = new Uint8Array(encData.iv);

    const rawLayer1Key = await deriveRawKeyBytes(window.baseKey, layer1Salt, argonSettings);
    const decrypted = await window.aesDecryptRust(rawLayer1Key, encIv, encBytes);
    const parsed = JSON.parse(new TextDecoder().decode(decrypted));
    const { selectedL2Indices, remainingL2Indices, gateIndices, questionList } = parsed;

    // ✅ Build user answer map using data-index (original indices)
    const userAnswerMap = {};
    document.querySelectorAll('input.answer-input').forEach(input => {
      const index = parseInt(input.getAttribute("data-index"));
      if (!isNaN(index)) {
        userAnswerMap[index] = input.value.trim().toLowerCase();
      }
    });

    if (Object.values(userAnswerMap).every(a => !a)) {
      showToast("Please fill out the recovery answers before proceeding.", "error");
      return;
    }

    const bruteAnswers = selectedL2Indices.map(idx => userAnswerMap[idx]);
    const permutations = generatePermutations(bruteAnswers);
    const totalAttempts = permutations.length;
    await printLineSlow(`[⛏] Brute-forcing ${totalAttempts} permutations...`);

    const totalBlocks = 40;
    for (let i = 0; i < totalBlocks; i++) {
      const block = document.createElement("div");
      block.className = "progress-block";
      progressBar.appendChild(block);
    }

    let attempt = 0;
    let success = false;
    let metaJson = null;
    let finalRawKey = null;
    let finalFullConcat = "";

    for (const permuted of permutations) {
      attempt++;

      const permutedAnswers = [];

      // 🔁 Fill in gate and remaining L2 answers from user input
      gateIndices.forEach(idx => permutedAnswers[idx] = userAnswerMap[idx]);
      remainingL2Indices.forEach(idx => permutedAnswers[idx] = userAnswerMap[idx]);

      // 🔁 Fill in selected L2 answers from current permutation
      selectedL2Indices.forEach((originalIdx, permutedIdx) => {
        permutedAnswers[originalIdx] = permuted[permutedIdx];
      });

      const fullConcat = [
        ...gateIndices.map(idx => permutedAnswers[idx]),
        ...remainingL2Indices.map(idx => permutedAnswers[idx]),
        ...selectedL2Indices.map(idx => permutedAnswers[idx])
      ].join('');

      const rawFullKey = await deriveRawKeyBytes(fullConcat, fullSalt, argonSettings);

      const hashBytes = await sha256Hash(new TextEncoder().encode(fullConcat));
      const hashHex = bufferToHex(hashBytes);
      const hashPreview = hashHex.slice(0, 20);

      printLineFast(`[${attempt}/${totalAttempts}] trying: ${fullConcat.split('').join('|')} → hash=${hashPreview}...`);

      const filledCount = Math.floor((attempt / totalAttempts) * totalBlocks);
      const blocks = progressBar.querySelectorAll(".progress-block");
      blocks.forEach((block, i) => {
        block.classList.toggle("filled", i < filledCount);
      });

      try {
        const metaBlob = await vaultZip.get("vault.meta");
        const metaBuf = new Uint8Array(await metaBlob.arrayBuffer());
        const decryptedMeta = await window.aesDecryptRust(rawFullKey, vaultMetaIv, metaBuf);
        const decodedMeta = new TextDecoder().decode(decryptedMeta);
        metaJson = JSON.parse(decodedMeta);

        if (!metaJson || !Array.isArray(metaJson.files)) {
          throw new Error("vault.meta decrypted but missing or invalid .files array.");
        }

        console.log("[RECOVER] Success on attempt", attempt);
        await printLineSlow(`[✔] Vault unlocked on attempt ${attempt}.`);
        await printLineSlow(`[✔] Final Concat: ${fullConcat}`);
        await printLineSlow(`[✔] Answer Index Order: ${[
          ...gateIndices,
          ...remainingL2Indices,
          ...selectedL2Indices
        ].join(', ')}`);

        await new Promise(resolve => setTimeout(resolve, 3000)); // pause

        finalRawKey = rawFullKey;
        finalFullConcat = fullConcat;
        success = true;
        break;
      } catch (err) {
        // try next permutation silently
      }
    }

    if (success && metaJson && finalRawKey) {
     const decryptedFiles = await decryptVaultDocs(finalRawKey, metaJson.files || [], finalFullConcat);

let finalMessage = "";
try {
  finalMessage = await decryptFinalMessage(finalRawKey, metaJson.files || [], finalFullConcat);
} catch (e) {
  console.warn("Final message unavailable; continuing.", e);
  await printLineFast(`[!] Final message unavailable: ${e.message || e}. Continuing.`);
}

await showRecoveryModal(finalMessage, decryptedFiles);
    } else {
      throw new Error("All permutations exhausted without success. Please review your answers and try again.");
    }

  } catch (err) {
    console.error("❌ submitRecovery failed:", err);
    showMessageModal("Error", err.message || err.toString());
  } finally {
    overlay.style.display = "none";
  }
}

    // Update hint display for a question
    function updateHint(renderIdx, originalIdx) {
  const question = savedQuestions[originalIdx];
  const hintDiv = document.getElementById(`hint-${renderIdx}`);
  if (!question || !hintDiv) return;

  const expectedLength = question.expectedLength || 0;
  const spaceIndexes = Array.isArray(question.spaceIndexes) ? question.spaceIndexes : [];
  const hintLetters = Array.isArray(question.hintLetters) ? question.hintLetters : [];
  const hintValues = Array.isArray(question.hintValues) ? question.hintValues : [];

  let renderedHint = '';
  let letterPos = 1;
  let valueIndex = 0;

  for (let j = 0; j < expectedLength; j++) {
    if (spaceIndexes.includes(j)) {
      renderedHint += ' ';
    } else if (hintLetters.includes(letterPos)) {
      const val = hintValues[valueIndex++];
      renderedHint += val === undefined ? '_' : val;
    } else {
      renderedHint += '_';
    }
    letterPos++;
  }

  const spacedHint = renderedHint.split('').join(' ');
// (optional) tiny sanitizer to avoid injecting raw HTML from question.custom
const escapeHtml = (s) => String(s)
  .replace(/&/g, "&amp;")
  .replace(/</g, "&lt;")
  .replace(/>/g, "&gt;")
  .replace(/"/g, "&quot;")
  .replace(/'/g, "&#039;");

hintDiv.innerHTML = `
  <div class="hint-row">
    <code class="hint-code">${spacedHint}</code>
    ${question.custom ? `<div class="hint-custom-text">Hint: ${escapeHtml(question.custom)}</div>` : ""}
  </div>
`;
}

    // Get nth permutation of an array
    function getNthPermutation(n, length) {
      let remaining = Array.from({length}, (_, i) => i);
      let result = [];
      for (let i = length; i > 0; i--) {
        let fact = 1;
        for (let j = 1; j < i; j++) fact *= j;
        let index = Math.floor(n / fact);
        result.push(remaining.splice(index, 1)[0]);
        n %= fact;
      }
      return result;
    }

    // Generate all permutations of an array
    function generatePermutations(array) {
      if (array.length <= 1) return [array.slice()];
      const result = [];

      for (let i = 0; i < array.length; i++) {
        const current = array[i];
        const remaining = array.slice(0, i).concat(array.slice(i + 1));
        const perms = generatePermutations(remaining);
        for (const perm of perms) {
          result.push([current, ...perm]); // force copy
        }
      }

      return result;
    }

    // Show the seed modal
    function showSeedModal() {
      const modal = document.getElementById("seedModal");
      modal.classList.add("show");
    }

    // AES decryption
    async function aesDecrypt(ciphertext, iv, key) {
      return await crypto.subtle.decrypt(
        { name: "AES-GCM", iv },
        key,
        ciphertext
      );
    }

    // Copy donation link to clipboard
    function copyDonationLink() {
      const url = "https://trocador.app/en/anonpay/?ticker_to=xmr&network_to=Mainnet&address=83czGNh6SKbhmjg3wPzeiDRQbN7gkLLqTYSvfMGRQRmKQf1SyQTG88Db67NoBdEvpCii6Qzcxq3BxNt94FDeJutmJ3xBXc6&donation=True&amount=0.1&name=Kasmaristo+Delvakto&description=Memoro+Vault+is+funded+by+donations+only.+Thanks+for+your+support!&ticker_from=xmr&network_from=Mainnet&bgcolor=";
      navigator.clipboard.writeText(url)
        .then(() => showToast("Donation link copied!", "success"))
        .catch(() => showToast("Failed to copy link.", "error"));
    }

    // Decrypt order blob
    async function decryptOrderBlob(orderData, fullKey) {
      const iv = new Uint8Array(orderData.iv);
      const ciphertext = new Uint8Array(orderData.ciphertext);
      const decrypted = await window.aesDecryptRust(fullKey, iv, ciphertext);
      const decoded = new TextDecoder().decode(decrypted);
      return JSON.parse(decoded).remainingOrder;
    }

// Decrypt final-message.txt (per-file key must match builder’s Rust Argon2id)
async function decryptFinalMessage(fullKeyBytes, filesMeta, fullConcat) {
  const finalMeta = filesMeta.find(f => f.originalName === "final-message.txt");
  if (!finalMeta) { await printLineFast("[*] No final message to decrypt."); return ""; }

  const blob = fileMap[finalMeta.filename];
  if (!blob) throw new Error("Missing final message file");

  const encrypted = await safeUint8ArrayFromBlob(blob);
  if (encrypted.length < 17) return "";

  const enc = new TextEncoder();
  const fileId   = finalMeta.filename.replace(".vaultdoc", "");
  const password = fullConcat + fileId;
  const fileSalt = new Uint8Array(await window.sha256Hash(enc.encode(password)));

  const rawKey = window.argon2DeriveRust(
    enc.encode(password),  // permutedConcat + fileId
    fileSalt,              // SHA-256(permutedConcat + fileId)
    3, 16384, 1, 32
  );

  const iv = new Uint8Array(finalMeta.iv);
  try {
    const decU8 = await window.aesDecryptRust(rawKey, iv, encrypted);
    return new TextDecoder().decode(decU8).trim();
  } catch (e) {
    await printLineFast(`[!] Final message decryption failed: ${e.message || e}`);
    throw new Error("Final message could not be decrypted.");
  }
}

// Decrypt all .vaultdoc files using Rust Argon2id per-file keys
async function decryptVaultDocs(fullKeyRaw, vaultMetaFiles, fullConcat) {
  const recoveredFiles = [];
  const enc = new TextEncoder();

  for (let i = 0; i < vaultMetaFiles.length; i++) {
    const meta = vaultMetaFiles[i];
    try {
      const blob = fileMap[meta.filename];
      if (!blob) { await printLineFast(`[!] Missing ${meta.filename}, skipping.`); continue; }

      const encrypted = await safeUint8ArrayFromBlob(blob);
      if (encrypted.length < 17) { await printLineFast(`[!] ${meta.filename} too short, skipping.`); continue; }

      const fileId   = meta.filename.replace(".vaultdoc", "");
      const password = fullConcat + fileId;
      const fileSalt = new Uint8Array(await window.sha256Hash(enc.encode(password)));

      const rawKey = window.argon2DeriveRust(enc.encode(password), fileSalt, 3, 16384, 1, 32);
      const iv = new Uint8Array(meta.iv);
      const decU8 = await window.aesDecryptRust(rawKey, iv, encrypted);

      const outBlob = new Blob([new Uint8Array(decU8)], {
        type: meta.mimeType || "application/octet-stream"
      });

      recoveredFiles.push({
        name: meta.originalName || meta.filename,
        mime: meta.mimeType || "application/octet-stream",
        blob: outBlob
      });

      await printLineFast(`[+] Decrypted ${meta.filename}`);
    } catch (e) {
      await printLineFast(`[!] Failed to decrypt ${meta.filename}: ${e.message || e}`);
    }
  }

  return recoveredFiles;
}

    // Decrypt vault metadata
    async function decryptVaultMeta(key, orderKey) {
      const vaultZip = window.loadedVaultZip;
      if (!vaultZip) throw new Error("No loaded vault archive found.");

      const vaultMetaBlob = await vaultZip.get("vault.meta");
      const vaultMetaBytes = new Uint8Array(await vaultMetaBlob.arrayBuffer());

      const vaultJsonBlob = await vaultZip.get("vault.json");
      const vaultJson = JSON.parse(await vaultJsonBlob.text());
      const vaultIv = new Uint8Array(vaultJson.vaultMetaIv);

      const decryptedMetaBuf = await window.aesDecryptRust(key, vaultIv, vaultMetaBytes);
      const metaJson = JSON.parse(new TextDecoder().decode(decryptedMetaBuf));

      const orderBlob = await vaultZip.get("order.enc");
      const orderData = JSON.parse(await orderBlob.text());
      const orderIv = new Uint8Array(orderData.iv);
      const ciphertext = new Uint8Array(orderData.ciphertext);

      const decryptedOrderBuf = await window.aesDecryptRust(orderKey, orderIv, ciphertext);
      const parsedOrder = JSON.parse(new TextDecoder().decode(decryptedOrderBuf));
      const restoredOrder = parsedOrder.remainingOrder;

      if (!Array.isArray(restoredOrder)) {
        throw new Error("Decrypted order.enc is missing remainingOrder array.");
      }

      return { ...metaJson, restoredOrder };
    }

    // Close seed modal and exit
    function closeSeedModal() {
      secureExit();
    }

    // Navigate back to dashboard
    function backToDashboard() {
      window.location.href = "dashboard.html";
    }

    // Show toast notification
    function showToast(msg, type = 'error') {
      const toast = document.getElementById("toast");
      toast.innerText = msg;
      toast.style.backgroundColor = type === 'success' ? '#28a745' : '#f55';
      toast.classList.add("show");
      setTimeout(() => toast.classList.remove("show"), 2500);
    }

    // Decrypt order blob (alternative implementation)
    async function decryptOrderBlob(orderData, fullKey) {
      const iv = new Uint8Array(orderData.iv);
      const ciphertext = new Uint8Array(orderData.ciphertext);
      const decrypted = await window.aesDecryptRust(fullKey, iv, ciphertext);
      const decoded = new TextDecoder().decode(decrypted);
      return JSON.parse(decoded).remainingOrder;
    }

    // Rust Argon2id → raw bytes
async function deriveRawKeyBytes(password, saltHex, argonSettings) {
  const enc = new TextEncoder();
  const pwdBytes = enc.encode(password);
  const salt = saltHex
    ? Uint8Array.from(saltHex.match(/.{1,2}/g).map(h => parseInt(h, 16)))
    : new Uint8Array(await crypto.subtle.digest("SHA-256", pwdBytes));
  const s = argonSettings || { time: 3, mem: 16384, parallelism: 1, hashLen: 32 };
  return window.argon2DeriveRust(pwdBytes, salt, s.time, s.mem, s.parallelism, s.hashLen);
}

    // Preview decrypted file
    function previewFile(blob, mimeType) {
      const modal = document.getElementById("previewModal");
      const container = document.getElementById("previewContent");
      container.innerHTML = "";

      if (mimeType.startsWith("image/")) {
        const img = document.createElement("img");
        img.src = URL.createObjectURL(blob);
        img.style.maxWidth = "100%";
        container.appendChild(img);
      } else if (mimeType.startsWith("text/") || mimeType === "application/json") {
        blob.text().then(text => {
          const pre = document.createElement("pre");
          pre.style.whiteSpace = "pre-wrap";
          pre.style.textAlign = "left";
          pre.textContent = text;
          container.appendChild(pre);
        });
      } else {
        container.innerHTML = `<p style="color:#bbb;">Preview not supported for this file type.</p>`;
      }

      modal.style.display = "flex";
    }

    // Close preview modal
    function closePreview() {
      document.getElementById("previewModal").style.display = "none";
    }

     window.onload = async () => {
  try {
    const vaultId = localStorage.getItem("lastVaultId");
    const transferKey = vaultId ? vaultId + "-transfer" : "memoroTransfer";
    console.log("Recovering from transfer key:", transferKey);

    // Load transfer data from IndexedDB or sessionStorage
    const db = await new Promise((resolve, reject) => {
      const req = indexedDB.open("memoroVaultVaultStorage", 1);
      req.onsuccess = (e) => resolve(e.target.result);
      req.onerror = () => reject("Failed to open IndexedDB.");
    });

    const tx = db.transaction("vaultFiles", "readonly");
    const store = tx.objectStore("vaultFiles");

    const transfer = await new Promise((resolve, reject) => {
      const getReq = store.get(transferKey);
      getReq.onsuccess = () => {
        const raw = getReq.result;
        console.log("📦 Raw transfer IndexedDB result:", raw);
        resolve(raw?.data || raw);
      };
      getReq.onerror = () => reject("❌ Transfer data lookup failed.");
    });

    let transferFromStorage = transfer;
    if (!transfer) {
      const sessionData = sessionStorage.getItem("memoroTransfer");
      if (sessionData) {
        console.log("Falling back to sessionStorage:", sessionData);
        transferFromStorage = JSON.parse(sessionData);
      }
    }

    console.log("Transfer data loaded:", transferFromStorage);

    if (!transferFromStorage) throw new Error("Vault transfer data missing.");
    if (!transferFromStorage.vaultBlob || !transferFromStorage.fileMapRaw || !transferFromStorage.vaultJson || !transferFromStorage.baseKey) {
      throw new Error("Incomplete transfer object: missing vaultBlob, fileMapRaw, vaultJson, or baseKey");
    }

    // Load vault ZIP
    const vaultBlob = new Blob([new Uint8Array(transferFromStorage.vaultBlob)], { type: "application/zip" });
    const zipReader = new zip.ZipReader(new zip.BlobReader(vaultBlob));
    const entries = await zipReader.getEntries();

    window.loadedVaultZip = {
      get: async (name) => {
        const entry = entries.find(e => e.filename === name);
        if (!entry) throw new Error(`${name} not found in vault.`);
        return await entry.getData(new zip.BlobWriter());
      },
      getEntries: async () => entries
    };

    // ✅ Rehydrate file map from raw transfer blobs
    window.fileMap = {};
    for (const [filename, raw] of Object.entries(transferFromStorage.fileMapRaw || {})) {
      const blob = new Blob([new Uint8Array(raw.data)], { type: raw.type });
      window.fileMap[filename] = blob;
    }
    console.log("✅ window.fileMap populated:", Object.keys(window.fileMap));

    // Set other metadata
    window.vaultData = transferFromStorage.vaultJson;
    window.unlockKey = transferFromStorage.unlockKey || null;
    window.baseKey = transferFromStorage.baseKey;
    console.log("baseKey set:", window.baseKey);

    // Decrypt vault.enc to load questions
    const encBlob = await window.loadedVaultZip.get("vault.enc");
    const encObj = JSON.parse(await encBlob.text());
    const vaultEncBytes = new Uint8Array(encObj.ciphertext);
    const vaultEncIv = new Uint8Array(encObj.iv);

    const layer1Salt = transferFromStorage.vaultJson.layer1Salt;
    const argonSettings = transferFromStorage.vaultJson.argonSettings || {
      time: 3,
      mem: 16384,
      parallelism: 1,
      type: "Argon2id",
      hashLen: 32
};

    // L1: decrypt vault.enc with Rust AES using key derived from baseKey + layer1Salt
const l1KeyRaw = await deriveRawKeyBytes(window.baseKey, layer1Salt, argonSettings);
let encData;
try {
  const decU8 = await window.aesDecryptRust(l1KeyRaw, vaultEncIv, vaultEncBytes);
  encData = JSON.parse(new TextDecoder().decode(decU8));
  window.savedQuestions     = encData.questionList || [];
  window.selectedL2Indices  = encData.selectedL2Indices || [];
  window.remainingL2Indices = encData.remainingL2Indices || [];
  window.gateIndices        = encData.gateIndices || [];
} catch (e) {
  console.error("Failed to decrypt vault.enc:", e);
  window.savedQuestions = [];
  window.selectedL2Indices = [];
  window.remainingL2Indices = [];
  window.gateIndices = [];
}


    console.log("Loaded vaultData:", window.vaultData);
    console.log("Populated savedQuestions before loadQuestions:", window.savedQuestions);

    // Render the questions
    loadQuestions(
      window.savedQuestions,
      window.gateIndices,
      window.remainingL2Indices,
      window.selectedL2Indices
    );

    document.getElementById("redHerringModal").style.display = "flex";

  } catch (err) {
    console.error("Vault restore failed:", err);
    showToast("Vault transfer failed. Restart from dashboard.");
  }
};

    // Close Red Herring modal
    function closeRedHerringModal() {
      document.getElementById("redHerringModal").style.display = "none";
    }

    // Matrix effect for background
    const canvas = document.getElementById('matrixCanvas');
    const ctx = canvas.getContext('2d');

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890@$%&'.split('');
    const fontSize = 14;
    const columns = Math.floor(canvas.width / fontSize);
    const drops = Array(columns).fill(0);

    function drawMatrix() {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#00ff99';
      ctx.font = `${fontSize}px monospace`;

      for (let i = 0; i < drops.length; i++) {
        const text = letters[Math.floor(Math.random() * letters.length)];
        ctx.fillText(text, i * fontSize, drops[i] * fontSize);
        drops[i]++;
        if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
          drops[i] = 0;
        }
      }
    }

    setInterval(drawMatrix, 66);

    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });

    // Visual effect for vault unlock
    async function burstMatrixEffect() {
      const body = document.body;
      const crackOverlay = document.getElementById('crackOverlay');
      const flash = document.getElementById('burstFlash');

      body.style.animation = 'screenShake 0.1s infinite';
      crackOverlay.style.background = "repeating-linear-gradient(135deg, transparent, transparent 5px, rgba(255,255,255,0.05) 6px)";
      crackOverlay.style.opacity = "1";

      await new Promise(r => setTimeout(r, 1200));

      flash.style.animation = 'crackFlash 0.3s ease-out';
      flash.style.opacity = '1';

      setTimeout(() => {
        flash.style.animation = '';
        flash.style.opacity = '0';
      }, 300);

      await new Promise(r => setTimeout(r, 200));

      body.style.animation = '';
      crackOverlay.style.opacity = "0";

      const modal = document.querySelector('#seedModal');
      modal.style.opacity = '0';
      modal.style.transform = 'scale(1.5)';
      modal.style.transition = 'opacity 0.8s ease-out, transform 0.8s ease-out';

      requestAnimationFrame(() => {
        modal.classList.add('show');
        modal.style.opacity = '1';
        modal.style.transform = 'scale(1)';
      });
    }

    // Show recovery modal with decrypted files
    async function showRecoveryModal(finalMessage, files) {
      const modal = document.getElementById("seedModal");
      const seedBox = document.getElementById("recoveredSeed");
      const messageBox = document.getElementById("finalMessage");

      seedBox.textContent = files.length
        ? `${files.length} file(s) decrypted successfully.`
        : "No files recovered.";

      if (finalMessage) {
        messageBox.textContent = finalMessage;
      }

      const existingLinks = document.getElementById("recoveryFileLinks");
      if (existingLinks) existingLinks.remove();

      const fileLinks = document.createElement("div");
      fileLinks.id = "recoveryFileLinks";
      fileLinks.className = "recovery-file-links";
      const title = document.createElement("h3");
      title.className = "decrypted-files-title";
      title.textContent = "Decrypted Files:";
      fileLinks.appendChild(title);
      
      const zipWriter = new zip.ZipWriter(new zip.BlobWriter("application/zip"));
      const seenNames = new Set();

      // getVaultKeyMaterial.js
function getVaultKeyMaterial({ gateAnswers, knownAnswers, bruteAnswers, gateIndices, knownAnswerIndices, bruteIndices, fullSalt }) {
  // Answers must be placed in the correct slot
  const allAnswers = [];
  const totalLen = gateIndices.length + knownAnswerIndices.length + bruteIndices.length;
  // Find max index
  const maxIndex = Math.max(...gateIndices, ...knownAnswerIndices, ...bruteIndices);
  for (let i = 0; i <= maxIndex; i++) allAnswers[i] = "";
  gateIndices.forEach((idx, i) => { allAnswers[idx] = gateAnswers[i]; });
  knownAnswerIndices.forEach((idx, i) => { allAnswers[idx] = knownAnswers[i]; });
  bruteIndices.forEach((idx, i) => { allAnswers[idx] = bruteAnswers[i]; });
  const fullConcat = allAnswers.join('');
  return fullSalt + fullConcat;
}

// blankRedHerring.js
function blankRedHerring(answers, trapIndex) {
  if (trapIndex !== undefined && trapIndex !== null && trapIndex >= 0 && trapIndex < answers.length) {
    answers = answers.slice();
    answers[trapIndex] = "";
  }
  return answers;
}

      function getUniqueFilename(name) {
        let base = name, ext = "";
        const dotIdx = name.lastIndexOf(".");
        if (dotIdx !== -1) {
          base = name.substring(0, dotIdx);
          ext = name.substring(dotIdx);
        }
        let counter = 1;
        let finalName = name;
        while (seenNames.has(finalName)) {
          finalName = `${base}_${counter++}${ext}`;
        }
        seenNames.add(finalName);
        return finalName;
      }

      for (const file of files) {
        const finalName = getUniqueFilename(file.name);
        await zipWriter.add(finalName, new zip.BlobReader(file.blob));

        const fileEntry = document.createElement("div");
        fileEntry.style.marginBottom = "10px";
        fileEntry.style.display = "flex";
        fileEntry.style.alignItems = "center";

        const link = document.createElement("a");
        link.href = URL.createObjectURL(file.blob);
        link.download = finalName;
        link.innerText = `📎 ${finalName}`;
        link.className = "file-link";
        link.style.marginRight = "12px";

        const previewBtn = document.createElement("button");
        previewBtn.innerText = "Preview";
        previewBtn.onclick = () => previewFile(file.blob, file.blob.type);
        previewBtn.className = "button";
        previewBtn.style.padding = "4px 8px";

        fileEntry.appendChild(link);
        fileEntry.appendChild(previewBtn);
        fileLinks.appendChild(fileEntry);
      }

      const btnRow = document.createElement("div");
      btnRow.className = "btn-row";

      const zipAllBtn = document.createElement("button");
      zipAllBtn.innerText = "Download All as ZIP";
      zipAllBtn.className = "button";
      zipAllBtn.onclick = async () => {
        const zippedBlob = await zipWriter.close();
        const url = URL.createObjectURL(zippedBlob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "Memoro_Recovered_Files.zip";
        a.click();
      };

      const wipeBtn = document.createElement("button");
      wipeBtn.innerText = "Securely Wipe & Exit";
      wipeBtn.className = "button";
      wipeBtn.onclick = secureExit;

      btnRow.appendChild(zipAllBtn);
      btnRow.appendChild(wipeBtn);
      fileLinks.appendChild(btnRow);

      const recoveredBox = document.querySelector("#seedModal .pow-section:nth-of-type(2)");
      recoveredBox.appendChild(fileLinks);

      burstMatrixEffect();
    }

// --- recover.html: replace your existing secureExit() with this ---
async function secureExit() {
  try {
    const THEME_KEY = "theme";

    // Prefer sessionStorage first, then localStorage
    const preserved =
      sessionStorage.getItem(THEME_KEY) ??
      localStorage.getItem(THEME_KEY) ??
      null;

    // Clear everything except THEME_KEY
    function safeClear(store) {
      const keep = new Set([THEME_KEY]);
      for (let i = store.length - 1; i >= 0; i--) {
        const k = store.key(i);
        if (!keep.has(k)) store.removeItem(k);
      }
    }

    safeClear(localStorage);
    safeClear(sessionStorage);

    // Restore preserved theme into BOTH storages so either page can read it
    if (preserved !== null) {
      localStorage.setItem(THEME_KEY, preserved);
      sessionStorage.setItem(THEME_KEY, preserved);
    }

    // Wipe IndexedDBs
    if (indexedDB.databases) {
      const dbs = await indexedDB.databases();
      for (const db of dbs) {
        if (db?.name) indexedDB.deleteDatabase(db.name);
      }
    } else {
      indexedDB.deleteDatabase("memoroVaultVaultStorage");
      indexedDB.deleteDatabase("memoroVaultDB");
    }
  } catch (e) {
    console.warn("Secure exit cleanup issue:", e);
  } finally {
    window.location.href = "dashboard.html";
  }
}

// --- recover.html: replace your existing nukeEverything() with this ---
async function nukeEverything() {
  try {
    const THEME_KEY = "theme";

    // Prefer sessionStorage first, then localStorage
    const preserved =
      sessionStorage.getItem(THEME_KEY) ??
      localStorage.getItem(THEME_KEY) ??
      null;

    // Clear everything except THEME_KEY
    function safeClear(store) {
      const keep = new Set([THEME_KEY]);
      for (let i = store.length - 1; i >= 0; i--) {
        const k = store.key(i);
        if (!keep.has(k)) store.removeItem(k);
      }
    }

    safeClear(localStorage);
    safeClear(sessionStorage);

    // Restore preserved theme into BOTH storages so either page can read it
    if (preserved !== null) {
      localStorage.setItem(THEME_KEY, preserved);
      sessionStorage.setItem(THEME_KEY, preserved);
    }

    // Delete all IndexedDB databases
    if (indexedDB.databases) {
      const dbs = await indexedDB.databases();
      for (const db of dbs) {
        if (db?.name) indexedDB.deleteDatabase(db.name);
      }
    } else {
      indexedDB.deleteDatabase("memoroVaultVaultStorage");
      indexedDB.deleteDatabase("memoroVaultDB");
    }

    console.log("Memoro Vault: Local memory wiped (theme preserved).");
  } catch (err) {
    console.warn("Memoro Vault wipe failed:", err);
  } finally {
    // Send the user back to dashboard after wipe
    window.location.href = "dashboard.html";
  }
}
</script>

  <script>
  // Matrix controller for recover page
  const RecoverMatrix = {
    _interval: null,
    _ctx: null,
    _canvas: null,
    _drops: [],
    _fontSize: 14,
    _letters: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890@$%&'.split(''),

    _draw() {
      const ctx = this._ctx, c = this._canvas;
      ctx.fillStyle = 'rgba(0,0,0,0.15)';
      ctx.fillRect(0, 0, c.width, c.height);
      ctx.fillStyle = '#00ff99';
      ctx.font = `${this._fontSize}px monospace`;

      for (let i = 0; i < this._drops.length; i++) {
        const t = this._letters[Math.floor(Math.random() * this._letters.length)];
        ctx.fillText(t, i * this._fontSize, this._drops[i] * this._fontSize);
        this._drops[i]++;
        if (this._drops[i] * this._fontSize > c.height && Math.random() > 0.975) {
          this._drops[i] = 0;
        }
      }
    },

    _resize() {
      const c = this._canvas;
      c.width = window.innerWidth;
      c.height = window.innerHeight;
      const cols = Math.floor(c.width / this._fontSize);
      this._drops = Array(cols).fill(0);
    },

    start() {
      if (this._interval) return;
      if (!this._canvas) {
        this._canvas = document.getElementById("matrixCanvas");
        if (!this._canvas) return;
        this._ctx = this._canvas.getContext("2d");
        window.addEventListener('resize', () => this._resize());
      }
      this._resize();
      this._canvas.style.display = 'block';
      this._interval = setInterval(() => this._draw(), 66);
    },

    stop() {
      if (this._interval) {
        clearInterval(this._interval);
        this._interval = null;
      }
      if (this._canvas && this._ctx) {
        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
        this._canvas.style.display = 'none';
      }
    }
  };

  // Apply theme + maybe start matrix once DOM is ready
  window.addEventListener('DOMContentLoaded', () => {
    applyRecoverTheme(window.__savedRecoverTheme || 'cypherpunk');
  });
</script>
</body>
</html>