<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Answer Your Questions - Memoro Vault</title>
  <script src="libs/zxcvbn.js"></script>

  <style>
  body {
    background-color: black;
    color: #00ff99;
    font-family: 'Fira Code', monospace;
    margin: 0;
    padding: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  canvas {
    position: fixed;
    top: 0;
    left: 0;
    z-index: -2;
  }

  .matrix-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.75);
    z-index: -1;
  }

  h1 {
    font-size: 32px;
    margin-bottom: 10px;
  }

  #countdown {
    font-size: 18px;
    color: #0f0;
    margin-bottom: 20px;
  }

  h1, #countdown {
    text-align: center;
    width: 100%;
  }

  .question-form {
    width: 100%;
    max-width: 900px;
    display: flex;
    flex-direction: column;
  }

  .question-block {
    background-color: #111;
    padding: 15px;
    margin-bottom: 15px;
    border-radius: 8px;
    display: grid;
    grid-template-columns: 3fr 1fr auto;
    gap: 10px;
    align-items: center;
    border: 1px solid #0f0;
  }

  /* Force Red Herring checkbox to drop below earlier */
@media (max-width: 650px) {
  .question-block {
    grid-template-columns: 1fr;  /* stack everything */
    gap: 12px;
  }
}

  label {
    font-size: 16px;
    margin-bottom: 5px;
    word-break: break-word;
    white-space: normal;
  }

  .input-group {
    display: flex;
    flex-direction: column;
  }

  input[type="text"], textarea, select {
    padding: 10px;
    border-radius: 6px;
    border: none;
    background-color: #222;
    color: #0f0;
    font-size: 16px;
  }

  .button-container {
  display: flex;
  justify-content: center;
  flex-wrap: wrap; /* âœ… wrap on overflow instead of stacking immediately */
  gap: 10px;
  margin-top: 30px;
  width: 100%;
}

.button {
  background-color: #222;
  color: #00ff99;
  border: 1px solid #00ff99;
  padding: 12px 20px;
  font-size: 16px;
  border-radius: 8px;
  cursor: pointer;
  min-width: 120px;         /* âœ… prevents buttons from shrinking too small */
  flex: 1 1 auto;            /* âœ… allows flexible spacing side-by-side */
  text-align: center;
  white-space: nowrap;
}

.button:hover {
  background-color: #333;
}

  #fileUploadLabel {
    display: inline-block;
    padding: 10px 20px;
    background-color: #002611;
    color: #00ff99;
    border: 1px solid #00ff99;
    border-radius: 8px;
    font-size: 16px;
    font-family: 'Fira Code', monospace;
    cursor: pointer;
    transition: background-color 0.3s, transform 0.2s;
    box-shadow: 0 0 6px #00ff99;
  }

  #fileUploadLabel:hover {
    background-color: #004422;
    transform: translateY(-1px);
  }

  .modal {
    display: none;
    position: fixed;
    z-index: 9999;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.75);
    align-items: flex-start;
    justify-content: center;
    overflow: auto;
    padding: 60px;
    box-sizing: border-box;
  }

  .modal-content {
    background-color: #111;
    padding: 30px;
    border-radius: 10px;
    text-align: center;
    width: 90%;
    max-width: 400px;
    border: 1px solid #00ff99;
    max-height: 90vh;
    overflow-y: auto;
  }

  .modal-buttons {
    margin-top: 20px;
    display: flex;
    justify-content: center;
    gap: 10px;
  }

  .modal-buttons button {
    background-color: #006600;
    color: #fff;
    border: none;
    padding: 10px 20px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 16px;
  }

  .modal-buttons button:hover {
    background-color: #009900;
  }

  .modal.fade-out {
    opacity: 0;
    pointer-events: none;
  }

  #letterSelectors {
    max-height: 250px;
    overflow-y: auto;
    padding-right: 6px;
    border: 1px solid #00ff99;
    border-radius: 6px;
  }

  input[type="checkbox"] {
    appearance: none;
    -webkit-appearance: none;
    background-color: #000;
    border: 2px solid #00ff99;
    width: 18px;
    height: 18px;
    border-radius: 4px;
    cursor: pointer;
    position: relative;
    vertical-align: middle;
    margin-right: 8px;
    display: inline-block;
    box-shadow: 0 0 5px rgba(0,255,153,0.5);
  }

  input[type="checkbox"]:checked::after {
    content: "âœ”";
    color: #00ff99;
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    font-size: 14px;
    font-weight: bold;
    line-height: 1;
  }

  input[type="checkbox"]:hover {
    box-shadow: 0 0 8px #00ff99;
  }

  #messageModal {
    z-index: 10000;
  }

  .info-icon {
    color: #00ff99;
    cursor: pointer;
    font-weight: bold;
    font-size: 16px;
    padding: 0 4px;
    border: 1px solid #00ff99;
    border-radius: 50%;
    line-height: 1;
    display: inline-block;
    text-align: center;
    width: 18px;
    height: 18px;
    transition: background 0.3s ease;
  }

  .info-icon:hover {
    background-color: #00ff99;
    color: #000;
  }

 .modal {
  display: none;               /* <-- keep it hidden by default */
  position: fixed;
  z-index: 9999;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0,0,0,0.75);
  align-items: center;
  justify-content: center;
  padding: 5px;
  box-sizing: border-box;
}

.modal-content {
  background-color: #111;
  padding: 30px;
  border-radius: 10px;
  text-align: left;
  width: 95vw;
  max-width: 95vw;
  border: 1px solid #00ff99;
}

  @media (max-width: 420px) {
  .button {
    font-size: 14px;
    padding: 10px 14px;
    min-width: 90px;
  }

    h1 {
      font-size: 22px;
    }

    #countdown {
      font-size: 16px;
    }

    .question-form {
      max-width: 100%;
    }

    .question-block {
      grid-template-columns: 1fr;
      padding: 12px;
      gap: 12px;
    }

    .button-container {
      flex-direction: column;
      align-items: stretch;
    }

    .button {
      width: 100%;
      font-size: 16px;
      padding: 12px;
    }

    .modal-content {
  background-color: #111;
  padding: 20px; /* âœ… was 30â€“40px, now reduced */
  border-radius: 10px;
  border: 1px solid #00ff99;
  color: #ccc;
  width: 100%;
  max-width: 800px;
  box-sizing: border-box;
  text-align: left;
  font-size: 16px;
  line-height: 1.5;
}

#trapModal .modal-content {
  margin-bottom: 30px; /* slightly reduced */
}


    input[type="text"], textarea, select {
      font-size: 15px;
    }

    label {
      font-size: 15px;
    }

    #fileUploadLabel {
      font-size: 14px;
      padding: 8px 16px;
    }

    .info-icon {
      font-size: 14px;
      width: 16px;
      height: 16px;
    }

    #letterSelectors select {
      font-size: 14px;
    }

    .modal-buttons button {
      font-size: 14px;
      padding: 8px 16px;
    }
  }

  /* Default: scrollable on larger screens */
.ascii-table-wrapper {
  width: 100%;
  overflow-x: auto;
  padding: 0;
  margin: 0;
  text-align: left;
}

.ascii-table {
  background-color: black;
  color: #00ff99;
  padding: 15px;
  font-family: 'Fira Code', monospace;
  font-size: 14px;
  line-height: 1.3;
  white-space: pre;
  display: block;
  border-radius: 6px;
  min-width: fit-content;
  margin: 0;
}

/* ğŸ“± Small screens: shrink to fit instead of scrolling */
@media (max-width: 600px) {
  .ascii-table-wrapper {
    overflow-x: hidden;   /* no horizontal scroll */
  }
  .ascii-table {
    display: block;
    white-space: pre-wrap; /* âœ… wrap long lines */
    word-break: break-word; 
    font-size: 10px;       /* âœ… shrink font size */
    width: 100%;           /* âœ… force full width of screen */
    min-width: unset;      /* âœ… no forced min-width */
    overflow-wrap: anywhere;
  }
}

</style>

</head>

<body>

<canvas id="matrixCanvas"></canvas>
<div class="matrix-overlay"></div>


<h1>Answer Your Questions and Upload Files</h1>
<div id="countdown"></div>

<form class="question-form" id="answerForm">

</form>

<div id="extraSeedsSection" style="margin-top: 30px; width: 100%; max-width: 900px;">
  <!-- Extra seed inputs will go here if needed -->
</div>

<div id="totalEntropyContainer" style="margin: 30px auto 0 auto; width: fit-content; text-align: center; border: 1px solid #0f0; padding: 12px 24px; border-radius: 8px; background-color: #111; box-shadow: 0 0 8px #0f0;">
  <p style="font-size: 16px; color: #ccc;">
    Estimated Vault Strength:
    <span id="totalEntropyBits" style="color:#00ff99;">0.0</span> bits â€”
    <span id="entropyAssessment" style="color:#ff3333;">Very Weak</span>
    <br>
    <span style="color:#ccc; font-size: 14px;">
      Total Combinations: <span id="totalCombinations" style="color:#00ff99;">0</span>
    </span>
    <span style="color:#aaa; font-size: 13px;">
      Estimated Crack Time: <span id="estimatedCrackTime" style="color:#ff9933;">Instantly crackable</span><br>
      <em style="color:#777;">(assuming 1 trillion guesses/sec â€” botnet-level offline attack)</em>
    </span>
    <br>
    <span id="crackabilityTier" style="display: block; margin-top: 8px; font-size: 14px; color: #ff3333;"></span>
    <span style="color: #888; font-size: 13px; display: block; margin-top: 4px;">
      This estimation does not factor in the potential for phishing, coercion, or social engineering â€” never share personal details.
    </span>
  </p>
</div>


<details style="margin-top: 30px; color: #0f0;">
  <summary style="cursor: pointer; font-size: 16px;">What is entropy and how is my vault protected?</summary>
  <div style="margin-top: 15px; font-size: 15px; color: #ccc; line-height: 1.6;">

    <p><strong>Entropy</strong> is a measure of unpredictability â€” how many guesses an attacker would need to crack your answers. Memoro Vault uses <code>zxcvbn</code>, a password strength estimator from Dropbox, to evaluate the entropy of each response. We calculate this conservatively â€” assuming only 26 lowercase letters and no symbols â€” to ensure you're not overestimating security.</p>

    <p>We assume <strong>the worst-case scenario</strong>: global adversaries with the fastest hardware on Earth.</p>

    <div class="ascii-table-wrapper">
  <pre class="ascii-table">
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  ASSUMED ATTACKER HARDWARE         |   GUESSES/SEC   |   TIME TO CRACK     â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Consumer GPU (RTX 4090)           |   45B/sec       |   40-bit: ~24 sec   â•‘
â•‘                                    |                 |   80-bit: ~27M yrs  â•‘
â•‘                                    |                 |   120-bit: 10Â²â´ yrs â•‘
â•Ÿâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¢
â•‘  Enterprise Cluster (A100s)        |   1T/sec        |   40-bit: ~1.1 sec  â•‘
â•‘                                    |                 |   80-bit: ~38K yrs  â•‘
â•‘                                    |                 |   120-bit: 10Â²Â¹ yrs â•‘
â•Ÿâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¢
â•‘  Nation-State Supercluster         |  100T/sec       |   40-bit: ~0.01 sec â•‘
â•‘                                    |                 |   80-bit: ~384 yrs  â•‘
â•‘                                    |                 |   120-bit: 10Â¹â¹ yrs â•‘
â•‘                                    |                 |   180-bit: 10â´â° yrs â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  </pre>
</div>



    <p>Memoro Vault uses this to classify your vault strength:</p>

    <ul style="margin-left: 20px;">
  <li><strong style="color:#ff3333;">Very Weak</strong>: under 40 bits â€” crackable in seconds to minutes</li>
  <li><strong style="color:#ff9933;">Weak</strong>: 40â€“79 bits â€” crackable in minutes to months</li>
  <li><strong style="color:#ffff66;">Moderate</strong>: 80â€“119 bits â€” could take decades to millions of years</li>
  <li><strong style="color:#66ff66;">Strong</strong>: 120â€“179 bits â€” would take longer than the age of the universe using todayâ€™s best hardware</li>
  <li><strong style="color:#00ff99;">Very Strong</strong>: 180+ bits â€” beyond the reach of any current or foreseeable brute-force attack</li>
    </ul>


    <p>Even one weak answer can collapse your vault. To strengthen it:</p>
    <ul style="margin-left: 20px;">
      <li>Use answers that only trusted people would know â€” not Google, Facebook, or public records</li>
      <li>Avoid names, birthplaces, and dates â€” these can often be socially engineered</li>
      <li>Use symbolic, metaphorical, or abstract memories, not surface facts</li>
      <li>Mix short and long structures and avoid patterns (like â€œjohn2024â€)</li>
    </ul>

    <p>Memoro Vault provides no hints, no partial credit, and no feedback on incorrect input. To unlock the vault, users must enter the exact correct answers for all questions, and for six of them, they must also provide the correct order. This creates a layered security model: the decryption key is only derived if every answer is 100% accurate, and the six ordered answers match the precise sequence used during vault creation. With no indication of which part is wrong, attackers must blindly guess both content and order across hundreds of possibilitiesâ€”making brute-force attempts impractical and expensive.</p>

  </div>
</details>


<!-- Multi-seed input section -->
<div id="multiSeedSection" style="margin-top: 40px; width: 100%; max-width: 900px;">
  <h2 style="color:#0f0;">Saved Seed or Password Files</h2>
  <div class="input-group">
    <label for="newSeedName">Seed File/Password Name:</label>
    <input type="text" id="newSeedName" placeholder="e.g. Primary Wallet" />
  </div>
  <div class="input-group" style="margin-top:10px;">
    <label for="newSeedContent">Seed Phrase or Password:</label>
    <textarea id="newSeedContent" rows="3" placeholder="type or paste seed phrase or private passphrase here"></textarea>
  </div>
  <button class="button" type="button" onclick="saveNamedSeed()">Save Password/Seed File</button>
  <div id="namedSeedsList" style="margin-top: 20px;"></div>
</div>

<div class="input-group" style="margin-top: 40px; width: 100%; max-width: 900px;">
  <label for="fileUpload" style="font-size: 18px;">Optional: Upload Documents to Include in Your Vault</label>
<div style="display: flex; align-items: center; gap: 12px;">
<input type="file" id="fileUpload" multiple hidden />
<label for="fileUpload" id="fileUploadLabel">Choose Files</label>
<span id="fileUploadStatus" style="color: #0f0; font-size: 16px;">No files uploaded</span>
</div>
  <p style="font-size: 14px; color: #aaa; margin-top: 5px;">You can upload files like text notes, images, or scanned documents (up to ~250MB depending on device hardware).</p>
</div>

<div id="uploadedFileList" style="margin-top: 20px; width: 100%; max-width: 900px;"></div>

<div class="input-group" style="margin-top: 40px; width: 100%; max-width: 900px;">
  <label for="finalMessage" style="font-size: 18px;">Optional: Final Message for Yourself or Your Family</label>
  <textarea id="finalMessage" rows="4" placeholder="Example: 'Looks like someone was ACTUALLY listening to all those rants I gave at family dinner. Congratulations!'"></textarea>
  <p style="font-size: 14px; color: #aaa; margin-top: 5px;">This message will be stored securely with your vault.</p>
</div>

<div class="button-container">
  <button class="button" type="button" onclick="goBack()">â† Back</button>
  <button class="button" type="button" onclick="submitAnswers()">Create Vault</button>
  <button class="button" type="button" onclick="startSecurityTimer()">Reset Timer</button>
</div>

<!-- Modals -->
<div id="messageModal" class="modal">
  <div class="modal-content">
    <h2 id="messageModalTitle">Notice</h2>
    <p id="messageModalText">Message here</p>
    <div class="modal-buttons">
      <button onclick="closeMessageModal()">OK</button>
    </div>
  </div>
</div>

<div id="hintModal" class="modal">
  <div class="modal-content">
  <h2>Hint Options</h2>

  <!-- NEW: show length toggle -->
  <div class="input-group" style="margin-bottom: 14px;">
    <label>
      <input type="checkbox" id="showLength" checked>
      Show answer length during unlock
    </label>
  </div>

  <!-- Existing letter/position hint controls -->
  <div class="input-group">
    <label>Reveal specific letters from the answer</label>
    <select id="numLetters" onchange="buildLetterSelectors()"></select>
  </div>
  <div id="letterSelectors" class="input-group" style="margin-top: 15px;"></div>

  <div class="input-group" style="margin-top: 20px;">
    <label>Optional: Custom Hint Text</label>
    <textarea id="customHintText" rows="2" placeholder="Example: 'At the park'..."></textarea>
  </div>

  <div class="modal-buttons">
    <button onclick="saveCustomHint()">Save</button>
    <button onclick="closeHintModal()">Cancel</button>
  </div>
</div>
</div>

<script>

function openVaultDB(version = 2) {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('memoroVaultDB', version);

    request.onupgradeneeded = function (event) {
      const db = event.target.result;
      if (!db.objectStoreNames.contains('vaultFiles')) {
        db.createObjectStore('vaultFiles', { keyPath: 'id' });
      }
      if (!db.objectStoreNames.contains('vaultUserData')) {
        db.createObjectStore('vaultUserData', { keyPath: 'id' });
      }
    };

    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

async function handleFileStorageUpload(event) {
  const fileUpload = document.getElementById('fileUpload');
  const selectedFiles = Array.from(event.target.files);
  fileUpload.value = null; // âœ… allow re-uploading the same files

  if (selectedFiles.length === 0) return;

  const newFiles = selectedFiles.map(f => ({ file: f, id: crypto.randomUUID() }));
  const existingMeta = JSON.parse(localStorage.getItem('uploadedFileMeta') || '[]');
  const newMeta = [];
  const processedFiles = [];

  for (const { file, id } of newFiles) {
    try {
      const arrayBuffer = await file.arrayBuffer();
      processedFiles.push({
        id,
        name: file.name,
        size: file.size,
        type: file.type,
        raw: arrayBuffer
      });
      newMeta.push({ id, name: file.name, size: file.size, type: file.type });
    } catch (err) {
      console.warn('File unreadable:', file.name, err);
    }
  }

  const combinedMeta = [...existingMeta, ...newMeta];

  openVaultDB().then(db => {
  const tx = db.transaction('vaultFiles', 'readwrite');
  const store = tx.objectStore('vaultFiles');
  for (const file of processedFiles) {
    store.put(file);
  }
  tx.oncomplete = () => {
    db.close();
    localStorage.setItem('uploadedFileMeta', JSON.stringify(combinedMeta));
    displayUploadedFiles();
  };
}).catch(async (err) => {
  if (err.name === 'NotFoundError' || err.message.includes('object store')) {
    indexedDB.deleteDatabase('memoroVaultDB'); // Clear broken DB
    showMessageModal("IndexedDB Reset", "A missing data store was detected. The vault database has been reset. Please try uploading your files again.");
  } else {
    showMessageModal("IndexedDB Error", "Unexpected error: " + err.message);
  }
});

}

function displayUploadedFiles() {
  const container = document.getElementById('uploadedFileList');
  const status = document.getElementById('fileUploadStatus');
  if (!container) return;
  container.innerHTML = '';

  const storedFiles = JSON.parse(localStorage.getItem('uploadedFileMeta') || '[]');

  storedFiles.forEach(file => {
    const entry = document.createElement('div');
    entry.style.display = 'flex';
    entry.style.justifyContent = 'space-between';
    entry.style.alignItems = 'center';
    entry.style.marginBottom = '6px';
    entry.style.padding = '10px';
    entry.style.border = '1px solid #00ff99';
    entry.style.borderRadius = '8px';
    entry.style.backgroundColor = '#111';

    const fileLabel = document.createElement('span');
    fileLabel.textContent = `ğŸ“„ ${file.name} (${Math.round(file.size / 1024)} KB)`;
    fileLabel.style.color = '#00ff99';

    const removeBtn = document.createElement('button');
    removeBtn.textContent = 'Remove';
    removeBtn.style.marginLeft = '10px';
    removeBtn.style.padding = '4px 12px';
    removeBtn.style.backgroundColor = '#550000';
    removeBtn.style.color = '#fff';
    removeBtn.style.border = 'none';
    removeBtn.style.borderRadius = '6px';
    removeBtn.style.cursor = 'pointer';

    removeBtn.onclick = () => {
      const updatedMeta = storedFiles.filter(f => f.id !== file.id);
      localStorage.setItem('uploadedFileMeta', JSON.stringify(updatedMeta));

      const req = indexedDB.open('memoroVaultDB');
      req.onsuccess = function () {
        const db = req.result;
        const tx = db.transaction('vaultFiles', 'readwrite');
        const store = tx.objectStore('vaultFiles');
        store.delete(file.id);
        tx.oncomplete = () => {
          db.close();
          displayUploadedFiles(); // refresh
        };
      };
    };

    entry.appendChild(fileLabel);
    entry.appendChild(removeBtn);
    container.appendChild(entry);
  });

  // Update status label
  if (status) {
    const count = storedFiles.length;
    status.textContent = count === 0 ? 'No files uploaded' : `${count} file${count !== 1 ? 's' : ''} uploaded`;
  }
}

// Add this to your onload:
window.addEventListener('DOMContentLoaded', () => {
  const fileUpload = document.getElementById('fileUpload');
  if (fileUpload) fileUpload.addEventListener('change', handleFileStorageUpload);
  displayUploadedFiles();
});

  const savedQuestions = JSON.parse(localStorage.getItem('questions')) || [];
  let securityTimeout;
  let remainingTime = 1800; // 30 minutes in seconds
  
  function startSecurityTimer() {
  clearTimeout(securityTimeout);
  remainingTime = 1800; // Reset to 30 minutes
  updateCountdownDisplay();
  securityTimeout = setInterval(() => {
    remainingTime--;
    updateCountdownDisplay();
    if (remainingTime <= 0) {
      securelyClearSensitiveData();
      alert('Session expired for your security. Sensitive data has been cleared.');
      window.location.href = "dashboard.html";
    }
  }, 1000);
}

  function extendTimer() {
    remainingTime += 5; // Add 5 seconds for any user interaction
  }
  
  // Countdown clock display
  function updateCountdownDisplay() {
    const timerElement = document.getElementById('countdown');
    if (!timerElement) return;
    const minutes = Math.floor(remainingTime / 60);
    const seconds = remainingTime % 60;
    timerElement.textContent = `Sensitive Data Will Be Securely Erased In: ${minutes}:${seconds.toString().padStart(2, '0')}`;
  }
  
  const defaultQuestions = [
    "What was the name of your childhood best friend?",
    "What was the street name where you grew up?",
    "What is your oldest siblingâ€™s middle name?",
    "What was the name of your first pet?",
    "What city were you born in?",
    "What is the name of your favorite childhood teacher?",
    "What was the make of your first car?",
    "What is the middle name of one of your grandparents?",
    "What is the title of your favorite childhood book?",
    "What was the mascot of your high school?",
    "What was your favorite vacation spot as a kid?",
    "What was the name of your first boss?",
    "What was the color of your childhood bedroom walls?",
    "What was your childhood dream job?",
    "Whatâ€™s the first concert you ever attended?",
    "Whatâ€™s the name of your favorite stuffed animal or toy?",
    "What was the first videogame you remember playing?",
    "What was your childhood nickname?",
    "What is your mother's mother's maiden name?",
    "What is the name of the first street you lived on?",
    "What was your favorite childhood meal?",
    "What was your favorite cartoon growing up?",
    "Who was your favorite childhood hero?",
    "What is a weird family tradition you had growing up?"
  ];
  
  let activeHintIndex = null;
  let customHints = {};
  
  function loadQuestions() {
  const form = document.getElementById('answerForm');
  const numberOfQuestions = parseInt(localStorage.getItem('questionCount')) || 12;

  for (let i = 0; i < numberOfQuestions; i++) {
    const questionText = savedQuestions[i] || defaultQuestions[i];

    const block = document.createElement('div');
    block.className = 'question-block';
    block.innerHTML = `
      <div class="input-group" style="grid-column: 1 / 2;">
        <label><b>${i + 1}.</b> ${questionText}</label>
        <input type="text"
          id="answer-${i}"
          placeholder="Your answer"
          required
          oninput="forceLowercase(this); refreshHintModal(); updateEntropy(${i})"
          onpaste="handlePaste(event, ${i})"
        >
      </div>

      <div style="display: flex; align-items: center;">
  <input type="checkbox"
    id="hint-options-${i}"
    onchange="if(this.checked) openHintModal(${i})"
  >
  <span style="line-height: 1;">Hint Options</span>
</div>


      <div style="display: flex; align-items: center; gap: 6px;">
  <label style="margin: 0;">
    <input type="checkbox"
      class="trap-checkbox"
      data-index="${i}"
    >
    Use as <strong style="color:#00ff99;">Red Herring</strong>
  </label>
  <span class="info-icon"
        onclick="event.stopPropagation(); document.getElementById('trapModal').style.display='flex';"
        title="What is a Red Herring?">â„¹</span>
</div>


      <div id="entropy-${i}" style="grid-column: 1 / -1; text-align: right; font-size: 14px; color: #0f0; margin-top: 6px;">
        Entropy: 0.0 bits
      </div>
</div>

    `;

    form.appendChild(block);
    updateEntropy(i); // Initialize entropy

    if (i === numberOfQuestions - 1) {
  attachTrapCheckboxHandlers();
}

  }
}

    function attachTrapCheckboxHandlers() {
  const checkboxes = document.querySelectorAll('.trap-checkbox');

  checkboxes.forEach(cb => {
    cb.addEventListener('change', () => {
      const selectedIndex = parseInt(cb.dataset.index);

      // Prevent selecting a Layer 1 question as Red Herring
      if (selectedIndex < 2 && cb.checked) {
        cb.checked = false;
        showMessageModal(
          "Invalid Red Herring",
          "You cannot select one of the Layer 1 unlock questions as a red herring. Please choose a different question."
        );
        return;
      }

      if (cb.checked) {
        // Check if any other is already selected
        const alreadySelected = Array.from(checkboxes).find(other => other !== cb && other.checked);
        if (alreadySelected) {
          // âŒ Disallow second selection
          cb.checked = false;
          showMessageModal(
            "Only One Red Herring Allowed",
            "You can only select one question as the Red Herring."
          );
        }
      }
    });
  });
}

  function goBack() {
    window.history.back();
  }
  
  async function submitAnswers() {
  const answers = [];
  const normalizedAnswers = [];
  const spaceIndexesList = [];
  const seeds = [];
  const answerInputs = document.querySelectorAll('input[id^="answer-"]');
  const seedInputs = document.querySelectorAll('input[id^="seed-"]');
  const finalMessage = document.getElementById('finalMessage').value.trim();
  let trapIndex = -1;

  document.querySelectorAll('.trap-checkbox').forEach(cb => {
    if (cb.checked) trapIndex = parseInt(cb.dataset.index);
  });

  answerInputs.forEach(input => {
    const raw = input.value.trim();
    answers.push(raw);
    normalizedAnswers.push(raw.toLowerCase());

    const spaceIndexes = [];
    for (let i = 0; i < raw.length; i++) {
      if (raw[i] === ' ') spaceIndexes.push(i);
    }
    spaceIndexesList.push(spaceIndexes);
  });

  seedInputs.forEach(input => seeds.push(input.value.trim()));

  const vaultType = localStorage.getItem('selectedVaultType');
  const isCryptoVault = !(vaultType === 'docs-only' || vaultType === 'crypto-docs');

  if (answers.some(a => a === '') || (isCryptoVault && seeds.some(s => s === ''))) {
    showMessageModal('Missing Information', 'Please fill in all answers' + (isCryptoVault ? ' and all seed words.' : '.'));
    return;
  }

  // Use bulkSeedPhrase if available
  const bulkSeed = JSON.parse(localStorage.getItem('bulkSeedPhrase') || '[]');
  const finalSeeds = bulkSeed.length > seeds.length ? bulkSeed : seeds;

  const unlockIndexes = JSON.parse(localStorage.getItem('unlockQuestions')) || [0, 1];
  const questionCount = parseInt(localStorage.getItem('questionCount')) || 12;
  const questions = JSON.parse(localStorage.getItem('questions')) || [];

  const req = indexedDB.open('memoroVaultDB', 2);

  req.onupgradeneeded = function (e) {
    const db = e.target.result;
    if (!db.objectStoreNames.contains('vaultUserData')) {
      db.createObjectStore('vaultUserData', { keyPath: 'id' });
    }
  };

  req.onsuccess = function () {
    const db = req.result;
    const tx = db.transaction('vaultUserData', 'readwrite');
    const store = tx.objectStore('vaultUserData');
    const finalTrapIndex = getSelectedTrapIndex();
if (finalTrapIndex >= 0) {
  if (!customHints[finalTrapIndex]) {
    customHints[finalTrapIndex] = { letters: [], custom: "", showLength: true };
  }
  customHints[finalTrapIndex].showLength = true;
}

    store.put({
      id: 'userData',
      answers,
      normalizedAnswers,
      spaceIndexes: spaceIndexesList,
      seeds: finalSeeds,
      hints: customHints,
      questions,
      questionCount,
      unlockIndexes,
      finalMessage,
      trapIndex
    });

    tx.oncomplete = () => {
      db.close();

      const namedSeedFiles = namedSeeds.map(seed => ({
        name: seed.name + ".txt",
        content: seed.content
      }));

      localStorage.setItem("namedSeedFiles", JSON.stringify(namedSeedFiles));
      localStorage.removeItem("namedSeeds"); // âœ… clear temp seed list after saving

      window.location.href = "build-vault.html";
    };
  };

  req.onerror = function () {
    showMessageModal("IndexedDB Error", "Failed to store user data.");
  };
}

  function forceLowercase(input) {
    input.value = input.value.toLowerCase();
  }
  
  function handlePaste(event, index) {
    event.preventDefault();
    const pasted = (event.clipboardData || window.clipboardData).getData('text');
    const input = document.getElementById(`answer-${index}`);
    input.value += pasted.toLowerCase();
    refreshHintModal();
  }
  
  function handleSeedPaste() {
  const textarea = document.getElementById('bulk-seed');
  const seeds = textarea.value.trim().toLowerCase().split(/\s+/);
  const totalSeeds = seeds.length;

  // Save pasted full phrase to localStorage
  localStorage.setItem('bulkSeedPhrase', JSON.stringify(seeds));

  // Autofill seed inputs attached to questions
  seeds.forEach((word, index) => {
    const input = document.getElementById(`seed-${index}`);
    if (input) input.value = word;
  });

  // Display overflow seeds if present
  const questionCount = parseInt(localStorage.getItem('questionCount')) || 12;
  const overflow = seeds.slice(questionCount);
  const extraContainer = document.getElementById('extraSeedsSection');
  extraContainer.innerHTML = '';

  if (overflow.length > 0) {
    const label = document.createElement('label');
    label.style = "font-size: 18px; color: #ccc;";
    label.textContent = `Extra Seed Words (${overflow.length}):`;
    extraContainer.appendChild(label);

    overflow.forEach((word) => {
      const input = document.createElement('input');
      input.type = 'text';
      input.value = word;
      input.readOnly = true;
      input.style = `
        width: 100%; margin-top: 6px; padding: 10px;
        border-radius: 6px; background-color: #333; color: #eee;
        font-size: 16px; border: none;
      `;
      extraContainer.appendChild(input);
    });
  }
}

// Returns the currently selected Red Herring index, or -1 if none selected
function getSelectedTrapIndex() {
  let idx = -1;
  document.querySelectorAll('.trap-checkbox').forEach(cb => {
    if (cb.checked) idx = parseInt(cb.dataset.index);
  });
  return idx;
}

// Ensure Red Herring's showLength flag is forced ON in memory
function enforceRedHerringShowLength() {
  const trapIndex = getSelectedTrapIndex();
  if (trapIndex >= 0) {
    if (!customHints[trapIndex]) {
      customHints[trapIndex] = { letters: [], custom: "", showLength: true };
    } else {
      customHints[trapIndex].showLength = true;
    }
  }
}

  function openHintModal(index) {
  activeHintIndex = index;
  document.getElementById('hintModal').style.display = 'flex';

  const trapIndex = getSelectedTrapIndex();
  const showLengthEl = document.getElementById('showLength');
  const saved = customHints[index];

  // Default from saved or TRUE
  showLengthEl.checked = (saved && typeof saved.showLength === 'boolean')
    ? saved.showLength
    : true;

  // If this question is the Red Herring, force ON + disable
  if (index === trapIndex) {
    showLengthEl.checked = true;
    showLengthEl.disabled = true;
  } else {
    showLengthEl.disabled = false;
  }

  // Pre-size number of letters dropdown
  const numLettersEl = document.getElementById('numLetters');
  if (saved?.letters?.length >= 0) {
    numLettersEl.value = String(saved.letters.length || 0);
  }

  buildLetterSelectors();

  // Disable/enable letter hint controls based on showLength
  toggleLetterHintAvailability(showLengthEl.checked);

  // Ensure it updates live when checkbox toggles
  showLengthEl.addEventListener("change", () => {
    toggleLetterHintAvailability(showLengthEl.checked);
  });
}

  function toggleLetterHintAvailability(enabled) {
  const numLettersEl = document.getElementById('numLetters');
  const container = document.getElementById('letterSelectors');
  const saveBtn = document.getElementById('hintSaveBtn');

  if (!enabled) {
    if (numLettersEl) numLettersEl.disabled = true;
    if (container) container.querySelectorAll('select').forEach(sel => sel.disabled = true);
    if (saveBtn) saveBtn.disabled = true;  // block saving letter hints
  } else {
    if (numLettersEl) numLettersEl.disabled = false;
    if (container) container.querySelectorAll('select').forEach(sel => sel.disabled = false);
    if (saveBtn) saveBtn.disabled = false;
  }
}

  function closeHintModal() {
  activeHintIndex = null;
  document.getElementById('hintModal').style.display = 'none';
  document.getElementById('letterSelectors').innerHTML = '';
  document.getElementById('customHintText').value = '';
  const numSel = document.getElementById('numLetters');
  if (numSel) numSel.value = '0';
  const sl = document.getElementById('showLength');
  if (sl) sl.checked = true;
}

  function buildLetterSelectors() {
  if (activeHintIndex === null) return;

  const container = document.getElementById('letterSelectors');
  container.innerHTML = '';

  const answerInput = document.getElementById(`answer-${activeHintIndex}`);
  const rawAnswer = answerInput ? answerInput.value.trim() : '';
  const cleanedAnswer = rawAnswer.replace(/\s+/g, '');

  const maxHints = Math.floor(cleanedAnswer.length * 0.5);
  const select = document.getElementById('numLetters');

  // Dynamically repopulate the dropdown if needed
  if (select.options.length !== maxHints + 1) {
    select.innerHTML = '';
    for (let i = 0; i <= maxHints; i++) {
      const option = document.createElement('option');
      option.value = i;
      option.textContent = i === 0
        ? "0 letters (only answer length)"
        : `${i} letter${i > 1 ? 's' : ''}`;
      select.appendChild(option);
    }
  }

  // Read selected number of letters
  let num = parseInt(select.value);
  if (num > maxHints) {
    num = maxHints;
    select.value = maxHints;
    showMessageModal('Warning', `You cannot reveal more than 50% of your answer's letters (Max ${maxHints}).`);
  }

  // Build selectors
  for (let i = 0; i < num; i++) {
    const letterSelect = document.createElement('select');
    letterSelect.id = `letter-select-${i}`;
    for (let j = 0; j < cleanedAnswer.length; j++) {
      const option = document.createElement('option');
      option.value = j + 1;
      option.textContent = `${cleanedAnswer[j]} (${j + 1})`;
      letterSelect.appendChild(option);
    }
    container.appendChild(letterSelect);
  }
}

  function saveCustomHint() {
  if (activeHintIndex === null) return;

  const trapIndex = getSelectedTrapIndex();
  const requestedShowLength = document.getElementById('showLength').checked;
  const effectiveShowLength = (activeHintIndex === trapIndex) ? true : requestedShowLength;

  // If showLength is off â†’ block letter hints, only save custom text
  if (!effectiveShowLength) {
    customHints[activeHintIndex] = {
      letters: [],
      custom: document.getElementById('customHintText').value.trim(),
      showLength: false
    };
    updateEntropy(activeHintIndex);
    closeHintModal();
    return;
  }

  // Otherwise allow letter hints
  const num = parseInt(document.getElementById('numLetters').value);
  const indexes = [];
  const seen = new Set();
  let duplicateFound = false;

  for (let i = 0; i < num; i++) {
    const el = document.getElementById(`letter-select-${i}`);
    if (!el) continue;
    const value = parseInt(el.value);
    if (seen.has(value)) {
      duplicateFound = true;
      break;
    }
    seen.add(value);
    indexes.push(value);
  }

  if (duplicateFound) {
    showMessageModal('Duplicate Letter Chosen', 'Please choose different letters for your hints.');
    return;
  }

  customHints[activeHintIndex] = {
    letters: indexes.sort((a, b) => a - b),
    custom: document.getElementById('customHintText').value.trim(),
    showLength: effectiveShowLength
  };

  updateEntropy(activeHintIndex);
  closeHintModal();
}

  function refreshHintModal() {
    if (document.getElementById('hintModal').style.display === 'flex') {
      buildLetterSelectors();
    }
  }
  
  function showMessageModal(title, message, autoCloseMs) {
    const modal = document.getElementById('messageModal');
    modal.classList.remove('fade-out');
    document.getElementById('messageModalTitle').innerText = title;
    document.getElementById('messageModalText').innerText = message;
    modal.style.display = 'flex';
    if (autoCloseMs) {
      setTimeout(() => {
        modal.classList.add('fade-out');
        setTimeout(closeMessageModal, 500);
      }, autoCloseMs);
    }
  }
  
  function closeMessageModal() {
    const modal = document.getElementById('messageModal');
    modal.style.display = 'none';
    modal.classList.remove('fade-out');
  }
  
  function securelyClearSensitiveData() {
  localStorage.removeItem('userAnswers');
  localStorage.removeItem('userSeeds');
  localStorage.removeItem('userHints');
  localStorage.removeItem('finalMessage');
  localStorage.removeItem('namedSeeds'); // âœ… optional extra safety
}

  window.onload = () => {
  // Render the questions UI
  loadQuestions();

  // Start the 30â€‘minute security timer + initial countdown text
  startSecurityTimer();
  updateCountdownDisplay();

  // Attach Red Herring handlers (safe to call even though loadQuestions wires them)
  attachTrapCheckboxHandlers();

  // Refresh uploads list (the DOMContentLoaded listener for uploads is fine to keep)
  displayUploadedFiles();

  // Compute overall strength once the perâ€‘question entropy rows exist
  calculateTotalEntropy();

  // (Optional) re-render saved named seeds list
  renderNamedSeeds();
};
</script>

<script>
const canvas = document.getElementById("matrixCanvas");
const ctx = canvas.getContext("2d");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890@$%&'.split('');
const fontSize = 14;
const columns = Math.floor(canvas.width / fontSize);
const drops = Array(columns).fill(0);

function drawMatrix() {
  ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#00ff99';
  ctx.font = `${fontSize}px monospace`;

  for (let i = 0; i < drops.length; i++) {
    const text = letters[Math.floor(Math.random() * letters.length)];
    ctx.fillText(text, i * fontSize, drops[i] * fontSize);
    drops[i]++;
    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
      drops[i] = 0;
    }
  }
}

setInterval(drawMatrix, 66);

window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
});
</script>


<script>
let namedSeeds = JSON.parse(localStorage.getItem("namedSeeds") || "[]");

function saveNamedSeed() {
  const nameInput = document.getElementById('newSeedName');
  const contentInput = document.getElementById('newSeedContent');
  const name = nameInput.value.trim();
  const content = contentInput.value.trim();

  if (!name || !content) {
    showMessageModal("Missing Info", "You must provide both a name and a seed phrase.");
    return;
  }

  const safeName = name.toLowerCase().replace(/[^a-z0-9]/gi, "_");

  namedSeeds.push({ name: safeName, content });
  localStorage.setItem("namedSeeds", JSON.stringify(namedSeeds));
  
  nameInput.value = "";
  contentInput.value = "";
  renderNamedSeeds();
}

function renderNamedSeeds() {
  const container = document.getElementById('namedSeedsList');
  container.innerHTML = "";

  namedSeeds.forEach((entry, index) => {
    const div = document.createElement("div");
    div.style.marginBottom = "10px";
    div.style.padding = "10px";
    div.style.background = "#111";
    div.style.border = "1px solid #0f0";
    div.style.borderRadius = "6px";
    div.innerHTML = `
      <strong>${entry.name}.txt</strong><br>
      <code>${entry.content.replace(/\s+/g, " ")}</code><br>
      <button style="margin-top:6px;" class="button" onclick="deleteNamedSeed(${index})">Remove</button>
    `;
    container.appendChild(div);
  });
}

function deleteNamedSeed(index) {
  namedSeeds.splice(index, 1);
  localStorage.setItem("namedSeeds", JSON.stringify(namedSeeds));
  renderNamedSeeds();
}

window.addEventListener("DOMContentLoaded", renderNamedSeeds);

async function nukeEverything() {
  try {
    localStorage.clear();
    sessionStorage.clear();
    if (indexedDB.databases) {
      const dbs = await indexedDB.databases();
      for (const db of dbs) {
        indexedDB.deleteDatabase(db.name);
      }
    } else {
      indexedDB.deleteDatabase("memoroVaultVaultStorage");
      indexedDB.deleteDatabase("memoroVaultDB");
    }
    console.log("Memoro Vault: Local memory wiped.");
  } catch (err) {
    console.warn("Memoro Vault wipe failed:", err);
  }
}

function updateEntropy(index) {
  const input = document.getElementById(`answer-${index}`);
  const entropyDisplay = document.getElementById(`entropy-${index}`);
  if (!input || !entropyDisplay || typeof zxcvbn !== 'function') {
    console.warn('Entropy calc skipped â€” missing input or zxcvbn not loaded');
    return;
  }

  const answer = input.value.trim().toLowerCase();
  const hintObj = customHints[index] || { letters: [], showLength: true };

  // Base entropy from zxcvbn (or 1 bit for yes/no/true/false)
  const binaryAnswers = ['t', 'f', 'y', 'n', 'true', 'false', 'yes', 'no'];
  let baseEntropy;
  if (binaryAnswers.includes(answer)) {
    baseEntropy = 1;
  } else {
    const result = zxcvbn(answer);
    baseEntropy = Math.log2(result.guesses || 1);
  }

  // Penalties:
  // 1) Revealed letters (each ~ log2(26) bits leaked for lowercase model)
  const lettersRevealed = Array.isArray(hintObj.letters) ? hintObj.letters.length : 0;
  const lettersPenalty = lettersRevealed * Math.log2(26);

  // 2) Revealing exact length leaks a small amount of information.
  //    We conservatively bound this at log2(min(length, 20)) to avoid overcounting.
  const showLength = (typeof hintObj.showLength === 'boolean') ? hintObj.showLength : true;
  const lengthKnown = showLength ? answer.length : 0;
  const lengthPenalty = showLength
    ? Math.log2(Math.max(1, Math.min(lengthKnown, 20)))
    : 0;

  const effectiveEntropy = Math.max(0, baseEntropy - lettersPenalty - lengthPenalty);

  let color = '#ff3333';
  if (effectiveEntropy >= 40) color = '#00ff99';
  else if (effectiveEntropy >= 20) color = '#ffff00';

  entropyDisplay.textContent = `Entropy: ${effectiveEntropy.toFixed(1)} bits`;
  entropyDisplay.style.color = color;

  calculateTotalEntropy();
}

function calculateTotalEntropy() {
  const numberOfQuestions = parseInt(localStorage.getItem('questionCount')) || 12;
  let totalBits = 0;

  // Aggregate total entropy
  for (let i = 0; i < numberOfQuestions; i++) {
    const el = document.getElementById(`entropy-${i}`);
    if (el) {
      const match = el.textContent.match(/([\d.]+) bits/);
      if (match) totalBits += parseFloat(match[1]);
    }
  }

  // Display total entropy
  document.getElementById('totalEntropyBits').textContent = totalBits.toFixed(1);

  // Set strength label and color
  const assessment = document.getElementById('entropyAssessment');
  if (totalBits < 40) {
    assessment.textContent = 'Very Weak';
    assessment.style.color = '#ff3333';
  } else if (totalBits < 80) {
    assessment.textContent = 'Weak';
    assessment.style.color = '#ff9933';
  } else if (totalBits < 120) {
    assessment.textContent = 'Moderate';
    assessment.style.color = '#ffff00';
  } else if (totalBits < 180) {
    assessment.textContent = 'Strong';
    assessment.style.color = '#66ff66';
  } else {
    assessment.textContent = 'Very Strong';
    assessment.style.color = '#00ff99';
  }

  // Calculate and display total combinations
  const combos = Math.pow(2, totalBits);
  const totalCombinationsEl = document.getElementById('totalCombinations');
  if (combos <= 1) {
    totalCombinationsEl.textContent = "0";
  } else {
    const exp = Math.floor(Math.log10(combos));
    const base = combos / Math.pow(10, exp);
    totalCombinationsEl.textContent = `${base.toFixed(2)} Ã— 10^${exp}`;
  }

  // Crack time calculation
  const guessesPerSecond = 1e12; // 1 trillion guesses/sec
  const seconds = combos / guessesPerSecond;
  const crackTimeEl = document.getElementById('estimatedCrackTime');

  let crackReadable;
  if (seconds < 1) {
    crackReadable = "Instantly crackable";
  } else if (seconds < 60) {
    crackReadable = `~${Math.ceil(seconds)} second${seconds > 1 ? 's' : ''}`;
  } else if (seconds < 3600) {
    crackReadable = `~${Math.ceil(seconds / 60)} minute${seconds >= 120 ? 's' : ''}`;
  } else if (seconds < 86400) {
    crackReadable = `~${Math.ceil(seconds / 3600)} hour${seconds >= 7200 ? 's' : ''}`;
  } else if (seconds < 31536000) {
    crackReadable = `~${Math.ceil(seconds / 86400)} day${seconds >= 172800 ? 's' : ''}`;
  } else if (seconds < 1e21) {
    const years = seconds / 31536000;
    crackReadable = `~${years.toFixed(1)} year${years > 1.1 ? 's' : ''}`;
  } else {
    crackReadable = `~${seconds.toExponential(2)} years`;
  }

  crackTimeEl.textContent = crackReadable;

  // Update tier banner
const tier = document.getElementById("crackabilityTier");
if (tier) {
  if (totalBits < 40) {
    tier.textContent = "âš ï¸ Crackable instantly â€” trivial for any attacker";
    tier.style.color = "#ff3333";
  } else if (totalBits < 80) {
    tier.textContent = "ğŸ”¶ Vulnerable to distributed attacks (â‰¤ 79 bits)";
    tier.style.color = "#ff9933";
  } else if (totalBits < 120) {
    tier.textContent = "ğŸŸ¡ Resistant to consumer + small-scale parallel attacks (â‰¥ 80 bits)";
    tier.style.color = "#ffff66";
  } else if (totalBits < 180) {
    tier.textContent = "ğŸŸ¢ Strong even against enterprise GPU clusters (â‰¥ 120 bits)";
    tier.style.color = "#66ff66";
  } else {
    tier.textContent = "ğŸŸ¢ Functionally immune to brute-force (â‰¥ 180 bits)";
    tier.style.color = "#00ff99";
  }
}
}

window.addEventListener("DOMContentLoaded", calculateTotalEntropy);

</script>

<div id="trapModal" class="modal">
  <div class="modal-content">
    <h2>What is a Red Herring?</h2>
    <p style="font-size: 15px; color: #ccc; line-height: 1.5;">
      A <strong>Red Herring</strong> is a decoy question: it appears like the others, but you answer it <strong>incorrectly on purpose</strong>. During recovery, the correct action is to leave it <strong>blank</strong>.<br><br>

      <strong>Purpose:</strong><br>
      Red Herrings add a powerful layer of protection against social engineering. An attacker has no way to know which question is fake, and any attempt to answer it results in failure.<br><br>

      <strong>How to use it:</strong><br>
      â€¢ Choose a <strong>real-looking question</strong> that only close friends or family would recognize.<br>
      â€¢ Enter a <strong>wrong answer</strong> that subtly signals itâ€™s not genuine.<br>
      â€¢ Make sure the fake answer is at least <strong>two characters longer or shorter</strong> than the real one.<br><br>

      <strong>Why length matters:</strong><br>
      During recovery, Memoro Vault displays the expected number of characters for each answer.<br>
      This lets trusted contacts recognize mismatches and know to leave the Red Herring blank.<br><br>

      <strong>Example:</strong><br>
      <em>Question:</em> â€œWhat was my childhood nickname?â€<br>
      <em>Real Answer:</em> <code>Squirt</code> (6 characters)<br>
      <em>Red Herring Answer:</em> <code>Tuf</code> (3 characters)<br>
      If someone sees the vault is expecting a 3-character answer but knows the real answer has 6 characters, they'll know to leave it blank. Vault builders can also choose to give away letter/s to help those in their inner circle recognize the Red Herring.<br><br>

      <strong>Psychological Advantage:</strong><br>
      The beauty of the Red Herring is this: even if you choose not to use one, the attacker doesnâ€™t know that.<br>
      Theyâ€™re forced to ask themselves: <em>"Do I leave one blank? If so, which one?"</em><br>
      This uncertainty makes brute-force and social guessing nearly impossible â€” whether or not a Red Herring was actually used.<br><br>

      <strong>Guidelines:</strong><br>
      â€¢ Do not use questions that can be profiled, guessed, or searched online.<br>
      â€¢ Only one Red Herring is allowed.<br>
      â€¢ Using one is optional â€” but even the possibility dramatically increases your security.
    </p>
    <div class="modal-buttons">
      <button onclick="document.getElementById('trapModal').style.display='none'">Got it</button>
    </div>
  </div>

</body>
</html>