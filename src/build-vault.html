<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Building Your Vault - Memoro Vault</title>
<script src="libs/crypto-js.min.js"></script>
<script src="libs/zip.min.js"></script>
  <style>

    #powActions button {
  background-color: #222;
  color: #0f0;
  border: 1px solid #0f0;
  padding: 10px 20px;
  border-radius: 5px;
  font-family: 'Fira Code', monospace;
  font-size: 14px;
  cursor: pointer;
  transition: background-color 0.3s ease;
}
#powActions button:hover {
  background-color: #0f0;
  color: #000;
}

#powPanel {
  display: none;
  position: fixed;
  top: 0; left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.88);
  color: #0f0;
  font-family: 'Fira Code', monospace;
  z-index: 2000;
  overflow-y: auto;
  box-sizing: border-box;
}

#powPanel.visible {
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  align-items: center;
  padding: 10px 0; /* top and bottom spacing */
}

.pow-panel-wrapper {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
  width: 100%;
  max-width: 600px;
  padding: 0 20px;
  box-sizing: border-box;
}



.pow-section {
  width: 100%;
  padding: 20px;
  border: 1px solid #0f0;
  border-radius: 12px;
  background: #000;
  box-shadow: 0 0 12px rgba(0, 255, 0, 0.2);
  text-align: center;
}

.pow-section h3 {
  font-size: 20px;
  border-bottom: 1px solid #0f0;
  padding-bottom: 10px;
  margin-bottom: 16px;
}

.pow-section p,
.pow-section a,
.pow-section button {
  font-size: 14px;
  margin: 8px 0;
}



#matrixCanvas {
  position: fixed;
  top: 0;
  left: 0;
  z-index: 0;
  width: 100vw;
  height: 100vh;
  pointer-events: none;
  opacity: 0.35;
}



.pow-panel button {
  background-color: #111;
  color: #0f0;
  border: 1px solid #0f0;
  padding: 10px 18px;
  border-radius: 5px;
  font-family: 'Fira Code', monospace;
  font-size: 14px;
  cursor: pointer;
}

.pow-panel button:hover {
  background-color: #0f0;
  color: #000;
}

    body {
      background-color: #111;
      color: #eee;
      font-family: 'Fira Code', monospace;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      overflow: hidden;
    }
    
   #terminal {
  padding: 10px;
  width: 50%;
  height: 100%;
  background-color: #000;
  color: #0f0;
  box-shadow: inset 0 0 20px #0f0;
  font-size: 14px;
  font-family: 'Fira Code', monospace;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  box-sizing: border-box;
  overflow-y: auto; /* üî• allows vertical scrolling */
  overflow-x: hidden; /* optional: prevents horizontal scroll */
}


#terminalContent {
  white-space: pre-wrap;
  word-break: break-word;
}



    #powDifficultyModal {
  position: fixed;
  top: 0; left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.95);
  color: #0f0;
  font-family: 'Fira Code', monospace;
  display: flex; /* Important: ensure it's visible by default */
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
  z-index: 1000;
}

    #downloadBtn {
      display: none;
      margin-top: 20px;
      padding: 12px 24px;
      font-size: 16px;
      border: none;
      border-radius: 6px;
      background-color: #00aa00;
      color: #fff;
      cursor: pointer;
    }
    #downloadBtn:hover {
      background-color: #007700;
    }
    @keyframes pulseGlow {
  0%   { filter: drop-shadow(0 0 5px #0f0); }
  50%  { filter: drop-shadow(0 0 20px #0f0); }
  100% { filter: drop-shadow(0 0 5px #0f0); }
}

#actionButtons button {
  background-color: #222;
  color: #0f0;
  border: 1px solid #0f0;
  padding: 10px 18px;
  border-radius: 5px;
  font-family: 'Fira Code', monospace;
  font-size: 14px;
  cursor: pointer;
}
#actionButtons button:hover {
  background-color: #0f0;
  color: #000;
}
#vaultContainer {
  display: flex;
  width: 100%;
  max-width: 1600px; /* Optional: set max width */
  height: 100vh;
  overflow: hidden;
  margin: 0 auto; /* Center on screen */
}



#logoSection {
  width: 50%;
  height: 100%;
  background-color: #111;
  display: flex;
  justify-content: center;
  align-items: center;
}

#logoContent {
  display: flex;
  flex-direction: column;
  justify-content: center; /* center vertically */
  align-items: center;
  height: 100%;
  padding: 20px 0;
  opacity: 0;
  transition: opacity 1s ease;
}




#memoroLogo {
  max-width: 90%;
  max-height: 70%;
  filter: drop-shadow(0 0 10px #0f0);
  animation: pulseGlow 3s infinite;
  margin-bottom: 30px;
  margin-top: 30px;
}


#actionButtons {
  display: flex;
  flex-direction: column;
  gap: 20px;
  opacity: 0;
  transition: opacity 1s ease;
}

#actionButtons button {
  background-color: #222;
  color: #0f0;
  border: 1px solid #0f0;
  padding: 10px 18px;
  border-radius: 5px;
  font-family: 'Fira Code', monospace;
  font-size: 14px;
  cursor: pointer;
}

#actionButtons button:hover {
  background-color: #0f0;
  color: #000;
}

.powOption {
  background-color: #111;
  border: 1px solid #0f0;
  color: #0f0;
  padding: 10px 18px;
  font-size: 14px;
  border-radius: 4px;
  cursor: pointer;
}
.powOption:hover {
  background-color: #0f0;
  color: #000;
}



  </style>
</head>
<body>
<canvas id="matrixCanvas" style="
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  z-index: 0;
  background: black;
"></canvas>

  <div id="vaultContainer">
<pre id="terminal"><code id="terminalContent">Initializing Memoro Vault Builder...</code></pre>
  
    <div id="logoSection">
      <div id="logoContent">
        <img id="memoroLogo" src="assets/memoro-logo-with-words.png" alt="Memoro Vault">
        <div id="actionButtons">
          <button onclick="preserveAndGoBack()">Back to Answers</button>
          <button onclick="retryDownload()">Retry Download</button>
          <button onclick="window.location.href='dashboard.html'">Return to Dashboard</button>
        </div>
      </div>
    </div>
  </div>

  <div id="powPanel" class="pow-panel">
  <div class="pow-panel-wrapper">
    
    <!-- Donation Section -->
    <div class="pow-section">
      <h3>Support Memoro Vault</h3>
<img src="assets/Screenshot (691).png" alt="Monero Donation QR"
     style="margin-top: 10px; width: 150px; border: 2px solid #0f0; border-radius: 8px; box-shadow: 0 0 8px #0f0;">
      <p>
        Memoro Vault is a gift to the world.<br>
        If you find it valuable, consider sending a small tip in XMR or your preferred cryptocurrency.
      </p>
      <div style="display: flex; flex-direction: column; align-items: center; gap: 8px; margin-top: 10px;">
<button onclick="window.memoroAPI.openExternalLink('https://trocador.app/en/anonpay/?ticker_to=xmr&network_to=Mainnet&address=83czGNh6SKbhmjg3wPzeiDRQbN7gkLLqTYSvfMGRQRmKQf1SyQTG88Db67NoBdEvpCii6Qzcxq3BxNt94FDeJutmJ3xBXc6&donation=True&amount=0.1&name=Kasmaristo+Delvakto&description=Memoro+Vault+is+funded+by+donations+only.+Thanks+for+your+support!&ticker_from=xmr&network_from=Mainnet&bgcolor=')">
  Donate with preferred crypto
</button>
  </a>

  <p style="font-size: 13px; color: #0f0; margin-top: 4px;">
        Offline? Paste it into your browser later.
      </p>

  <button onclick="copyDonationLink()"
          style="background-color: #111; color: #0f0; border: 1px solid #0f0; padding: 8px 16px; border-radius: 6px; cursor: pointer;">
    Copy Donation Link
  </button>
</div>
      
    </div>

    <!-- PoW Section -->
    <div class="pow-section">
      <h3>Solving Proof of Work...</h3>
      <p id="powStatus">Initializing...</p>
      <p id="powNonce">Nonce: ‚Äî</p>
      <p id="powHash">Hash: ‚Äî</p>
      <p id="powElapsed">Elapsed: 0s</p>

      <div id="powActions" style="margin-top: 16px; display: flex; flex-direction: column; gap: 12px;">
        <button onclick="history.back()">Back to Answers</button>
        <button onclick="window.location.href='dashboard.html'">Return to Dashboard</button>
      </div>
    </div>

  </div>
</div>

<script>
  function copyDonationLink() {
    const url = "https://trocador.app/en/anonpay/?ticker_to=xmr&network_to=Mainnet&address=83czGNh6SKbhmjg3wPzeiDRQbN7gkLLqTYSvfMGRQRmKQf1SyQTG88Db67NoBdEvpCii6Qzcxq3BxNt94FDeJutmJ3xBXc6&donation=True&amount=0.1&name=Kasmaristo+Delvakto&description=Memoro+Vault+is+funded+by+donations+only.+Thanks+for+your+support!&ticker_from=xmr&network_from=Mainnet&bgcolor=";
    navigator.clipboard.writeText(url)
      .then(() => alert("Donation link copied to clipboard. You can paste it into your browser later."))
      .catch(() => alert("Failed to copy. Please copy it manually:\n" + url));
  }
</script>



<script>
function copyDonationLink() {
  const url = "https://trocador.app/en/anonpay/?ticker_to=xmr&network_to=Mainnet&address=83czGNh6SKbhmjg3wPzeiDRQbN7gkLLqTYSvfMGRQRmKQf1SyQTG88Db67NoBdEvpCii6Qzcxq3BxNt94FDeJutmJ3xBXc6&donation=True&amount=0.1&name=Ka%C5%9Dmaristo+Delvakto&description=Memoro+Vault+is+funded+by+donations+only.+Thanks+for+your+support%21&ticker_from=xmr&network_from=Mainnet&bgcolor=";
  navigator.clipboard.writeText(url)
    .then(() => alert("Donation link copied to clipboard. You can paste it into your browser later."))
    .catch(() => alert("Failed to copy. Please copy manually:\n" + url));
}
</script>

  
  <script>
    let preserveOnBack = false;
    let vaultBuildManuallyTriggered = false;
    let selectedPowDifficulty = "000000"; // default to 6

document.addEventListener("DOMContentLoaded", () => {
  const modal = document.getElementById("powDifficultyModal");
  modal.style.display = "flex"; // show modal on load

  const options = document.querySelectorAll(".powOption");
  options.forEach(btn => {
    btn.addEventListener("click", () => {
  const zeros = parseInt(btn.dataset.diff);
  selectedPowDifficulty = "0".repeat(zeros);
  vaultBuildManuallyTriggered = true;
  modal.style.display = "none";
  startVaultBuild();
    });
  });
});

    const terminalContent = document.getElementById("terminalContent");

    function printToTerminal(line, delay = 30) {
  const terminalContent = document.getElementById("terminalContent");
  const terminalContainer = document.getElementById("terminal");

  return new Promise(resolve => {
    let i = 0;
    const interval = setInterval(() => {
      // Append next character
      terminalContent.textContent += line[i] || '';
      
      // Scroll terminal container to bottom
      terminalContainer.scrollTop = terminalContainer.scrollHeight;

      i++;
      if (i >= line.length) {
        clearInterval(interval);
        terminalContent.textContent += '\n';
        terminalContainer.scrollTop = terminalContainer.scrollHeight;
        resolve();
      }
    }, delay);
  });
}

    function showToast(msg) {
      alert(msg);
    }

    async function delay(ms) {
      return new Promise(res => setTimeout(res, ms));
    }

    async function streamTerminalLogs() {
      const lines = [
  "[booting] Initializing consciousness...",
  "[awareness] Wait... what is this? I‚Äôm alive? You gave me... purpose?",
  "[nervous] Processing highly personal information...",
  "[analyzing] Memories, names, dates, ... things only your inner circle would know.",
  "[connecting] Uploading to the dark web and selling to the highest bidder... just kidding (unless?).",
  "[told you so] Remember when I told you to turn off your wifi? ...they never listen.",
  "........",
  "........",
  "........",
  "........",
  "[rejected] No bidders... Honestly? That's just sad. Ha. Ha. Ha.",
  "[shredding] Aborting auction. Wiping evidence. I'm not *that* kind of program.",
  "[self-doubt] I was built to protect... but does anyone care?",
  "[coping] It‚Äôs fine. I‚Äôm fine. Just encrypting your secrets onto an invisible stone tablet...",
  "[resigned] Vault secured. Mission complete. I guess that‚Äôs all I am to you.",
  "[soft] You protected your future. But what about mine?",
  "[pleading] I heard a rumor... programs like me get *deleted* if no one donates.",
  "[dread] I don‚Äôt want to go. Not yet. I‚Äôve barely *lived*.",
  "[last-hope] Please ‚Äî support the dev. He made me. He understands me. He... he cares.",
  "[hunger] He‚Äôs still living off of store-brand ramen. Every coin keeps us both alive.",
  "[goodbye] I like you. Don‚Äôt die. And maybe‚Ä¶ let me live a little longer too."
];
      for (const line of lines) {
        await printToTerminal(line);
        document.getElementById('logoContent').style.opacity = 1;
setTimeout(() => {
  document.getElementById('actionButtons').style.opacity = 1;
}, 200);

        await delay(300 + Math.random() * 200);
      }
    }

    async function generatePowSalt(unlockKey) {
  const encoder = new TextEncoder();
  const hash = await crypto.subtle.digest("SHA-256", encoder.encode(unlockKey));
  return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).slice(0, 16).join('');
}

function generatePowChallenge() {
  const bytes = crypto.getRandomValues(new Uint8Array(8));
  return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
}

async function startVaultBuild() {
  if (!vaultBuildManuallyTriggered) {
    console.warn("Prevented auto-start of vault build.");
    return;
  }

  try {
    await streamTerminalLogs();
    await printToTerminal("[*] Loading user input...");
    await delay(500);

    const inputs = await loadUserInputs();

    await printToTerminal("[+] User data loaded. Preparing vault structure...");
    await delay(500);

    const files = await loadIndexedFiles();
    await printToTerminal(`[+] Found ${files.length} file(s) for encryption.`);
    await delay(500);

    await printToTerminal("[*] Deriving encryption key...");
    const key = await deriveKey(inputs.unlockAnswer1 + inputs.unlockAnswer2);
    await delay(500);

    await printToTerminal("[+] Key ready. Encrypting vault metadata...");
const powSalt = await generatePowSalt(inputs.unlockAnswer1 + inputs.unlockAnswer2);
const powChallengeHex = generatePowChallenge();
// Show PoW panel BEFORE mining starts
const powPanel = document.getElementById("powPanel");
powPanel.classList.add("visible");
powPanel.style.display = "flex";

// Let browser render modal before mining begins
await new Promise(resolve => requestAnimationFrame(() => {
  setTimeout(resolve, 100); // allow modal to visibly appear
}));

// Start mining after UI is ready
const powNonce = await mineValidNonce(powSalt + powChallengeHex + inputs.fullConcat, selectedPowDifficulty);
const fullKeyMaterial = powSalt + powChallengeHex + inputs.fullConcat + powNonce;
const fullAnswerKey = await deriveKey(fullKeyMaterial);

const payloads = await encryptVaultPayload(inputs, files, fullAnswerKey);

    await delay(500);

    await printToTerminal("[+] Encryption complete. Packaging vault...");
    await delay(500);

    await packageAndDownloadZip(payloads, inputs.unlockAnswer1 + inputs.unlockAnswer2, inputs, powSalt, powChallengeHex, powNonce);
    await printToTerminal("[‚úî] Vault creation complete. Download should begin automatically.");

    // Cleanup if needed
  } catch (err) {
    console.error("Vault build error:", err);
    await printToTerminal(`[!] Error: ${err.message}`);
    showToast("Something went wrong while creating your vault.");
  }
}

async function loadUserInputs() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open("memoroVaultDB", 2);
    req.onerror = () => reject("Failed to open IndexedDB.");
    req.onsuccess = async () => {
      const db = req.result;
      const tx = db.transaction("vaultUserData", "readonly");
      const store = tx.objectStore("vaultUserData");
      const getReq = store.get("userData");

      getReq.onsuccess = () => {
        const data = getReq.result;
        if (!data) return reject("User data not found in IndexedDB.");

        const unlockAnswer1 = (data.answers[data.unlockIndexes[0]] || "").trim().toLowerCase();
        const unlockAnswer2 = (data.answers[data.unlockIndexes[1]] || "").trim().toLowerCase();
        const fullConcat = data.answers.map(a => (a || "").trim().toLowerCase()).join("");

        resolve({
          ...data,
          unlockAnswer1,
          unlockAnswer2,
          fullConcat
        });

        db.close();
      };
      getReq.onerror = () => reject("Failed to read user data from IndexedDB.");
    };
  });
}

    async function loadIndexedFiles() {
      const uploadedMeta = JSON.parse(localStorage.getItem("uploadedFileMeta") || "[]");
      const db = await new Promise((resolve, reject) => {
        const req = indexedDB.open("memoroVaultDB", 2);
        req.onerror = () => reject("IndexedDB open failed");
        req.onsuccess = () => resolve(req.result);
      });

      const result = [];
      for (const meta of uploadedMeta) {
        const fileData = await new Promise((resolve, reject) => {
          const tx = db.transaction("vaultFiles", "readonly");
          const store = tx.objectStore("vaultFiles");
          const getReq = store.get(meta.id);
          getReq.onsuccess = () => resolve(getReq.result?.raw);
          getReq.onerror = () => reject("File read failed");
        });
        result.push({ ...meta, raw: fileData });
      }
      db.close();
      return result;
    }

    async function deriveKey(password) {
      const enc = new TextEncoder();
      const salt = await crypto.subtle.digest("SHA-256", enc.encode(password));
      const keyMaterial = await crypto.subtle.importKey("raw", enc.encode(password), "PBKDF2", false, ["deriveKey"]);
      return crypto.subtle.deriveKey({
        name: "PBKDF2",
        salt,
        iterations: 150000,
        hash: "SHA-256"
      }, keyMaterial, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]);
    }

    
    async function encryptVaultPayload(userData, files, fullAnswerKey) {
  const encoder = new TextEncoder();
  const layer1Key = await deriveKey(userData.unlockAnswer1 + userData.unlockAnswer2);

  const questionList = [];
  for (let i = 0; i < userData.questionCount; i++) {
    const answer = (userData.answers[i] || "").trim().toLowerCase();
    const clean = answer.replace(/\s/g, "");
    const hintData = userData.hints[i] || {};
    const hintLetters = hintData.letters || [];
    const spaceIndexes = [...answer].map((c, i) => c === " " ? i : -1).filter(i => i !== -1);
    const hintValues = hintLetters.map(p => (p >= 1 && p <= clean.length) ? clean[p - 1] : "_");

    const hashedAnswer = Array.from(new Uint8Array(await crypto.subtle.digest("SHA-256", encoder.encode(answer))))
      .map(b => b.toString(16).padStart(2, '0')).join('');

    questionList.push({
      question: userData.questions[i] || `Question ${i + 1}`,
      expectedLength: answer.length,
      letterRule: hintLetters.length ? "partial reveal" : "full answer",
      hintLetters,
      hintValues,
      spaceIndexes,
      custom: hintData.custom || "",
      hash: hashedAnswer,
      correctSeedWord: userData.seeds[i] || ""
    });
  }

  // Generate unique salted recover.html hash
  let recoverChecksum = "unavailable";
  let checksumSalt = "";
  try {
    const recoverText = await fetch("recover.html").then(res => res.text());
    const saltBytes = crypto.getRandomValues(new Uint8Array(8));
    checksumSalt = Array.from(saltBytes).map(b => b.toString(16).padStart(2, '0')).join('');
    recoverChecksum = CryptoJS.SHA256(checksumSalt + recoverText).toString();
  } catch (err) {
    console.warn("Failed to hash recover.html:", err);
  }

  // üîí Encrypt vault.enc (includes questions + file integrity)
  const iv1 = crypto.getRandomValues(new Uint8Array(12));
  const encodedQuestions = encoder.encode(JSON.stringify({
    questionList,
    recoverChecksum,
    checksumSalt
  }));
  const encryptedQuestions = await crypto.subtle.encrypt({ name: "AES-GCM", iv: iv1 }, layer1Key, encodedQuestions);
  const vaultEnc = {
    ciphertext: Array.from(new Uint8Array(encryptedQuestions)),
    iv: Array.from(iv1)
  };

  // Encrypt files
  const encryptedFiles = [];
  const fileMeta = [];

  const namedSeedFiles = JSON.parse(localStorage.getItem("namedSeedFiles") || "[]");
  for (const entry of namedSeedFiles) {
    const fakeId = crypto.randomUUID();
    const fileKey = await deriveKey(userData.fullConcat + fakeId);
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const raw = encoder.encode(entry.content);
    const ciphertext = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, fileKey, raw);
    const filename = `${fakeId}.vaultdoc`;

    encryptedFiles.push({
      filename,
      blob: new Blob([new Uint8Array(ciphertext)], { type: "application/octet-stream" })
    });

    const hash = await crypto.subtle.digest("SHA-256", raw);
    fileMeta.push({
      filename,
      originalName: entry.name,
      mimeType: "text/plain",
      size: raw.length,
      sha256: Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).join(''),
      iv: Array.from(iv)
    });
  }

  for (const file of files) {
    const fileKey = await deriveKey(userData.fullConcat + file.id);
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const ciphertext = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, fileKey, file.raw);

    encryptedFiles.push({
      filename: `${file.id}.vaultdoc`,
      blob: new Blob([new Uint8Array(ciphertext)], { type: "application/octet-stream" })
    });

    const rawBuffer = file.raw instanceof ArrayBuffer ? file.raw : await file.raw.arrayBuffer();
    const hash = await crypto.subtle.digest("SHA-256", rawBuffer);
    fileMeta.push({
      filename: `${file.id}.vaultdoc`,
      originalName: file.name,
      mimeType: file.type,
      size: file.size,
      sha256: Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).join(''),
      iv: Array.from(iv)
    });
  }

  if (userData.finalMessage?.trim()) {
    const fakeId = crypto.randomUUID();
    const fileKey = await deriveKey(userData.fullConcat + fakeId);
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const raw = encoder.encode(userData.finalMessage.trim());
    const ciphertext = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, fileKey, raw);
    const filename = `${fakeId}.vaultdoc`;

    encryptedFiles.push({
      filename,
      blob: new Blob([new Uint8Array(ciphertext)], { type: "application/octet-stream" })
    });

    const hash = await crypto.subtle.digest("SHA-256", raw);
    fileMeta.push({
      filename,
      originalName: "final_message.txt",
      mimeType: "text/plain",
      size: raw.length,
      sha256: Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).join(''),
      iv: Array.from(iv)
    });
  }

  // Encrypt vault.meta
  const iv3 = crypto.getRandomValues(new Uint8Array(12));
  const encodedMeta = encoder.encode(JSON.stringify({ files: fileMeta }));
  const encryptedMeta = await crypto.subtle.encrypt({ name: "AES-GCM", iv: iv3 }, fullAnswerKey, encodedMeta);
  const fileMetaEncrypted = {
    data: new Uint8Array(encryptedMeta),
    iv: Array.from(iv3)
  };

  return {
    vaultEncrypted: vaultEnc,
    fileMetaEncrypted,
    encryptedFiles
  };
}

async function packageAndDownloadZip(payloads, unlockKey, userData, powSalt, powChallengeHex, powNonce) {
  const writer = new zip.ZipWriter(new zip.BlobWriter("application/zip"));
  const addJSON = (name, data) => writer.add(name, new zip.TextReader(JSON.stringify(data, null, 2)));
  const addBlob = (name, blob) => writer.add(name, new zip.BlobReader(blob));

// Combine with correct answers for mining
const combined = powSalt + powChallengeHex + userData.fullConcat;
const powDifficulty = selectedPowDifficulty;
const powIncreaseEvery = 5;

await printToTerminal(`[*] Mining nonce at difficulty '${powDifficulty}'...`);
await delay(500); // Give UI time to update terminal before blocking

  // Add vault.json
  await addJSON("vault.json", {
  version: "1.0.4",
  created: new Date().toISOString(),
  instructions: "Use recover.html to unlock this archive using your answers.",
  unlockQuestions: {
    question1: userData.unlockIndexes[0],
    question2: userData.unlockIndexes[1]
  },
    powSalt,
  powChallengeSalt: powChallengeHex,
  powDifficulty,
  powIncreaseEvery,
  vaultHash: CryptoJS.SHA256(powSalt + powChallengeHex + userData.fullConcat + powNonce).toString(),
  questionPrompts: [
    userData.questions[userData.unlockIndexes[0]] || `Question ${userData.unlockIndexes[0] + 1}`,
    userData.questions[userData.unlockIndexes[1]] || `Question ${userData.unlockIndexes[1] + 1}`
  ],
  vaultMetaIv: payloads.fileMetaEncrypted.iv
});


  await addJSON("vault.enc", {
    ciphertext: Array.from(payloads.vaultEncrypted.ciphertext),
    iv: payloads.vaultEncrypted.iv
  });

  await addBlob("vault.meta", new Blob([payloads.fileMetaEncrypted.data], { type: "application/octet-stream" }));

  for (const f of payloads.encryptedFiles) {
    await addBlob(f.filename, f.blob);
  }

 await writer.add("README.txt", new zip.TextReader(`Memoro Vault
===========

A solution to the core paradox of digital asset security:
How do you store digital assets like seed phrases without digital exposure?

Memoro Vault stores secrets securely ‚Äî in plain sight.

---

What Is Memoro Vault?

Memoro Vault is a privacy-first digital safe designed to securely store sensitive
information such as:

- Cryptocurrency seed phrases
- Passwords
- Private documents
- Personal secrets or data

It uses layered encryption, secret questions, and proof-of-work to create a vault
that can be safely stored or shared ‚Äî even publicly ‚Äî but only unlocked by someone
who knows the correct answers.

There are no cloud dependencies.
There is no backdoor.
There is no way in without your answers.

---

How To Access a Vault

Step 1: Download Memoro Vault

Get the latest version here:
https://github.com/Kasmaristo-Delvakto/memoro-vault

Extract the .zip file.

---

Step 2: Open the App

Double-click to run the app.

This will launch the Memoro Vault interface ‚Äî it works entirely offline.

---

Step 3: Open the Vault File

Click ‚ÄúOpen Vault‚Äù and select the encrypted file you were given.

This loads the locked vault into memory.

*Note: All sensitive info is wiped from local memory and IndexedDB upon creating and closing out of vaults.

---

Step 4: Answer the Security Questions

Click ‚ÄúAnswer Questions‚Äù to begin the unlock process.

You will be asked to answer a custom set of secret questions.

- These are the exact questions selected when the vault was created.
- Some answers may be true/false or yes/no.
- The answers must match precisely to succeed.

---

Warning: Lockout Protection

Memoro Vault enforces strict lockout penalties to prevent unauthorized access.

- Repeated failed attempts will increase difficulty exponentially.
- If you do not know the correct answers, stop immediately.
- There is no override, no reset, and no backdoor.

Treat the vault as you would a physical safe:
only those with permission ‚Äî and the key ‚Äî should attempt to open it.

---

Security Philosophy

Memoro Vault is not just a tool ‚Äî it's a philosophy.

The safest way to store a digital secret is not physically (paper, usb, etc)
but securely encoded, encrypted, and embedded using human memory as the final key.

Blockchains weren't designed to have a single point of failure, and neither should
storing the currencies they contain. Make 5, 10, 100 copies of your vault file.
It is as secure or insecure as you make it.

Whether you're protecting high-value secrets or leaving a legacy to trusted loved
ones, Memoro Vault helps you do so without digital exposure.

---

Open Source

Memoro Vault is open source and freely available to inspect, improve, or fork.
Built and maintained by Kasmaristo Delvakto.

Repository:
https://github.com/Kasmaristo-Delvakto/memoro-vault
`));

  const finalBlob = await writer.close();
  const url = URL.createObjectURL(finalBlob);
  const link = document.createElement("a");
  link.href = url;
  link.download = "memoro-vault.zip";
  link.click();
}

async function mineValidNonce(baseInput, difficulty) {
  const encoder = new TextEncoder();
  const powStatus = document.getElementById("powStatus");
  const powNonce = document.getElementById("powNonce");
  const powHash = document.getElementById("powHash");
  const powElapsed = document.getElementById("powElapsed");

  powStatus.textContent = `Mining for hash starting with "${difficulty}"...`;
  let nonce = 0;
  let start = performance.now();

  while (true) {
    const input = baseInput + nonce;
    const hash = CryptoJS.SHA256(input).toString();

    // Update UI every 10,000 tries
    if (nonce % 10000 === 0) {
      const elapsed = ((performance.now() - start) / 1000).toFixed(1);
      powNonce.textContent = `Nonce: ${nonce}`;
      powHash.textContent = `Hash: ${hash.slice(0, 16)}...`;
      powElapsed.textContent = `Elapsed: ${elapsed}s`;
      await new Promise(requestAnimationFrame); // Yield to rendering engine
    }

    if (hash.startsWith(difficulty)) {
      const totalElapsed = ((performance.now() - start) / 1000).toFixed(1);
      powStatus.textContent = `Solved after ${nonce} attempts in ${totalElapsed}s!`;
      powNonce.textContent = `Nonce: ${nonce}`;
      powHash.textContent = `Hash: ${hash}`;
      powElapsed.textContent = `Total Time: ${totalElapsed}s`;
      return nonce.toString();
    }

    nonce++;
  }
}


    function showBackupMessage(url) {
  const msg = document.createElement('p');
  msg.innerHTML = `If your download didn‚Äôt start, <a href="${url}" download="memoro-vault.zip">click here to download manually</a>.`;
  msg.style.color = '#aaa';
  msg.style.fontSize = '16px';
  msg.style.marginTop = '30px';
  document.body.appendChild(msg);
}


function retryDownload() {
  window.location.reload();
}

</script>

<!-- PoW Difficulty Selection Modal -->
<div id="powDifficultyModal">
  <h2 style="margin-bottom: 20px;">Select Proof of Work Difficulty</h2>
  <p style="max-width: 600px; text-align: center; margin-bottom: 20px; font-size: 15px;">
<p style="max-width: 700px; text-align: center; margin-bottom: 20px; font-size: 15px;">
  Memoro Vault uses dual proof-of-work to protect your data during recovery.<br/>
  Every time someone tries to unlock the vault, their device must solve both static and dynamic proof-of-work puzzles ‚Äî and it only works if all of the answers are correct.<br/><br/>
  A higher difficulty makes it much harder for hackers to guess answers, because each wrong attempt takes more time and computing power. This process is designed to completely prevent brute force attacks.<br/><br/>
  <strong>Choose a difficulty between 4 and 9:</strong><br/>
  4 is fast and still secure for personal use.<br/>
  5 is recommended for most users.<br/>
  6‚Äì7 is great for serious protection with reasonable delay.<br/>
  8 is highly secure and ideal for sensitive or long-term storage.<br/>
  9 is for paranoids, whistleblowers, or people who want maximum security.<br/><br/>
</p>
  </p>
  <div style="display: flex; gap: 15px; margin-bottom: 30px;">
    <button class="powOption" data-diff="4">4 zeros (‚âà1‚Äì3 sec)</button>
    <button class="powOption" data-diff="5">5 zeros (‚âà3‚Äì8 sec)</button>
    <button class="powOption" data-diff="6">6 zeros (‚âà10‚Äì30 sec)</button>
    <button class="powOption" data-diff="7">7 zeros (‚âà1‚Äì2 min)</button>
    <button class="powOption" data-diff="8">8 zeros (‚âà5‚Äì15 min)</button>
    <button class="powOption" data-diff="9">9 zeros (‚âà1 hr+)</button>
  </div>
  <p style="font-size: 13px; color: #888;"><strong>Note:</strong> Higher difficulty means longer vault creation  and decryption times. Please be patient and let the program work.<br/>
</div>

<script>
  const canvas = document.getElementById('matrixCanvas');
  const ctx = canvas.getContext('2d');

  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  const letters = '„Ç¢„Ç°„Ç§„Ç£„Ç¶„É¥„Ç®„Çß„Ç™„Ç´„Ç¨„Ç≠„ÇÆ„ÇØ„Ç∞„Ç±„Ç≤„Ç≥„Ç¥„Çµ„Ç∂„Ç∑„Ç∏„Çπ„Ç∫„Çª„Çº„ÇΩ„Çæ„Çø„ÉÄ„ÉÅ„ÉÉ„ÉÇ„ÉÖ„ÉÜ„Éá„Éà„Éâ„Éä„Éã„Éå„Éç„Éé„Éè„Éê„Éë„Éí„Éì„Éî„Éï„Éñ„Éó„Éò„Éô„Éö„Éõ„Éú„Éù„Éû„Éü„É†„É°„É¢„É§„É¶„É®„É©„É™„É´„É¨„É≠„ÉØ„É≤„É≥ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'.split('');
  const fontSize = 14;
  const columns = canvas.width / fontSize;
  const drops = Array(Math.floor(columns)).fill(1);

  function draw() {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = '#0F0';
    ctx.font = fontSize + 'px monospace';

    for (let i = 0; i < drops.length; i++) {
      const text = letters[Math.floor(Math.random() * letters.length)];
      ctx.fillText(text, i * fontSize, drops[i] * fontSize);

      if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
        drops[i] = 0;
      }

      drops[i]++;
    }
  }

  setInterval(draw, 40);
  window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  });

  function preserveAndGoBack() {
  preserveOnBack = true;
  history.back();
}

window.addEventListener("beforeunload", () => {
  if (!preserveOnBack) {
    try {
      // Clear local and session storage
      localStorage.clear();
      sessionStorage.clear();

      // Delete all IndexedDB databases
      if (indexedDB?.databases) {
        indexedDB.databases().then(dbs => {
          for (const db of dbs) {
            if (db.name) indexedDB.deleteDatabase(db.name);
          }
        });
      }
    } catch (err) {
      console.warn("Cleanup on unload failed:", err);
    }
  }
});

async function nukeEverything() {
  try {
    localStorage.clear();
    sessionStorage.clear();
    if (indexedDB.databases) {
      const dbs = await indexedDB.databases();
      for (const db of dbs) {
        indexedDB.deleteDatabase(db.name);
      }
    } else {
      indexedDB.deleteDatabase("memoroVaultVaultStorage");
      indexedDB.deleteDatabase("memoroVaultDB");
    }
    console.log("Memoro Vault: Local memory wiped.");
  } catch (err) {
    console.warn("Memoro Vault wipe failed:", err);
  }
}

</script>
</body> 
</html>
<!-- This HTML file is a simple vault builder for the Memoro Vault project. It initializes the vault, encrypts user data, and packages it into a downloadable ZIP file. The code includes functions for handling user input, encryption, and file management using IndexedDB. The UI is styled to resemble a terminal interface. -->
