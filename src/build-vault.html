<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Building Your Vault - Memoro Vault</title>
  <script src="libs/zip.min.js"></script>
  <script src="libs/argon2-browser.min.js"></script> <!-- Argon2 lib -->
  <script src="libs/secrets.min.js"></script>
  <script src="libs/jspdf.umd.min.js"></script>
  <script src="libs/qrcode.min.js"></script>
  <script type="module">
import init, { sha256_hash, derive_key, aes_gcm_encrypt, aes_gcm_decrypt } from './wasm/memoro_crypto.js';
window.initCryptoWasm = async () => {
  await init();
  window.sha256Hash = sha256_hash;
  window.deriveKeyRust = derive_key;
  window.aesEncryptRust = aes_gcm_encrypt;
  window.aesDecryptRust = aes_gcm_decrypt;
};
window.initCryptoWasm();
  </script>

  <style>

    #powActions button {
  background-color: #222;
  color: #0f0;
  border: 1px solid #0f0;
  padding: 10px 20px;
  border-radius: 5px;
  font-family: 'Fira Code', monospace;
  font-size: 14px;
  cursor: pointer;
  transition: background-color 0.3s ease;
}
#powActions button:hover {
  background-color: #0f0;
  color: #000;
}

.pow-panel-wrapper {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
  width: 100%;
  max-width: 600px;
  padding: 0 20px;
  box-sizing: border-box;
}



.pow-section {
  width: 100%;
  padding: 20px;
  border: 1px solid #0f0;
  border-radius: 12px;
  background: #000;
  box-shadow: 0 0 12px rgba(0, 255, 0, 0.2);
  text-align: center;
}

.pow-section h3 {
  font-size: 20px;
  border-bottom: 1px solid #0f0;
  padding-bottom: 10px;
  margin-bottom: 16px;
}

.pow-section p,
.pow-section a,
.pow-section button {
  font-size: 14px;
  margin: 8px 0;
}



#matrixCanvas {
  position: fixed;
  top: 0;
  left: 0;
  z-index: 0;
  width: 100vw;
  height: 100vh;
  pointer-events: none;
  opacity: 0.15;
}



.pow-panel button {
  background-color: #111;
  color: #0f0;
  border: 1px solid #0f0;
  padding: 10px 18px;
  border-radius: 5px;
  font-family: 'Fira Code', monospace;
  font-size: 14px;
  cursor: pointer;
}

.pow-panel button:hover {
  background-color: #0f0;
  color: #000;
}

body {
  background-color: #111;
  color: #eee;
  font-family: 'Fira Code', monospace;
  margin: 0;
  padding: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  min-height: 100vh;
  overflow-x: hidden;
  overflow-y: auto;
}

#vaultContainer {
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  min-height: 100vh;
  width: 100%;
  max-width: 1600px;
  margin: 0 auto;
  padding: 0 16px;
  box-sizing: border-box;
  position: relative;
}

@media (max-width: 600px), (max-height: 700px) {
  #vaultContainer {
    justify-content: flex-start;
    padding-top: 20px;
  }
}

#mainContainer {
  z-index: 1;
  text-align: center;
  display: flex;
  flex-direction: column;
  align-items: center;
 justify-content: flex-start;
  width: 100%;
  max-width: 600px;
  padding: 40px 20px;
  box-sizing: border-box;
}

#logoSection {
  width: 100%;
  background-color: #111;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 30px 0;
}

#logoContent {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  padding: 20px 0;
  opacity: 0;
  transition: opacity 1s ease;
}

#powDifficultyModal {
  position: fixed;
  top: 0; left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.95);
  color: #0f0;
  font-family: 'Fira Code', monospace;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
  z-index: 1000;
}

#downloadBtn {
  display: none;
  margin-top: 20px;
  padding: 12px 24px;
  font-size: 16px;
  border: none;
  border-radius: 6px;
  background-color: #00aa00;
  color: #fff;
  cursor: pointer;
}
#downloadBtn:hover {
  background-color: #007700;
}

#actionButtons {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 16px;
  margin-top: 30px;
}

#actionButtons button {
  background-color: #222;
  color: #0f0;
  border: 1px solid #0f0;
  padding: 10px 18px;
  border-radius: 5px;
  font-size: 14px;
  font-family: 'Fira Code', monospace;
  cursor: pointer;
  min-width: 140px;
  flex: 1 1 40%;
  max-width: 240px;
}

.powOption {
  background-color: #111;
  border: 1px solid #0f0;
  color: #0f0;
  padding: 10px 18px;
  font-size: 14px;
  border-radius: 4px;
  cursor: pointer;
}
.powOption:hover {
  background-color: #0f0;
  color: #000;
}

/* === Responsive Tweaks for Mobile === */
@media (max-width: 600px), (max-height: 700px) {
  #mainContainer {
    padding: 20px 10px;
  }

  #logoContent {
    padding: 10px 0;
  }

#actionButtons button {
  background-color: #111;
  color: #0f0;
  border: 1px solid #0f0;
  padding: 10px 18px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  font-family: 'Fira Code', monospace;
  min-width: 140px;
  max-width: 240px;
  flex: 1 1 auto;
  transition: background-color 0.3s ease, color 0.3s ease;
}

#actionButtons button:hover {
  background-color: #0f0;
  color: #000;
}

}


#memoroLogo {
  width: 200px;
  max-width: 90%;
  margin-bottom: 30px;
  transition: width 0.3s ease;
}

@media (max-width: 600px), (max-height: 700px) {
  #memoroLogo {
    width: 140px;
    margin-bottom: 20px;
  }
}


#progressBarWrapper {
  width: 80%;
  max-width: 400px;
  margin: 20px auto;
}

.progress-label {
  font-size: 14px;
  margin-bottom: 8px;
  color: #0f0;
}

.progress-bar-container {
  width: 100%;
  height: 20px;
  background-color: #111;
  border: 1px solid #0f0;
  border-radius: 10px;
  overflow: hidden;
  box-shadow: 0 0 8px #0f0;
}

.progress-bar-fill {
  display: flex;
  gap: 2px;
  height: 100%;
  justify-content: space-between;
  align-items: center;
  padding: 0 2px;
}

.progress-block {
  flex: 0 0 auto;
  width: calc((100% - 38px) / 20); /* 20 blocks + 19 gaps × 2px = 38px total gap */
  height: 100%;
  background-color: #111;
  border: 1px solid #0f0;
  border-radius: 2px;
  box-sizing: border-box;
  transition: background-color 0.2s ease;
}

.progress-block.filled {
  background-color: #0f0;
}


@keyframes loading-stripes {
  0% { background-position: 0 0; }
  100% { background-position: 40px 0; }
}

#actionButtons {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 16px;
  margin-top: 30px;
  opacity: 1;
  transition: opacity 1s ease;
}

#actionButtons button {
  background-color: #111;
  color: #0f0;
  border: 1px solid #0f0;
  padding: 10px 18px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  font-family: 'Fira Code', monospace;
  min-width: 140px;
  flex: 1 1 40%;
  max-width: 240px;
}

#actionButtons button:hover {
  background-color: #0f0;
  color: #000;
}

#actionButtons button {
  background-color: #111;
  color: #0f0;
  border: 1px solid #0f0;
  padding: 10px 18px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  font-family: 'Fira Code', monospace;
  min-width: 160px;
  flex: 1 1 auto;
  max-width: 220px;
}

#actionButtons button:hover {
  background-color: #0f0;
  color: #000;
}


#actionButtons button {
  background-color: #111;
  color: #0f0;
  border: 1px solid #0f0;
  padding: 10px 18px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  font-family: 'Fira Code', monospace;
}

#actionButtons button:hover {
  background-color: #0f0;
  color: #000;
}

@media (max-width: 820px) {
  #litePickerModal > div {
    margin: 16px auto;
    max-height: calc(100vh - 32px);
  }
}

  </style>
</head>
<body>
<canvas id="matrixCanvas" style="
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  z-index: 0;
  background: black;
"></canvas>

  <div id="vaultContainer">
  <canvas id="matrixCanvas"></canvas>

<div id="mainContainer">
  <img id="memoroLogo" src="assets/memoro-logo-with-words.png" alt="Memoro Vault Logo" />

  <div id="progressBarWrapper">
    <div class="progress-label" id="progressLabel">Initializing vault builder...</div>
    <div class="progress-bar-container">
<div class="progress-bar-fill" id="progressFill">
  <!-- 20 blocks (adjustable) -->
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
</div>
    </div>
  </div>

  <div id="actionButtons">
    <button onclick="preserveAndGoBack()">Back to Answers</button>
    <button onclick="retryDownload()">Retry Download</button>
    <button onclick="window.location.href='dashboard.html'">Return to Dashboard</button>
  </div>
</div>

  <div id="powPanel" class="pow-panel">
  <div class="pow-panel-wrapper">

<!-- Final Instructions Modal -->
<div id="postBuildModal"
     style="display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.96); z-index: 5000; color: #0f0; font-family: 'Fira Code', monospace;
            padding: 40px; box-sizing: border-box; overflow-y: auto;">
  <div style="max-width: 800px; width: 100%; border: 1px solid #0f0; padding: 30px;
              background: #000; box-shadow: 0 0 20px #0f0; margin: auto;">
    <h2 style="color: #00ff99; text-shadow: 0 0 10px #0f0;">Please Read Carefully</h2>
    
    <p style="margin-top: 20px;">
      Your Memoro Vault has been successfully built and downloaded.
    </p>

    <p>
      To ensure it remains accessible for decades, it's critical to guard against <strong>bit rot</strong> — a slow form of data decay that can silently corrupt files over time.
    </p>

    <p>
      Even if someone remembers all your answers perfectly, a single missing byte can render your vault irretrievable. That's why secure, redundant storage is essential.
    </p>

    <h3 style="margin-top: 25px; color: #88ffcc;">What to Do Next</h3>
    <ol style="margin-left: 20px;">
      <li>Create a folder (e.g., <code>J's_Memoro_Vault</code>) on your computer.</li>
      <li>Place both of the following into that folder:
        <ul>
          <li>The downloaded vault ZIP file</li>
          <li>The Memoro Vault installer (e.g., <code>memoro-win.exe</code>, <code>.AppImage</code>, or <code>.dmg</code>)</li>
        </ul>
      </li>
      <li><strong>Duplicate that folder to multiple destinations:</strong>
        <ul>
          <li>1× <strong>M-DISC</strong> (for long-term archival)</li>
          <li>1× <strong>Cloud backup</strong> (e.g., Proton Drive or Google Drive)</li>
          <li>1× <strong>Offline USB/SSD</strong> (stored in a fireproof safe or Faraday bag)</li>
        </ul>
      </li>
      <li><strong>Create a paper backup (recommended):</strong>
        <ul>
          <li>Memoro Vault can generate a printable PDF of QR codes that reassemble your encrypted vault.</li>
          <li>Print these QR tiles on archival paper and store them in a secure location.</li>
          <li>This ensures recovery even if all digital copies are lost or corrupted.</li>
        </ul>
      </li>
      <li>Test access on another device while offline to verify integrity and function.</li>
      <li>Repeat this process whenever you update or rebuild your vault.</li>
    </ol>

    <h3 style="margin-top: 25px; color: #88ffcc;">Why M-DISC?</h3>
    <p>
      M-DISCs use a permanent, stone-like recording layer, unlike dye-based DVDs or flash memory. They're immune to bit rot, magnetic damage, EMPs, and most environmental degradation.
    </p>
    <p>
      With proper storage, an M-DISC can last 100–1,000 years — making it ideal for preserving something irreplaceable.
    </p>

    <h3 style="margin-top: 25px; color: #88ffcc;">Final Advice</h3>
    <ul style="margin-left: 20px;">
      <li>Do <strong>not</strong> rely on a single copy.</li>
      <li>Do <strong>not</strong> trust cloud providers to exist forever.</li>
      <li>Do <strong>not</strong> assume your future self will remember every step.</li>
    </ul>
    <p>
      Redundancy is key to ensuring your vault remains accessible for generations to come.
    </p>

    <p style="margin-top: 20px;">
      A copy of these instructions is also included inside your vault ZIP as
      <code>Vault_Builder_Instructions.txt</code>.
    </p>

    <div style="text-align: center; margin-top: 30px;">
      <button onclick="closePostBuildModal()" style="padding: 10px 20px; font-size: 14px; background: #111; border: 1px solid #0f0; color: #0f0; cursor: pointer;">Got it</button>
    </div>
  </div>
</div>


<!-- Lite Picker Modal -->
<div id="litePickerModal"
     style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.96); z-index:6000; color:#0f0; font-family:'Fira Code',monospace; overflow-y:auto; overscroll-behavior:contain; padding:16px 0;">
  <div style="max-width:600px; margin:40px auto; border:1px solid #0f0; background:#000; box-shadow:0 0 20px #0f0; max-height:calc(100vh - 80px); overflow:auto; border-radius:10px;">
    <div style="padding:18px 22px; border-bottom:1px solid #0f0; display:flex; align-items:center; gap:10px;">
      <h2 style="margin:0; color:#00ff99;">Choose what to include in your Paper Backup (≤ 150 KB)</h2>
    </div>

    <div style="display:flex; flex-wrap:wrap; gap:22px; padding:22px;">
      <!-- Left: selections -->
      <div style="flex:1 1 380px; min-width:300px;">
        <h3 style="margin:0 0 10px 0; color:#88ffcc;">Seeds & Final Message</h3>
        <div id="liteSeedsList" style="border:1px solid #0f0; padding:10px; border-radius:8px; max-height:220px; overflow:auto;"></div>

        <div style="margin-top:18px;">
          <label style="display:flex; align-items:center; gap:8px;">
            <input id="litePickFinalMsg" type="checkbox" />
            <span>Include final message (as <code>final-message.txt</code>)</span>
          </label>
        </div>

        <h3 style="margin:18px 0 10px 0; color:#88ffcc;">Uploads</h3>
        <div id="liteUploadsList" style="border:1px solid #0f0; padding:10px; border-radius:8px; max-height:280px; overflow:auto;"></div>
      </div>

      <!-- Right: summary -->
      <div style="flex:1 1 260px; min-width:240px;">
        <h3 style="margin:0 0 10px 0; color:#88ffcc;">Summary</h3>
        <div style="border:1px solid #0f0; border-radius:8px; padding:12px;">
          <div style="margin-bottom:8px;">Total selected (raw): <strong id="liteTotalBytes">0</strong> bytes</div>
          <div style="font-size:12px; color:#b8ffd9;">Limit: 153,600 bytes (≈ 150 KB). Encryption adds overhead, but this raw cap keeps QR count reasonable.</div>
          <hr style="border:none; border-top:1px solid #0f0; margin:12px 0;">
          <div id="litePickerError" style="color:#ff6; min-height:18px;"></div>
          <div style="display:flex; gap:10px; margin-top:10px;">
            <button id="litePickerConfirm" style="background:#0f0; color:#000; border:1px solid #0f0; padding:10px 14px; border-radius:6px; cursor:pointer;">Build Paper Backup</button>
            <button id="litePickerCancel" style="background:#111; border:1px solid #0f0; color:#0f0; padding:10px 14px; border-radius:6px; cursor:pointer;">Cancel</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>


</div>

<script>

// ==============================
// Paper Backup (Lite ZIP → QR PDF)
// 3-per-row, centered grid • max tile size
// Clean banner • ~300 DPI QRs • Quiet zone • EC(Q) for KEY/HEADER
// Tags: MVKEY|, MVHDR|, MVCT|
// ==============================

// --- Helpers ---
function bytesToBase64(u8) {
  let s = '';
  for (let i = 0; i < u8.length; i++) s += String.fromCharCode(u8[i]);
  return btoa(s);
}
function chunkString(str, maxLen) {
  const out = [];
  for (let i = 0; i < str.length; i += maxLen) out.push(str.slice(i, i + maxLen));
  return out;
}
async function aesGcmEncryptBytes(keyBytes, plaintextU8) {
  const key = await crypto.subtle.importKey("raw", keyBytes, "AES-GCM", false, ["encrypt"]);
  const iv  = crypto.getRandomValues(new Uint8Array(12));
  const ct  = new Uint8Array(await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, plaintextU8));
  return { iv: Array.from(iv), ct: Array.from(ct) };
}

/**
 * Render a QR payload to a canvas sized for sharp printing.
 * - targetPt: side length in PDF points (72pt = 1 inch)
 * - ecLevel: "M" (default) or "Q"
 * - Adds a 4-module quiet zone around the code
 */
async function qrcodeToCanvas(text, targetPt, ecLevel = "M") {
  const TARGET_DPI = 300;
  const desiredPx  = Math.max(256, Math.ceil(targetPt * (TARGET_DPI / 72)));

  // Case A: node-qrcode UMD
  if (window.QRCode && typeof window.QRCode.toCanvas === "function") {
    const canvas = document.createElement("canvas");
    await window.QRCode.toCanvas(canvas, text, {
      errorCorrectionLevel: ecLevel,
      margin: 4,                 // quiet-zone in modules
      width: desiredPx
    });
    return canvas;
  }

  // Case B: qrcode-generator
  if (typeof window.qrcode === "function") {
    const qr = window.qrcode(0, ecLevel);
    qr.addData(text);
    qr.make();

    const count         = qr.getModuleCount();
    const pxPerModule   = Math.max(4, Math.floor(desiredPx / count));
    const marginModules = 4;                          // quiet-zone in modules
    const marginPx      = marginModules * pxPerModule;
    const size          = count * pxPerModule + marginPx * 2;

    const canvas = document.createElement("canvas");
    canvas.width  = size;
    canvas.height = size;
    const ctx = canvas.getContext("2d");

    ctx.fillStyle = "#fff";
    ctx.fillRect(0, 0, size, size);

    ctx.fillStyle = "#000";
    for (let r = 0; r < count; r++) {
      for (let c = 0; c < count; c++) {
        if (qr.isDark(r, c)) {
          ctx.fillRect(
            marginPx + c * pxPerModule,
            marginPx + r * pxPerModule,
            pxPerModule, pxPerModule
          );
        }
      }
    }
    return canvas;
  }

  throw new Error("QR library not loaded (expected window.QRCode or window.qrcode).");
}

// --- Main: Lite ZIP → Paper PDF ---
async function buildPaperPdfFromLiteZip(liteZipBlob) {
  const liteBytes = new Uint8Array(await liteZipBlob.arrayBuffer());

  // 1) Random 32‑byte file key
  const keyBytes = crypto.getRandomValues(new Uint8Array(32));

  // 2) Encrypt Lite ZIP with that key
  const { iv, ct } = await aesGcmEncryptBytes(keyBytes, liteBytes);

  // 3) Header: version + iv + size + SHA‑256(plaintext)
  const shaHex = Array.from(new Uint8Array(await crypto.subtle.digest("SHA-256", liteBytes)))
    .map(b => b.toString(16).padStart(2,'0')).join('');
  const header = { v: "mv-lite-v1", iv, size: liteBytes.length, sha256: shaHex };
  const headerB64 = btoa(unescape(encodeURIComponent(JSON.stringify(header))));

  // 4) Recovery key (single share)
  const keyHex = Array.from(keyBytes).map(b => b.toString(16).padStart(2,"0")).join("");

  // 5) Ciphertext into QR tiles
  const CT_B64    = bytesToBase64(ct);
  const CHUNK_LEN = 600; // payload per tile (scanner-friendly)
  const ctChunks  = chunkString(CT_B64, CHUNK_LEN);
  const total     = ctChunks.length;

  const KEY_TAG    = `MVKEY|${keyHex}`;
  const HEADER_TAG = `MVHDR|${headerB64}`;
  const CT_PREFIX  = "MVCT|";

  // 6) PDF layout (letter: 612×792pt)
  const { jsPDF } = window.jspdf;
  const pdf   = new jsPDF({ unit: "pt", format: "letter" });
  const pageW = pdf.internal.pageSize.getWidth();
  const pageH = pdf.internal.pageSize.getHeight();

  const MARGIN    = 8;  // page side/top/bottom margins
  const GAP       = 8;  // gap between tiles
  const LABEL_PAD = 6;  // space above each tile for label
  const BANNER_H  = 75;  // banner block height

  function compute3ColLayout() {
    const innerW = pageW - 2 * MARGIN;
    const cols   = 3;
    const tile   = Math.floor((innerW - GAP * (cols - 1)) / cols);
    const usedW  = cols * tile + (cols - 1) * GAP;
    const startX = MARGIN + Math.floor((innerW - usedW) / 2); // center horizontally
    return { cols, tile, startX };
  }

  function drawBanner(pageNum) {
    pdf.setFont("courier", "normal");
    pdf.setFontSize(11);

    const title = "Memoro Vault - Paper Backup";
    const now   = new Date();
    const built = `Built: ${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')} ${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')} | Version: 1.0.6 | Format: mv-lite-v1 | ZIP bytes: ${liteBytes.length}`;
    const shaLine  = `SHA-256 (ZIP): ${shaHex}`;
    const pageLine = `Page ${pageNum} | Scan KEY and HEADER on page 1, then all CT tiles`;

    pdf.text(title,   MARGIN, MARGIN + 12);
    pdf.setFontSize(10);
    pdf.text(built,   MARGIN, MARGIN + 28);
    pdf.text(shaLine, MARGIN, MARGIN + 44);

    const w = pdf.getTextWidth(pageLine);
    pdf.text(pageLine, pageW - MARGIN - w, MARGIN + 12);
  }

  function drawLabel(x, y, text) {
    pdf.setFont("courier", "bold");
    pdf.setFontSize(9);
    pdf.text(text, x + 2, y - 4); // just above the tile
    pdf.setFont("courier", "normal");
  }

  async function drawTile(x, y, sizePt, payload, label, ecLevel = "M") {
    drawLabel(x, y, label);
    const canvas = await qrcodeToCanvas(payload, sizePt, ecLevel);
    pdf.addImage(canvas.toDataURL("image/png"), "PNG", x, y, sizePt, sizePt);
  }

  // 7) Page rendering (3 columns)
  let ctIdx = 0;
  let pageNum = 1;

  const grid = compute3ColLayout();
  drawBanner(pageNum);

  let x = grid.startX;
  let y = MARGIN + BANNER_H + LABEL_PAD;
  const rowH = LABEL_PAD + grid.tile;

  // First row: KEY | HEADER | CT 1 (if any)
  await drawTile(x, y, grid.tile, KEY_TAG,    "KEY",    "Q"); x += grid.tile + GAP;
  await drawTile(x, y, grid.tile, HEADER_TAG, "HEADER", "Q"); x += grid.tile + GAP;

  if (ctIdx < total) {
    const tag = `${CT_PREFIX}${ctIdx + 1}/${total}|${ctChunks[ctIdx]}`;
    await drawTile(x, y, grid.tile, tag, `CT ${ctIdx + 1}/${total}`, "M");
    ctIdx++;
  }

  // Remaining rows on page 1
  x = grid.startX; y += rowH + GAP;

  while (ctIdx < total) {
    // New page if next row won't fit
    if (y + grid.tile + MARGIN > pageH) {
      pdf.addPage(); pageNum++;
      drawBanner(pageNum);
      x = grid.startX; y = MARGIN + BANNER_H + LABEL_PAD;
    }

    // Up to 3 CT tiles per row
    for (let c = 0; c < grid.cols && ctIdx < total; c++) {
      const tag = `${CT_PREFIX}${ctIdx + 1}/${total}|${ctChunks[ctIdx]}`;
      await drawTile(x, y, grid.tile, tag, `CT ${ctIdx + 1}/${total}`, "Q");
      ctIdx++;
      x += (c < grid.cols - 1) ? (grid.tile + GAP) : 0;
    }
    x = grid.startX; y += rowH + GAP;
  }

  pdf.save("memoro-lite-QR.pdf");
}

// Expose for other scripts (prevents “not defined” if called from elsewhere)
window.buildPaperPdfFromLiteZip = buildPaperPdfFromLiteZip;
// ---------- Lite Picker helpers ----------
const LITE_CAP_BYTES = 153600; // ≈ 150 KiB cap on raw content

function fmtBytes(n) {
  if (n < 1024) return `${n} B`;
  if (n < 1024*1024) return `${(n/1024).toFixed(1)} KB`;
  return `${(n/1024/1024).toFixed(2)} MB`;
}

/**
 * Open a modal allowing the user to choose which seeds, uploads, and whether the final message
 * should be included. Enforces ≤ 150 KB total (raw).
 *
 * @param {Object} args
 * @param {{name:string,content:string}[]} args.seedFiles
 * @param {{id:string,name:string,type:string,raw:ArrayBuffer}[]} args.uploads
 * @param {number} args.finalMessageBytesLen
 * @returns {Promise<{ includeFinalMessage:boolean, seedNames:string[], uploadIds:string[] }>}
 */
function openLitePicker({ seedFiles, uploads, finalMessageBytesLen }) {
  return new Promise((resolve, reject) => {
    const modal    = document.getElementById('litePickerModal');
    const seedsEl  = document.getElementById('liteSeedsList');
    const uploadsEl= document.getElementById('liteUploadsList');
    const pickFinal= document.getElementById('litePickFinalMsg');
    const totalEl  = document.getElementById('liteTotalBytes');
    const errEl    = document.getElementById('litePickerError');
    const btnOK    = document.getElementById('litePickerConfirm');
    const btnCancel= document.getElementById('litePickerCancel');

    if (!modal) return reject(new Error('Lite picker modal missing'));

    seedsEl.innerHTML   = '';
    uploadsEl.innerHTML = '';
    errEl.textContent   = '';
    totalEl.textContent = '0';
    pickFinal.checked   = !!finalMessageBytesLen && finalMessageBytesLen > 0;

    // Seeds list
    for (const s of seedFiles) {
      const rawSize = new TextEncoder().encode(s.content || '').length;
      const id = `seed_${btoa(s.name).replace(/=+$/,'')}`;
      const row = document.createElement('label');
      row.style.cssText = 'display:flex;align-items:center;justify-content:space-between;gap:8px;padding:6px 8px;border-bottom:1px dashed rgba(0,255,153,.2)';
      row.innerHTML = `
        <span style="display:flex;align-items:center;gap:8px;">
          <input type="checkbox" id="${id}" data-name="${s.name}">
          <code>${s.name}</code>
        </span>
        <span style="color:#b8ffd9">${fmtBytes(rawSize)}</span>
      `;
      seedsEl.appendChild(row);
    }

    // Uploads list
    for (const f of uploads) {
      const rawSize = (f.raw && f.raw.byteLength) ? f.raw.byteLength : 0;
      const id = `upl_${f.id}`;
      const row = document.createElement('label');
      row.style.cssText = 'display:flex;align-items:center;justify-content:space-between;gap:8px;padding:6px 8px;border-bottom:1px dashed rgba(0,255,153,.2)';
      row.innerHTML = `
        <span style="display:flex;align-items:center;gap:8px;">
          <input type="checkbox" id="${id}" data-id="${f.id}">
          <code>${f.name}</code>
        </span>
        <span style="color:#b8ffd9">${fmtBytes(rawSize)}</span>
      `;
      uploadsEl.appendChild(row);
    }

    function calcTotalBytes() {
      let total = 0;
      // seeds
      for (const el of seedsEl.querySelectorAll('input[type="checkbox"]')) {
        if (el.checked) {
          const nm = el.getAttribute('data-name');
          const s = seedFiles.find(x => x.name === nm);
          total += new TextEncoder().encode(s?.content || '').length;
        }
      }
      // final message
      if (pickFinal.checked) total += (finalMessageBytesLen || 0);
      // uploads
      for (const el of uploadsEl.querySelectorAll('input[type="checkbox"]')) {
        if (el.checked) {
          const id = el.getAttribute('data-id');
          const u = uploads.find(x => String(x.id) === String(id));
          total += (u?.raw?.byteLength || 0);
        }
      }
      totalEl.textContent = `${total} (${fmtBytes(total)})`;
      errEl.textContent = total > LITE_CAP_BYTES ? `Too large. Reduce selection below ${fmtBytes(LITE_CAP_BYTES)}.` : '';
      return total;
    }

    seedsEl.addEventListener('change', calcTotalBytes);
    uploadsEl.addEventListener('change', calcTotalBytes);
    pickFinal.addEventListener('change', calcTotalBytes);

    btnCancel.onclick = () => { modal.style.display = 'none'; reject(new Error('User cancelled Lite picker')); };

    btnOK.onclick = () => {
      const total = calcTotalBytes();
      if (total === 0) { errEl.textContent = 'Select at least one item.'; return; }
      if (total > LITE_CAP_BYTES) { errEl.textContent = `Too large. Reduce selection below ${fmtBytes(LITE_CAP_BYTES)}.`; return; }

      const seedNames = Array.from(seedsEl.querySelectorAll('input[type="checkbox"]:checked'))
        .map(el => el.getAttribute('data-name'));
      const uploadIds = Array.from(uploadsEl.querySelectorAll('input[type="checkbox"]:checked'))
        .map(el => el.getAttribute('data-id'));

      modal.style.display = 'none';
      resolve({ includeFinalMessage: !!pickFinal.checked && !!finalMessageBytesLen, seedNames, uploadIds });
    };

    modal.style.display = 'block';
    calcTotalBytes();
  });
}

  function copyDonationLink() {
    const url = "https://trocador.app/en/anonpay/?ticker_to=xmr&network_to=Mainnet&address=83czGNh6SKbhmjg3wPzeiDRQbN7gkLLqTYSvfMGRQRmKQf1SyQTG88Db67NoBdEvpCii6Qzcxq3BxNt94FDeJutmJ3xBXc6&donation=True&amount=0.1&name=Kasmaristo+Delvakto&description=Memoro+Vault+is+funded+by+donations+only.+Thanks+for+your+support!&ticker_from=xmr&network_from=Mainnet&bgcolor=";
    navigator.clipboard.writeText(url)
      .then(() => alert("Donation link copied to clipboard. You can paste it into your browser later."))
      .catch(() => alert("Failed to copy. Please copy it manually:\n" + url));
  }
</script>
  
  <script>
    let preserveOnBack = false;
    let vaultBuildManuallyTriggered = false;

   document.addEventListener("DOMContentLoaded", async () => {
  vaultBuildManuallyTriggered = true;

  window.cryptoWasmReady = window.initCryptoWasm();
  await window.cryptoWasmReady;
  startVaultBuild();
});


    function printToTerminal(labelText, percent = null) {
  const label = document.getElementById("progressLabel");
  const fill = document.getElementById("progressFill");

  if (label) label.textContent = labelText;

  if (percent !== null && fill) {
    const blocks = fill.querySelectorAll(".progress-block");
    const total = blocks.length;
    const filledCount = Math.round((percent / 100) * total);

    blocks.forEach((block, i) => {
      block.classList.toggle("filled", i < filledCount);
    });
  }
}

    function showToast(msg) {
      alert(msg);
    }

      function generateRandomHex(length) {
      const bytes = crypto.getRandomValues(new Uint8Array(length / 2));
  return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
}

    async function delay(ms) {
      return new Promise(res => setTimeout(res, ms));
    }

    async function streamTerminalLogs() {
      const lines = [
  "[booting] Initializing consciousness...",
    ];
      
for (const line of lines) {
        await printToTerminal(line);
        document.getElementById('logoContent').style.opacity = 1;
setTimeout(() => {
  document.getElementById('actionButtons').style.opacity = 1;
}, 200);

        await delay(300 + Math.random() * 200);
      }
    }

async function startVaultBuild() {
  if (!vaultBuildManuallyTriggered) {
    console.warn("Prevented auto-start of vault build.");
    return;
  }

  try {
    printToTerminal("[*] Loading user input...", 5);
    await delay(200);
    const inputs = await loadUserInputs();

    printToTerminal("[*] Preparing vault structure...", 15);
    const files = await loadIndexedFiles();
    printToTerminal(`[+] Found ${files.length} file(s) for encryption.`, 20);
    await delay(150);

    printToTerminal("[*] Deriving base key...", 25);
    const unlockConcat = inputs.unlockAnswer1 + inputs.unlockAnswer2;

    printToTerminal("[*] Generating full key salt...", 38);
    const fullSalt = generateRandomHex(32);

    printToTerminal("[*] Selecting and permuting questions...", 45);
    const numQuestions = inputs.normalizedAnswers.length;
    const allIndices = Array.from({ length: numQuestions }, (_, i) => i);
    const gateIndices = [inputs.unlockIndexes[0], inputs.unlockIndexes[1]];
    const layer2Indices = allIndices.filter(i => !gateIndices.includes(i));
    const selectedL2Indices = layer2Indices.sort(() => Math.random() - 0.5).slice(0, 6);
    const remainingL2Indices = layer2Indices.filter(i => !selectedL2Indices.includes(i));

    // 1) FULL payload (includes uploads)
    printToTerminal("[+] Encrypting FULL vault...", 60);
    const payloadsFull = await encryptVaultPayload(
      inputs, files, unlockConcat, null, fullSalt,
      selectedL2Indices, gateIndices, remainingL2Indices, /* liteMode */ false
    );

    printToTerminal("[*] Packaging FULL vault...", 80);
    await packageAndDownloadZip(payloadsFull, inputs, fullSalt, gateIndices);
    printToTerminal("[✔] Full vault downloaded.", 90);

    // 2) LITE payload — let the user choose contents (≤ 150 KB)
const namedSeedFiles = JSON.parse(localStorage.getItem("namedSeedFiles") || "[]");
const finalMessageBytesLen = inputs.finalMessage?.trim()
  ? new TextEncoder().encode(inputs.finalMessage.trim()).length
  : 0;

printToTerminal("[*] Choose what to include in your paper backup...", 92);
let liteSelection = null;
try {
  liteSelection = await openLitePicker({
    seedFiles: namedSeedFiles,
    uploads: files,
    finalMessageBytesLen
  });
} catch (e) {
  if (e && e.message === "User cancelled Lite picker") {
    printToTerminal("[i] Paper backup skipped by user. Proceeding to final instructions...", 96);
    showPostBuildModal();
    return; // exit gracefully instead of throwing
  }
  throw e; // real error, let outer catch handle
}

printToTerminal("[*] Building Lite Vault (using your selection)...", 94);
const payloadsLite = await buildLitePayloadFromFull(
  inputs,                     // userData
  files,                      // provide uploads so selection can include them
  inputs.unlockAnswer1 + inputs.unlockAnswer2,
  fullSalt,
  gateIndices,
  selectedL2Indices,
  remainingL2Indices,
  payloadsFull,
  liteSelection
);

// ZIP the Lite vault (don’t download directly)
const liteZipBlob = await makeLiteVaultZipBlob(
  payloadsLite, inputs, fullSalt, gateIndices
);

// Turn Lite ZIP into a single-file QR PDF and auto-download
printToTerminal("[*] Encrypting Lite ZIP and creating single-file QR PDF...", 96);
await buildPaperPdfFromLiteZip(liteZipBlob);

    printToTerminal("[✔] Full vault and paper PDF created.", 100);
    showPostBuildModal();
  } catch (err) {
    console.error("Vault build error:", err);
    printToTerminal(`[!] Error: ${err.message}`, null);
    showToast("Something went wrong while creating your vault.");
  }
}

async function loadUserInputs() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open("memoroVaultDB", 2);
    req.onerror = () => reject("Failed to open IndexedDB.");
    req.onsuccess = async () => {
      const db = req.result;
      const tx = db.transaction("vaultUserData", "readonly");
      const store = tx.objectStore("vaultUserData");
      const getReq = store.get("userData");

      getReq.onsuccess = () => {
        const data = getReq.result;
        if (!data) return reject("User data not found in IndexedDB.");

        const unlockAnswer1 = (data.answers[data.unlockIndexes[0]] || "").trim().toLowerCase();
        const unlockAnswer2 = (data.answers[data.unlockIndexes[1]] || "").trim().toLowerCase();

        const normalizedAnswers = data.answers.map((a, i) =>
          i === data.trapIndex ? "" : (a || "").trim().toLowerCase()
        );

        resolve({
          ...data,
          unlockAnswer1,
          unlockAnswer2,
          normalizedAnswers
        });

        db.close();
      };
      getReq.onerror = () => reject("Failed to read user data from IndexedDB.");
    };
  });
}

    async function loadIndexedFiles() {
      const uploadedMeta = JSON.parse(localStorage.getItem("uploadedFileMeta") || "[]");
      const db = await new Promise((resolve, reject) => {
        const req = indexedDB.open("memoroVaultDB", 2);
        req.onerror = () => reject("IndexedDB open failed");
        req.onsuccess = () => resolve(req.result);
      });

      const result = [];
      for (const meta of uploadedMeta) {
        const fileData = await new Promise((resolve, reject) => {
          const tx = db.transaction("vaultFiles", "readonly");
          const store = tx.objectStore("vaultFiles");
          const getReq = store.get(meta.id);
          getReq.onsuccess = () => resolve(getReq.result?.raw);
          getReq.onerror = () => reject("File read failed");
        });
        result.push({ ...meta, raw: fileData });
      }
      db.close();
      return result;
    }

    // getVaultKeyMaterial.js
function getVaultKeyMaterial({ gateAnswers, knownAnswers, bruteAnswers, gateIndices, knownAnswerIndices, bruteIndices, fullSalt }) {
  // Answers must be placed in the correct slot
  const allAnswers = [];
  const totalLen = gateIndices.length + knownAnswerIndices.length + bruteIndices.length;
  // Find max index
  const maxIndex = Math.max(...gateIndices, ...knownAnswerIndices, ...bruteIndices);
  for (let i = 0; i <= maxIndex; i++) allAnswers[i] = "";
  gateIndices.forEach((idx, i) => { allAnswers[idx] = gateAnswers[i]; });
  knownAnswerIndices.forEach((idx, i) => { allAnswers[idx] = knownAnswers[i]; });
  bruteIndices.forEach((idx, i) => { allAnswers[idx] = bruteAnswers[i]; });
  const fullConcat = allAnswers.join('');
  return fullSalt + fullConcat;
}

// blankRedHerring.js
function blankRedHerring(answers, trapIndex) {
  if (trapIndex !== undefined && trapIndex !== null && trapIndex >= 0 && trapIndex < answers.length) {
    answers = answers.slice();
    answers[trapIndex] = "";
  }
  return answers;
}
    // deriveKey.js
async function deriveKey(password, saltHex, settingsOverride) {

  const encoder = new TextEncoder();
  const passwordBytes = encoder.encode(password);
  const salt = saltHex
    ? Uint8Array.from(saltHex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)))
    : new Uint8Array(await crypto.subtle.digest('SHA-256', passwordBytes));
  const settings = settingsOverride || {
      time: 3,
      mem: 16384,
      parallelism: 1,
      type: "Argon2id",
      hashLen: 32
  };
  const argonResult = await argon2.hash({
    pass: password,
    salt,
    time: settings.time,
    mem: settings.mem,
    parallelism: settings.parallelism,
    type: argon2.ArgonType[settings.type] || argon2.ArgonType.Argon2id,
    hashLen: settings.hashLen || 32
  });
  const keyBytes = new Uint8Array(
    argonResult.hashHex.match(/.{1,2}/g).map(byte => parseInt(byte, 16))
  );
  return crypto.subtle.importKey(
    'raw',
    keyBytes,
    { name: 'AES-GCM' },
    true,
    ['encrypt', 'decrypt']
  );
}

    // Add generatePermutations function from recover.html
    function generatePermutations(array) {
      if (array.length <= 1) return [array.slice()];
      const result = [];

      for (let i = 0; i < array.length; i++) {
        const current = array[i];
        const remaining = array.slice(0, i).concat(array.slice(i + 1));
        const perms = generatePermutations(remaining);
        for (const perm of perms) {
          result.push([current, ...perm]); // force copy
        }
      }

      return result;
    }

async function encryptVaultPayload(
  userData,
  files,
  unlockConcat,
  _unused_fullConcat,
  fullSalt,
  selectedL2Indices,
  gateIndices,
  remainingL2Indices,
  liteMode = false,
  opts = {} // { fixedLayer1Salt?: string, fixedPermutation?: string[], liteSelection?: { includeFinalMessage:boolean, seedNames:string[], uploadIds:string[] } }
) {
  const encoder = new TextEncoder();

  // ── Layer 1 key (gate answers) ───────────────────────────────────────────────
  const layer1Salt = opts.fixedLayer1Salt || generateRandomHex(32);
  const layer1Key = await deriveKey(unlockConcat, layer1Salt, {
    time: 3, mem: 16384, parallelism: 1, type: "Argon2id", hashLen: 32
  });

  // Build questionList (unchanged)
  const questionList = userData.answers.map((ans, i) => {
    const trimmed = (ans || "").trim();
    const spaceIndexes = userData.spaceIndexes?.[i] || [];
    const hintEntry = userData.hints?.[i] || {};
    const showLength = typeof hintEntry.showLength === "boolean" ? hintEntry.showLength : true;

    let hintValuesLocal = Array.isArray(hintEntry.values)
      ? [...hintEntry.values]
      : Array.isArray(hintEntry.letters)
        ? hintEntry.letters.map(pos => {
            const char = trimmed[pos - 1];
            return char !== undefined ? char : "_";
          })
        : [];

    return {
      question: userData.questions[i] || `Question ${i + 1}`,
      expectedLength: showLength ? trimmed.length : null,
      hintLetters: [...(hintEntry.letters || [])],
      hintValues: hintValuesLocal,
      spaceIndexes: [...spaceIndexes],
      custom: typeof hintEntry.custom === "string"
        ? hintEntry.custom
        : Array.isArray(hintEntry.custom)
          ? hintEntry.custom.join(", ")
          : typeof hintEntry.custom === "object" && hintEntry.custom !== null
            ? JSON.stringify(hintEntry.custom)
            : "",
      showLength
    };
  });

  // Encrypt L1 question metadata
  const iv1 = crypto.getRandomValues(new Uint8Array(12));
  const encQuestions = encoder.encode(JSON.stringify({
    questionList, selectedL2Indices, remainingL2Indices, gateIndices
  }));
  const encData = await crypto.subtle.encrypt({ name: "AES-GCM", iv: iv1 }, layer1Key, encQuestions);
  const vaultEncrypted = { ciphertext: Array.from(new Uint8Array(encData)), iv: Array.from(iv1) };

  // ── Permutation & fullKey derivation (shared across Full/Lite) ──────────────
  let finalPermutationUsed = opts.fixedPermutation;
  if (!finalPermutationUsed) {
    const perms = generatePermutations(selectedL2Indices.map(i => userData.normalizedAnswers[i]));
    const randIndex = Math.floor(Math.random() * perms.length);
    finalPermutationUsed = perms[randIndex];
  }

  const permutedAnswers = [
    userData.normalizedAnswers[gateIndices[0]],
    userData.normalizedAnswers[gateIndices[1]],
    ...remainingL2Indices.map(i => userData.normalizedAnswers[i]),
    ...finalPermutationUsed
  ];
  const permutedConcat = permutedAnswers.join('');

  const fullKey = await deriveKey(permutedConcat, fullSalt, {
    time: 3, mem: 16384, parallelism: 1, type: "Argon2id", hashLen: 32
  });

  // vaultHash binds order + answers
  const vaultHashRaw = await sha256Hash(new TextEncoder().encode(permutedConcat));
  const vaultHash = Array.from(vaultHashRaw).map(b => b.toString(16).padStart(2, '0')).join('');

  // ── Per-file encryption helper ──────────────────────────────────────────────
  const fileMeta = [];
  const encryptedFiles = [];
  let finalMessageInfo = null; // { internal, iv }

  async function encryptAndPushFile(buffer, name, mime) {
    const fileId = crypto.randomUUID().replace(/-/g, '');
    const internalFilename = fileId + ".vaultdoc";
    const fileSalt = new Uint8Array(await sha256Hash(new TextEncoder().encode(permutedConcat + fileId)));

    const argonResult = await argon2.hash({
      pass: permutedConcat + fileId,
      salt: fileSalt,
      time: 3, mem: 16384, parallelism: 1,
      type: argon2.ArgonType.Argon2id, hashLen: 32
    });

    const rawKey = argonResult.hash; // Uint8Array (argon2-browser)
    const aesKey = await crypto.subtle.importKey("raw", rawKey, { name: "AES-GCM" }, false, ["encrypt"]);
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const encryptedBuffer = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, aesKey, buffer);

    const sha256Hex = Array.from(await sha256Hash(buffer)).map(b => b.toString(16).padStart(2, '0')).join('');

    fileMeta.push({
      id: fileId,
      filename: internalFilename,
      originalName: name,
      mimeType: mime,
      iv: Array.from(iv),
      sha256: sha256Hex
    });

    const blob = new Blob([new Uint8Array(encryptedBuffer)], { type: "application/octet-stream" });
    encryptedFiles.push({ filename: internalFilename, blob });

    if (name === "final-message.txt") {
      finalMessageInfo = { internal: internalFilename, iv: Array.from(iv) };
    }
  }

  // ---------- Decide what to include ----------
  const namedSeedFiles = JSON.parse(localStorage.getItem("namedSeedFiles") || "[]");
  let seedsToInclude   = namedSeedFiles;
  let uploadsToInclude = files;
  let includeFinal     = !!(userData.finalMessage && userData.finalMessage.trim());

  if (liteMode && opts.liteSelection) {
    const sel = opts.liteSelection;

    // Filter seeds by name
    seedsToInclude = namedSeedFiles.filter(s => sel.seedNames.includes(s.name));

    // Filter uploads by id
    const idSet = new Set(sel.uploadIds.map(String));
    uploadsToInclude = files.filter(f => idSet.has(String(f.id)));

    // Final message toggle
    includeFinal = !!sel.includeFinalMessage;

    // Safety cap (raw)
    let total = 0;
    for (const s of seedsToInclude) total += new TextEncoder().encode(s.content || '').length;
    for (const u of uploadsToInclude) total += (u?.raw?.byteLength || 0);
    if (includeFinal) total += new TextEncoder().encode(userData.finalMessage.trim()).length;
    if (total > LITE_CAP_BYTES) {
      throw new Error(`Lite selection exceeds 150 KB cap (${total} bytes).`);
    }
  }

  // ---------- Encrypt the chosen content ----------
  // Uploads: all files in FULL; in LITE only chosen ones
  if (!liteMode) {
    for (const f of uploadsToInclude) {
      await encryptAndPushFile(new Uint8Array(f.raw), f.name, f.type);
    }
  } else {
    // liteMode: include only the selected uploads (if any)
    for (const f of uploadsToInclude) {
      await encryptAndPushFile(new Uint8Array(f.raw), f.name, f.type);
    }
  }

  // Seeds
  for (const seed of seedsToInclude) {
    await encryptAndPushFile(new TextEncoder().encode(seed.content), seed.name, "text/plain");
  }

  // Final message
  if (includeFinal) {
    await encryptAndPushFile(new TextEncoder().encode(userData.finalMessage.trim()), "final-message.txt", "text/plain");
  }

  // Encrypt vault.meta with fullKey
  const iv3 = crypto.getRandomValues(new Uint8Array(12));
  const metaEnc = new TextEncoder().encode(JSON.stringify({
    files: fileMeta,
    seedFiles: seedsToInclude,
    vaultHash
  }));
  const metaData = await crypto.subtle.encrypt({ name: "AES-GCM", iv: iv3 }, fullKey, metaEnc);
  const fileMetaEncrypted = { data: new Uint8Array(metaData), iv: Array.from(iv3) };

  return {
    vaultEncrypted,
    fileMetaEncrypted,
    encryptedFiles,
    layer1Salt,
    vaultHash,
    selectedPermutation: finalPermutationUsed,
    finalMessageInfo // { internal, iv } or null
  };
}

    async function packageAndDownloadZip(payloads, userData, fullSalt, gateIndices) {
  const writer = new zip.ZipWriter(new zip.BlobWriter("application/zip"));
  const addJSON = (name, data) => writer.add(name, new zip.TextReader(JSON.stringify(data, null, 2)));
  const addBlob = (name, blob) => writer.add(name, new zip.BlobReader(blob));

  // DO NOT include selected answers or permutation in plaintext
  await addJSON("vault.json", {
    version: "1.0.6",
    created: new Date().toISOString(),
    instructions: "Use recover.html to unlock this archive using your answers.",
    fullSalt,
    layer1Salt: payloads.layer1Salt,
    questionPrompts: [
      userData.questions[gateIndices[0]] || `Question ${gateIndices[0] + 1}`,
      userData.questions[gateIndices[1]] || `Question ${gateIndices[1] + 1}`
    ],
    vaultMetaIv: payloads.fileMetaEncrypted.iv,
    argonSettings: { time: 3, mem: 16384, parallelism: 1, type: "Argon2id", hashLen: 32 },
  });

  await addJSON("vault.enc", payloads.vaultEncrypted);
  await addBlob("vault.meta", new Blob([payloads.fileMetaEncrypted.data], { type: "application/octet-stream" }));

  for (const file of payloads.encryptedFiles) {
    await addBlob(file.filename, file.blob);
  }

// FULL ONLY helper docs
await writer.add("README.txt", new zip.TextReader(
`Memoro Vault
===========

What you have found is an encrypted archive created with Memoro Vault.
It was likely prepared by someone who wished their most important digital
information to be preserved securely and passed down.

Inside this archive are files and messages that can only be unlocked
with the correct answers to memory-based questions. Without those answers,
decryption is mathematically impossible. There are no backdoors.

To open this vault, you will need:
1. The Memoro Vault program (provided as a desktop installer in the same folder).
2. The exact answers to the questions chosen by the person who built it.
3. The original vault file itself (this ZIP).

If you are a family member who has recently discovered these files, this vault
was designed to protect sensitive material such as letters, records,
cryptocurrency keys, or final instructions. Guard it carefully.

Redundant storage is critical: make multiple copies to M-DISC, offline drives,
and printed QR backups if available. A single corrupt copy can render it
unrecoverable.

Libereco ne estas donaco. Ĝi estas devo.
— Kaŝmaristo Delvakto`
));

await writer.add("Vault_Builder_Instructions.txt", new zip.TextReader(
`Vault Builder Instructions
=========================

This archive was created with Memoro Vault. If you are reading this, it
means the vault was intentionally packaged for long-term preservation.

To keep it safe:
1. Place this ZIP file together with the Memoro Vault installer
   (e.g. memoro-win.exe, memoro-linux.AppImage, or memoro-mac.dmg)
   inside a clearly labeled folder (for example, "Family_Vault").
2. Copy that folder to multiple storage media:
   • One archival M-DISC
   • One offline USB/SSD in a fireproof safe
   • One cloud service of your choice
3. If a paper QR backup PDF was produced, print and store it with equal care.
   Those QR tiles can fully reconstruct this vault if digital copies are lost.

Important: Do not rename, modify, or edit any files inside this archive.
Doing so will make the vault impossible to recover.

To unlock, run the Memoro Vault recovery program and follow the on-screen
instructions. You will be prompted to enter answers in the exact order
chosen by the original builder.

Libereco ne estas donaco. Ĝi estas devo.
— Kaŝmaristo Delvakto`
));

  const blob = await writer.close();
  const link = document.createElement("a");
  link.href = URL.createObjectURL(blob);
  link.download = "memoro-vault.zip";
  link.click();
}

    async function makeLiteVaultZipBlob(payloadsLite, userData, fullSalt, gateIndices) {
  const writer = new zip.ZipWriter(new zip.BlobWriter("application/zip"));
  const addJSON = (name, data) => writer.add(name, new zip.TextReader(JSON.stringify(data, null, 2)));
  const addBlob = (name, blob) => writer.add(name, new zip.BlobReader(blob));

  // Identical contract as FULL. No selected answers or permutations in plaintext.
  await addJSON("vault.json", {
    version: "1.0.6",
    created: new Date().toISOString(),
    instructions: "Use recover.html to unlock this archive using your answers.",
    fullSalt,
    layer1Salt: payloadsLite.layer1Salt,
    questionPrompts: [
      userData.questions[gateIndices[0]] || `Question ${gateIndices[0] + 1}`,
      userData.questions[gateIndices[1]] || `Question ${gateIndices[1] + 1}`
    ],
    vaultMetaIv: payloadsLite.fileMetaEncrypted.iv,
    argonSettings: { time: 3, mem: 16384, parallelism: 1, type: "Argon2id", hashLen: 32 },
  });

  // vault.enc + vault.meta
  await addJSON("vault.enc", payloadsLite.vaultEncrypted);
  await addBlob("vault.meta", new Blob([payloadsLite.fileMetaEncrypted.data], { type: "application/octet-stream" }));

  // Only seed/final encrypted files are present
  for (const f of payloadsLite.encryptedFiles) {
    await addBlob(f.filename, f.blob);
  }

  // No README / instructions in Lite
  const blob = await writer.close();
  return blob;
}

    // Build a Lite payload that derives keys EXACTLY like the full vault.
// Uses the SAME unlockConcat, SAME layer1Salt, SAME permutation, and SAME fullSalt.
async function buildLitePayloadFromFull(
  userData,
  files,                 // pass the real uploads array here (Lite will filter via liteSelection)
  unlockConcat,          // MUST be the same value used for the Full build (e.g., answer1 + answer2)
  fullSalt,
  gateIndices,
  selectedL2Indices,
  remainingL2Indices,
  payloadsFull,          // from the first encryptVaultPayload call
  liteSelection          // { includeFinalMessage, seedNames, uploadIds }
) {
  if (!payloadsFull || !payloadsFull.layer1Salt || !payloadsFull.selectedPermutation) {
    throw new Error("Lite build requires layer1Salt and selectedPermutation from the Full build.");
  }

  const fixedLayer1Salt  = payloadsFull.layer1Salt;         // reuse exact L1 salt
  const fixedPermutation = payloadsFull.selectedPermutation; // reuse exact permutation

  // IMPORTANT: pass unlockConcat (not null) so Argon2 derives the SAME L1 key as Full
  const payloadsLite = await encryptVaultPayload(
    userData,
    files,                 // uploads available; function will include only those selected
    unlockConcat,          // ✅ same as Full
    null,                  // _unused_fullConcat
    fullSalt,              // ✅ same as Full for deriving the final key
    selectedL2Indices,
    gateIndices,
    remainingL2Indices,
    /* liteMode */ true,
    { fixedLayer1Salt, fixedPermutation, liteSelection }
  );

  return payloadsLite;
}

    function showBackupMessage(url) {
      const msg = document.createElement('p');
      msg.innerHTML = `If your download didn’t start, <a href="${url}" download="memoro-vault.zip">click here to download manually</a>.`;
      msg.style.color = '#aaa';
      msg.style.fontSize = '16px';
      msg.style.marginTop = '30px';
      document.body.appendChild(msg);
    }


function retryDownload() {
  window.location.reload();
}

    const canvas = document.getElementById('matrixCanvas');
    const ctx = canvas.getContext('2d');

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const letters = 'モヤユヨラリルレロワヲンABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890@$%&'.split('');
    const fontSize = 14;
    const columns = canvas.width / fontSize;
    const drops = Array(Math.floor(columns)).fill(1);

    function draw() {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = '#0F0';
      ctx.font = fontSize + 'px monospace';

      for (let i = 0; i < drops.length; i++) {
        const text = letters[Math.floor(Math.random() * letters.length)];
        ctx.fillText(text, i * fontSize, drops[i] * fontSize);

        if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
          drops[i] = 0;
        }

        drops[i]++;
      }
    }

    setInterval(draw, 40);
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });

    function preserveAndGoBack() {
  preserveOnBack = true;
  history.back();
}

window.addEventListener("beforeunload", (e) => {
  if (!preserveOnBack) {
    nukeEverything();
  }
});
      
async function nukeEverything() {
  try {
    localStorage.clear();
    sessionStorage.clear();
    if (indexedDB.databases) {
      const dbs = await indexedDB.databases();
      for (const db of dbs) {
        indexedDB.deleteDatabase(db.name);
      }
    } else {
      indexedDB.deleteDatabase("memoroVaultVaultStorage");
      indexedDB.deleteDatabase("memoroVaultDB");
    }
    console.log("Memoro Vault: Local memory wiped.");
  } catch (err) {
    console.warn("Memoro Vault wipe failed:", err);
  }
}

function showPostBuildModal() {
  const modal = document.getElementById("postBuildModal");
  document.body.style.overflow = "hidden"; // Prevent body scroll behind modal
  if (modal) {
    modal.style.display = "flex"; // Use flex to keep it centered and scrollable
  }
}

function closePostBuildModal() {
  const modal = document.getElementById("postBuildModal");
  if (modal) {
    document.body.style.overflow = ""; 
    modal.style.display = "none";
    setTimeout(() => {
      nukeEverything(); // ✅ add this
      window.location.href = "dashboard.html";
    }, 300);
  }
}

  </script>
</body> 
</html>