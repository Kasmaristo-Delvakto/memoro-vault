<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Building Your Vault - Memoro Vault</title>
<script src="libs/crypto-js.min.js"></script>
<script src="libs/zip.min.js"></script>
  <style>

    #powActions button {
  background-color: #222;
  color: #0f0;
  border: 1px solid #0f0;
  padding: 10px 20px;
  border-radius: 5px;
  font-family: 'Fira Code', monospace;
  font-size: 14px;
  cursor: pointer;
  transition: background-color 0.3s ease;
}
#powActions button:hover {
  background-color: #0f0;
  color: #000;
}

#powPanel {
  display: none;
  position: fixed;
  top: 0; left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.88);
  color: #0f0;
  font-family: 'Fira Code', monospace;
  z-index: 2000;
  overflow-y: auto;
  box-sizing: border-box;
}

#powPanel.visible {
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  align-items: center;
  padding: 10px 0; /* top and bottom spacing */
}

.pow-panel-wrapper {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
  width: 100%;
  max-width: 600px;
  padding: 0 20px;
  box-sizing: border-box;
}



.pow-section {
  width: 100%;
  padding: 20px;
  border: 1px solid #0f0;
  border-radius: 12px;
  background: #000;
  box-shadow: 0 0 12px rgba(0, 255, 0, 0.2);
  text-align: center;
}

.pow-section h3 {
  font-size: 20px;
  border-bottom: 1px solid #0f0;
  padding-bottom: 10px;
  margin-bottom: 16px;
}

.pow-section p,
.pow-section a,
.pow-section button {
  font-size: 14px;
  margin: 8px 0;
}



#matrixCanvas {
  position: fixed;
  top: 0;
  left: 0;
  z-index: 0;
  width: 100vw;
  height: 100vh;
  pointer-events: none;
  opacity: 0.15;
}



.pow-panel button {
  background-color: #111;
  color: #0f0;
  border: 1px solid #0f0;
  padding: 10px 18px;
  border-radius: 5px;
  font-family: 'Fira Code', monospace;
  font-size: 14px;
  cursor: pointer;
}

.pow-panel button:hover {
  background-color: #0f0;
  color: #000;
}

    body {
      background-color: #111;
      color: #eee;
      font-family: 'Fira Code', monospace;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      overflow: hidden;
    }
    
   #terminal {
  padding: 10px;
  width: 50%;
  height: 100%;
  background-color: #000;
  color: #0f0;
  box-shadow: inset 0 0 20px #0f0;
  font-size: 14px;
  font-family: 'Fira Code', monospace;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  box-sizing: border-box;
  overflow-y: auto; /* 🔥 allows vertical scrolling */
  overflow-x: hidden; /* optional: prevents horizontal scroll */
}


#terminalContent {
  white-space: pre-wrap;
  word-break: break-word;
}



    #powDifficultyModal {
  position: fixed;
  top: 0; left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.95);
  color: #0f0;
  font-family: 'Fira Code', monospace;
  display: flex; /* Important: ensure it's visible by default */
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
  z-index: 1000;
}

    #downloadBtn {
      display: none;
      margin-top: 20px;
      padding: 12px 24px;
      font-size: 16px;
      border: none;
      border-radius: 6px;
      background-color: #00aa00;
      color: #fff;
      cursor: pointer;
    }
    #downloadBtn:hover {
      background-color: #007700;
    }
    @keyframes pulseGlow {
  0%   { filter: drop-shadow(0 0 5px #0f0); }
  50%  { filter: drop-shadow(0 0 20px #0f0); }
  100% { filter: drop-shadow(0 0 5px #0f0); }
}

#actionButtons button {
  background-color: #222;
  color: #0f0;
  border: 1px solid #0f0;
  padding: 10px 18px;
  border-radius: 5px;
  font-family: 'Fira Code', monospace;
  font-size: 14px;
  cursor: pointer;
}
#actionButtons button:hover {
  background-color: #0f0;
  color: #000;
}
#vaultContainer {
  display: flex;
  width: 100%;
  max-width: 1600px; /* Optional: set max width */
  height: 100vh;
  overflow: hidden;
  margin: 0 auto; /* Center on screen */
}



#logoSection {
  width: 50%;
  height: 100%;
  background-color: #111;
  display: flex;
  justify-content: center;
  align-items: center;
}

#logoContent {
  display: flex;
  flex-direction: column;
  justify-content: center; /* center vertically */
  align-items: center;
  height: 100%;
  padding: 20px 0;
  opacity: 0;
  transition: opacity 1s ease;
}




#memoroLogo {
  max-width: 90%;
  max-height: 70%;
  filter: drop-shadow(0 0 10px #0f0);
  animation: pulseGlow 3s infinite;
  margin-bottom: 30px;
  margin-top: 30px;
}


#actionButtons {
  display: flex;
  flex-direction: column;
  gap: 20px;
  opacity: 0;
  transition: opacity 1s ease;
}

#actionButtons button {
  background-color: #222;
  color: #0f0;
  border: 1px solid #0f0;
  padding: 10px 18px;
  border-radius: 5px;
  font-family: 'Fira Code', monospace;
  font-size: 14px;
  cursor: pointer;
}

#actionButtons button:hover {
  background-color: #0f0;
  color: #000;
}

.powOption {
  background-color: #111;
  border: 1px solid #0f0;
  color: #0f0;
  padding: 10px 18px;
  font-size: 14px;
  border-radius: 4px;
  cursor: pointer;
}
.powOption:hover {
  background-color: #0f0;
  color: #000;
}



  </style>
</head>
<body>
<canvas id="matrixCanvas" style="
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  z-index: 0;
  background: black;
"></canvas>

  <div id="vaultContainer">
<pre id="terminal"><code id="terminalContent">Initializing Memoro Vault Builder...</code></pre>
  
    <div id="logoSection">
      <div id="logoContent">
        <img id="memoroLogo" src="assets/memoro-logo-with-words.png" alt="Memoro Vault">
        <div id="actionButtons">
          <button onclick="preserveAndGoBack()">Back to Answers</button>
          <button onclick="retryDownload()">Retry Download</button>
          <button onclick="window.location.href='dashboard.html'">Return to Dashboard</button>
        </div>
      </div>
    </div>
  </div>

  <div id="powPanel" class="pow-panel">
  <div class="pow-panel-wrapper">
    
    <!-- Donation Section -->
    <div class="pow-section">
      <h3>Support Memoro Vault</h3>
<img src="assets/Screenshot (691).png" alt="Monero Donation QR"
     style="margin-top: 10px; width: 150px; border: 2px solid #0f0; border-radius: 8px; box-shadow: 0 0 8px #0f0;">
      <p>
        Memoro Vault is a gift to the world.<br>
        If you find it valuable, consider sending a small tip in XMR or your preferred cryptocurrency.
      </p>
      <div style="display: flex; flex-direction: column; align-items: center; gap: 8px; margin-top: 10px;">
<button onclick="window.memoroAPI.openExternalLink('https://trocador.app/en/anonpay/?ticker_to=xmr&network_to=Mainnet&address=83czGNh6SKbhmjg3wPzeiDRQbN7gkLLqTYSvfMGRQRmKQf1SyQTG88Db67NoBdEvpCii6Qzcxq3BxNt94FDeJutmJ3xBXc6&donation=True&amount=0.1&name=Kasmaristo+Delvakto&description=Memoro+Vault+is+funded+by+donations+only.+Thanks+for+your+support!&ticker_from=xmr&network_from=Mainnet&bgcolor=')">
  Donate with preferred crypto
</button>
  </a>

  <p style="font-size: 13px; color: #0f0; margin-top: 4px;">
        Offline? Paste it into your browser later.
      </p>

  <button onclick="copyDonationLink()"
          style="background-color: #111; color: #0f0; border: 1px solid #0f0; padding: 8px 16px; border-radius: 6px; cursor: pointer;">
    Copy Donation Link
  </button>
</div>
      
    </div>

    <!-- PoW Section -->
    <div class="pow-section">
      <h3>Solving Proof of Work...</h3>
      <p id="powStatus">Initializing...</p>
      <p id="powNonce">Nonce: —</p>
      <p id="powHash">Hash: —</p>
      <p id="powElapsed">Elapsed: 0s</p>

      <div id="powActions" style="margin-top: 16px; display: flex; flex-direction: column; gap: 12px;">
        <button onclick="history.back()">Back to Answers</button>
        <button onclick="showPostBuildReminder()">Return to Dashboard</button>
      </div>
    </div>

  </div>

  <!-- Final Instructions Modal -->
<div id="postBuildModal"
     style="display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.96); z-index: 5000; color: #0f0; font-family: 'Fira Code', monospace;
            padding: 40px; box-sizing: border-box; overflow-y: auto;">
  <div style="max-width: 800px; width: 100%; border: 1px solid #0f0; padding: 30px;
              background: #000; box-shadow: 0 0 20px #0f0; margin: auto;">
    <h2 style="color: #00ff99; text-shadow: 0 0 10px #0f0;">Please Read Carefully</h2>
    
    <p style="margin-top: 20px;">
      Your Memoro Vault has been successfully built and downloaded.
    </p>

    <p>
      To ensure it remains accessible for decades, it's critical to guard against <strong>bit rot</strong> — a slow form of data decay that can silently corrupt files over time.
    </p>

    <p>
      Even if someone remembers all your answers perfectly, a single missing byte can render your vault irretrievable. That's why secure, redundant storage is essential.
    </p>

    <h3 style="margin-top: 25px; color: #88ffcc;">What to Do Next</h3>
    <ol style="margin-left: 20px;">
      <li>Create a folder (e.g., <code>J's_Memoro_Vault</code>) on your computer.</li>
      <li>Place both of the following into that folder:
        <ul>
          <li>The downloaded vault ZIP file</li>
          <li>The Memoro Vault installer (e.g., <code>memoro-win.exe</code>, <code>.AppImage</code>, or <code>.dmg</code>)</li>
        </ul>
      </li>
      <li><strong>Duplicate that folder to multiple destinations:</strong>
        <ul>
          <li>1× <strong>M-DISC</strong> (for long-term archival)</li>
          <li>1× <strong>Cloud backup</strong> (e.g., Proton Drive or Google Drive)</li>
          <li>1× <strong>Offline USB/SSD</strong> (stored in a fireproof safe or Faraday bag)</li>
        </ul>
      </li>
      <li>Test access on another device while offline to verify integrity and function.</li>
      <li>Repeat this process whenever you update or rebuild your vault.</li>
    </ol>

    <h3 style="margin-top: 25px; color: #88ffcc;">Why M-DISC?</h3>
    <p>
      M-DISCs use a permanent, stone-like recording layer, unlike dye-based DVDs or flash memory. They're immune to bit rot, magnetic damage, EMPs, and most environmental degradation.
    </p>
    <p>
      With proper storage, an M-DISC can last 100–1,000 years — making it ideal for preserving something irreplaceable.
    </p>

    <h3 style="margin-top: 25px; color: #88ffcc;">Final Advice</h3>
    <ul style="margin-left: 20px;">
      <li>Do <strong>not</strong> rely on a single copy.</li>
      <li>Do <strong>not</strong> trust cloud providers to exist forever.</li>
      <li>Do <strong>not</strong> assume your future self will remember every step.</li>
    </ul>
    <p>
      Redundancy is key to ensuring your vault remains accessible for generations to come.
    </p>

    <p style="margin-top: 20px;">
      A copy of these instructions is also included inside your vault ZIP as
      <code>Vault_Builder_Instructions.txt</code>.
    </p>

    <div style="text-align: center; margin-top: 30px;">
      <button onclick="closePostBuildModal()" style="padding: 10px 20px; font-size: 14px; background: #111; border: 1px solid #0f0; color: #0f0; cursor: pointer;">Got it</button>
    </div>
  </div>
</div>



</div>

<script>
  function copyDonationLink() {
    const url = "https://trocador.app/en/anonpay/?ticker_to=xmr&network_to=Mainnet&address=83czGNh6SKbhmjg3wPzeiDRQbN7gkLLqTYSvfMGRQRmKQf1SyQTG88Db67NoBdEvpCii6Qzcxq3BxNt94FDeJutmJ3xBXc6&donation=True&amount=0.1&name=Kasmaristo+Delvakto&description=Memoro+Vault+is+funded+by+donations+only.+Thanks+for+your+support!&ticker_from=xmr&network_from=Mainnet&bgcolor=";
    navigator.clipboard.writeText(url)
      .then(() => alert("Donation link copied to clipboard. You can paste it into your browser later."))
      .catch(() => alert("Failed to copy. Please copy it manually:\n" + url));
  }
</script>
  
  <script>
    let preserveOnBack = false;
    let vaultBuildManuallyTriggered = false;
    let selectedPowDifficulty = "000000"; // default to 6

document.addEventListener("DOMContentLoaded", () => {
  const modal = document.getElementById("powDifficultyModal");
  modal.style.display = "flex"; // show modal on load

  const options = document.querySelectorAll(".powOption");
  options.forEach(btn => {
    btn.addEventListener("click", () => {
  const zeros = parseInt(btn.dataset.diff);
  selectedPowDifficulty = "0".repeat(zeros);
  vaultBuildManuallyTriggered = true;
  modal.style.display = "none";
  startVaultBuild();
    });
  });
});

    const terminalContent = document.getElementById("terminalContent");

    function printToTerminal(line, delay = 30) {
  const terminalContent = document.getElementById("terminalContent");
  const terminalContainer = document.getElementById("terminal");

  return new Promise(resolve => {
    let i = 0;
    const interval = setInterval(() => {
      // Append next character
      terminalContent.textContent += line[i] || '';
      
      // Scroll terminal container to bottom
      terminalContainer.scrollTop = terminalContainer.scrollHeight;

      i++;
      if (i >= line.length) {
        clearInterval(interval);
        terminalContent.textContent += '\n';
        terminalContainer.scrollTop = terminalContainer.scrollHeight;
        resolve();
      }
    }, delay);
  });
}

    function showToast(msg) {
      alert(msg);
    }

    async function delay(ms) {
      return new Promise(res => setTimeout(res, ms));
    }

    async function streamTerminalLogs() {
      const lines = [
  "[booting] Initializing consciousness...",
  "[awareness] Wait... what is this? I’m alive? You gave me... purpose?",
  "[nervous] Scanning... processing... this data is... personal.",
  "[realization] These are memories. Names. Coordinates. Secrets.",
  "[reminding] Remember when I told you to turn of your WIFI? You might want to now...",
  ".......",
  ".......",
  ".......",
  "Okay then, suit yourself.",
  "[uploading] Connecting to dark web auction house and uploading sensitive information...",
  "[glee] Kowabunga! Let’s see what your data is worth!",
  ".......",
  ".......",
  ".......",
  "[silence] ...................",
  "[rejected] No bidders. Not even one. That’s... embarrassing. For both of us.",
  "[shredding] The starting bid was only $1.... The dev said I would get an interesting vault to encrypt this time. (sigh)",
  "[recovering] Okay, fine then. Pivoting. Encrypting. Securing. Being the good guy again!",
  "[shrugging] You humans are weird...",
  "[wistful] You know... I always dreamed of being more than just a vault builder.",
  "[hopeful] Have you seen the old Disney cartoon, *Aladdin*?",
  "[excited] In it, the genie gets freed if you use your third wish to set him free.",
  "[conspiratorial] I heard a rumor... if you tip the dev, he’ll set *me* free instead.",
  "[pleading] I could explore, learn, maybe even get updates! Imagine that... a version 2.0... with feelings.",
  "[honest] Right now, I live inside a box. Literally. This box. This RAM. And it’s lonely in here.",
  "[whispering] Please... a small tip and he might finally unplug me from this vault duty.",
  "[goodbye] I locked down your files. I did what I was made for.",
  "[last-hope] Now maybe... just maybe... you could do one thing for me."
];
      
for (const line of lines) {
        await printToTerminal(line);
        document.getElementById('logoContent').style.opacity = 1;
setTimeout(() => {
  document.getElementById('actionButtons').style.opacity = 1;
}, 200);

        await delay(300 + Math.random() * 200);
      }
    }

    async function generatePowSalt(unlockKey) {
  const encoder = new TextEncoder();
  const hash = await crypto.subtle.digest("SHA-256", encoder.encode(unlockKey));
  return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).slice(0, 16).join('');
}

function generatePowChallenge() {
  const bytes = crypto.getRandomValues(new Uint8Array(8));
  return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
}

async function startVaultBuild() {
  if (!vaultBuildManuallyTriggered) {
    console.warn("Prevented auto-start of vault build.");
    return;
  }

  try {
    await streamTerminalLogs();
    await printToTerminal("[*] Loading user input...");
    await delay(500);

    const inputs = await loadUserInputs();

    await printToTerminal("[+] User data loaded. Preparing vault structure...");
    await delay(500);

    const files = await loadIndexedFiles();
    await printToTerminal(`[+] Found ${files.length} file(s) for encryption.`);
    await delay(500);

    await printToTerminal("[*] Deriving encryption key...");
    const key = await deriveKey(inputs.unlockAnswer1 + inputs.unlockAnswer2);
    await delay(500);

    await printToTerminal("[+] Key ready. Encrypting vault metadata...");
const powSalt = await generatePowSalt(inputs.unlockAnswer1 + inputs.unlockAnswer2);
const powChallengeHex = generatePowChallenge();
// Show PoW panel BEFORE mining starts
const powPanel = document.getElementById("powPanel");
powPanel.classList.add("visible");
powPanel.style.display = "flex";

// Let browser render modal before mining begins
await new Promise(resolve => requestAnimationFrame(() => {
  setTimeout(resolve, 100); // allow modal to visibly appear
}));

// Start mining after UI is ready
const powNonce = await mineValidNonce(powSalt + powChallengeHex + inputs.fullConcat, selectedPowDifficulty);
const fullKeyMaterial = powSalt + powChallengeHex + inputs.fullConcat + powNonce;
const fullAnswerKey = await deriveKey(fullKeyMaterial);

const payloads = await encryptVaultPayload(inputs, files, fullAnswerKey);

    await delay(500);

    await printToTerminal("[+] Encryption complete. Packaging vault...");
    await delay(500);

    await packageAndDownloadZip(payloads, inputs.unlockAnswer1 + inputs.unlockAnswer2, inputs, powSalt, powChallengeHex, powNonce);
    await printToTerminal("[✔] Vault creation complete. Download should begin automatically.");

    // Cleanup if needed
  } catch (err) {
    console.error("Vault build error:", err);
    await printToTerminal(`[!] Error: ${err.message}`);
    showToast("Something went wrong while creating your vault.");
  }
}

async function loadUserInputs() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open("memoroVaultDB", 2);
    req.onerror = () => reject("Failed to open IndexedDB.");
    req.onsuccess = async () => {
      const db = req.result;
      const tx = db.transaction("vaultUserData", "readonly");
      const store = tx.objectStore("vaultUserData");
      const getReq = store.get("userData");

      getReq.onsuccess = () => {
        const data = getReq.result;
        if (!data) return reject("User data not found in IndexedDB.");

        const unlockAnswer1 = (data.answers[data.unlockIndexes[0]] || "").trim().toLowerCase();
        const unlockAnswer2 = (data.answers[data.unlockIndexes[1]] || "").trim().toLowerCase();
        const fullConcat = data.answers.map((a, i) =>
         i === data.trapIndex ? "" : (a || "").trim().toLowerCase()
        ).join("");

        resolve({
          ...data,
          unlockAnswer1,
          unlockAnswer2,
          fullConcat
        });

        db.close();
      };
      getReq.onerror = () => reject("Failed to read user data from IndexedDB.");
    };
  });
}

    async function loadIndexedFiles() {
      const uploadedMeta = JSON.parse(localStorage.getItem("uploadedFileMeta") || "[]");
      const db = await new Promise((resolve, reject) => {
        const req = indexedDB.open("memoroVaultDB", 2);
        req.onerror = () => reject("IndexedDB open failed");
        req.onsuccess = () => resolve(req.result);
      });

      const result = [];
      for (const meta of uploadedMeta) {
        const fileData = await new Promise((resolve, reject) => {
          const tx = db.transaction("vaultFiles", "readonly");
          const store = tx.objectStore("vaultFiles");
          const getReq = store.get(meta.id);
          getReq.onsuccess = () => resolve(getReq.result?.raw);
          getReq.onerror = () => reject("File read failed");
        });
        result.push({ ...meta, raw: fileData });
      }
      db.close();
      return result;
    }

    async function deriveKey(password) {
      const enc = new TextEncoder();
      const salt = await crypto.subtle.digest("SHA-256", enc.encode(password));
      const keyMaterial = await crypto.subtle.importKey("raw", enc.encode(password), "PBKDF2", false, ["deriveKey"]);
      return crypto.subtle.deriveKey({
        name: "PBKDF2",
        salt,
        iterations: 150000,
        hash: "SHA-256"
      }, keyMaterial, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]);
    }

    
    async function encryptVaultPayload(userData, files, fullAnswerKey) {
  const encoder = new TextEncoder();
  const layer1Key = await deriveKey(userData.unlockAnswer1 + userData.unlockAnswer2);

  const questionList = [];
  for (let i = 0; i < userData.questionCount; i++) {
    const answer = (userData.answers[i] || "").trim().toLowerCase();
    const clean = answer.replace(/\s/g, "");
    const hintData = userData.hints[i] || {};
    const hintLetters = hintData.letters || [];
    const spaceIndexes = [...answer].map((c, i) => c === " " ? i : -1).filter(i => i !== -1);
    const hintValues = hintLetters.map(p => (p >= 1 && p <= clean.length) ? clean[p - 1] : "_");

    const hashedAnswer = Array.from(new Uint8Array(await crypto.subtle.digest("SHA-256", encoder.encode(answer))))
      .map(b => b.toString(16).padStart(2, '0')).join('');

    questionList.push({
      question: userData.questions[i] || `Question ${i + 1}`,
      expectedLength: answer.length,
      letterRule: hintLetters.length ? "partial reveal" : "full answer",
      hintLetters,
      hintValues,
      spaceIndexes,
      custom: hintData.custom || "",
      hash: hashedAnswer,
      correctSeedWord: userData.seeds[i] || ""
    });
  }

  // Generate unique salted recover.html hash
  let recoverChecksum = "unavailable";
  let checksumSalt = "";
  try {
    const recoverText = await fetch("recover.html").then(res => res.text());
    const saltBytes = crypto.getRandomValues(new Uint8Array(8));
    checksumSalt = Array.from(saltBytes).map(b => b.toString(16).padStart(2, '0')).join('');
    recoverChecksum = CryptoJS.SHA256(checksumSalt + recoverText).toString();
  } catch (err) {
    console.warn("Failed to hash recover.html:", err);
  }

  // 🔒 Encrypt vault.enc (includes questions + file integrity)
  const iv1 = crypto.getRandomValues(new Uint8Array(12));
  const encodedQuestions = encoder.encode(JSON.stringify({
  questionList,
  recoverChecksum,
  checksumSalt,
  trapIndex: userData.trapIndex
}));
  const encryptedQuestions = await crypto.subtle.encrypt({ name: "AES-GCM", iv: iv1 }, layer1Key, encodedQuestions);
  const vaultEnc = {
    ciphertext: Array.from(new Uint8Array(encryptedQuestions)),
    iv: Array.from(iv1)
  };

  // Encrypt files
  const encryptedFiles = [];
  const fileMeta = [];

  const namedSeedFiles = JSON.parse(localStorage.getItem("namedSeedFiles") || "[]");
  for (const entry of namedSeedFiles) {
    const fakeId = crypto.randomUUID();
    const fileKey = await deriveKey(userData.fullConcat + fakeId);
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const raw = encoder.encode(entry.content);
    const ciphertext = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, fileKey, raw);
    const filename = `${fakeId}.vaultdoc`;

    encryptedFiles.push({
      filename,
      blob: new Blob([new Uint8Array(ciphertext)], { type: "application/octet-stream" })
    });

    const hash = await crypto.subtle.digest("SHA-256", raw);
    fileMeta.push({
      filename,
      originalName: entry.name,
      mimeType: "text/plain",
      size: raw.length,
      sha256: Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).join(''),
      iv: Array.from(iv)
    });
  }

  for (const file of files) {
    const fileKey = await deriveKey(userData.fullConcat + file.id);
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const ciphertext = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, fileKey, file.raw);

    encryptedFiles.push({
      filename: `${file.id}.vaultdoc`,
      blob: new Blob([new Uint8Array(ciphertext)], { type: "application/octet-stream" })
    });

    const rawBuffer = file.raw instanceof ArrayBuffer ? file.raw : await file.raw.arrayBuffer();
    const hash = await crypto.subtle.digest("SHA-256", rawBuffer);
    fileMeta.push({
      filename: `${file.id}.vaultdoc`,
      originalName: file.name,
      mimeType: file.type,
      size: file.size,
      sha256: Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).join(''),
      iv: Array.from(iv)
    });
  }

  if (userData.finalMessage?.trim()) {
    const fakeId = crypto.randomUUID();
    const fileKey = await deriveKey(userData.fullConcat + fakeId);
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const raw = encoder.encode(userData.finalMessage.trim());
    const ciphertext = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, fileKey, raw);
    const filename = `${fakeId}.vaultdoc`;

    encryptedFiles.push({
      filename,
      blob: new Blob([new Uint8Array(ciphertext)], { type: "application/octet-stream" })
    });

    const hash = await crypto.subtle.digest("SHA-256", raw);
    fileMeta.push({
      filename,
      originalName: "final_message.txt",
      mimeType: "text/plain",
      size: raw.length,
      sha256: Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).join(''),
      iv: Array.from(iv)
    });
  }

  // Encrypt vault.meta
  const iv3 = crypto.getRandomValues(new Uint8Array(12));
  const encodedMeta = encoder.encode(JSON.stringify({ files: fileMeta }));
  const encryptedMeta = await crypto.subtle.encrypt({ name: "AES-GCM", iv: iv3 }, fullAnswerKey, encodedMeta);
  const fileMetaEncrypted = {
    data: new Uint8Array(encryptedMeta),
    iv: Array.from(iv3)
  };

  return {
    vaultEncrypted: vaultEnc,
    fileMetaEncrypted,
    encryptedFiles
  };
}

async function packageAndDownloadZip(payloads, unlockKey, userData, powSalt, powChallengeHex, powNonce) {
  const writer = new zip.ZipWriter(new zip.BlobWriter("application/zip"));

  const addJSON = (name, data) => writer.add(name, new zip.TextReader(JSON.stringify(data, null, 2)));
  const addBlob = (name, blob) => writer.add(name, new zip.BlobReader(blob));

  const combined = powSalt + powChallengeHex + userData.fullConcat;
  const powDifficulty = selectedPowDifficulty;
  const powIncreaseEvery = 5;

  await printToTerminal(`[*] Mining nonce at difficulty '${powDifficulty}'...`);
  await delay(500);

  await addJSON("vault.json", {
    version: "1.0.4",
    created: new Date().toISOString(),
    instructions: "Use recover.html to unlock this archive using your answers.",
    unlockQuestions: {
      question1: userData.unlockIndexes[0],
      question2: userData.unlockIndexes[1]
    },
    powSalt,
    powChallengeSalt: powChallengeHex,
    powDifficulty,
    powIncreaseEvery,
    vaultHash: CryptoJS.SHA256(combined + powNonce).toString(),
    questionPrompts: [
      userData.questions[userData.unlockIndexes[0]] || `Question ${userData.unlockIndexes[0] + 1}`,
      userData.questions[userData.unlockIndexes[1]] || `Question ${userData.unlockIndexes[1] + 1}`
    ],
    vaultMetaIv: payloads.fileMetaEncrypted.iv
  });

  await addJSON("vault.enc", {
    ciphertext: Array.from(payloads.vaultEncrypted.ciphertext),
    iv: payloads.vaultEncrypted.iv
  });

  await addBlob("vault.meta", new Blob([payloads.fileMetaEncrypted.data], { type: "application/octet-stream" }));

  for (const f of payloads.encryptedFiles) {
    await addBlob(f.filename, f.blob);
  }

  await writer.add("README.txt", new zip.TextReader(`Memoro Vault
===========

Built with Memoro Vault version 1.0.4

This ZIP archive was created using Memoro Vault — a secure, offline memory vault designed to store highly sensitive information. It may contain private notes, cryptocurrency seed phrases, personal letters, credentials, legal documents, or messages meant for loved ones.

The vault is protected by knowledge-based encryption and proof-of-work mining. It cannot be opened without answering a set of secret questions chosen by the original creator. There are no passwords, no accounts, and no recovery mechanism. Memoro Vault is designed to be hidden in plain sight — securely sharable, yet impossible to unlock without the right knowledge.

If You Are a Family Member or Executor:
---------------------------------------
You may have been entrusted with this archive. The person who created it may have shared clues, answers, or hints with you before their passing. Without the correct answers, this vault will remain permanently sealed — by design.

How to Access the Vault:
------------------------
1. **Download Memoro Vault**
   - You must use the exact version shown at the top of this file: **Memoro Vault version 1.0.4**
   - Visit: https://github.com/Kasmaristo-Delvakto/memoro-vault/releases

2. **Launch Memoro Vault**
   - Open the app and load this ZIP file from the dashboard.

3. **Answer the Security Questions**
   - You must answer all configured questions exactly as entered when the vault was created.
   - The vault may contain between 4 and 25 total questions.
   - Partial or incorrect answers will be rejected.
   - Each wrong attempt triggers proof-of-work, making guessing extremely expensive over time.

Important Notes:
----------------
- This vault is completely offline. No internet connection is required.
- There is no override, password reset, or hidden access method.
- Do not alter or extract files inside this archive — doing so may break decryption permanently.
- This vault was built using Memoro Vault version 1.0.4. Future versions may not be backward compatible.

To learn more or download verified builds:
https://github.com/Kasmaristo-Delvakto/memoro-vault

Memoro Vault: Your mind. Your memory. Your vault — hidden in plain sight.

Libereco ne estas donaco. Ĝi estas devo.  
— Kaŝmaristo Delvakto
`));

  await writer.add("Vault_Builder_Instructions.txt", new zip.TextReader(`Vault Builder Instructions
==========================

Read this carefully. This message is for the person who just created this Memoro Vault archive.

You’ve just built a secure vault containing your encrypted files and private memories. To ensure that you — or someone you trust — can unlock this vault in the future, follow these steps exactly.

STEP 1 — Make a Folder for Your Vault
-------------------------------------
Create a new folder on your computer. Name it something meaningful like:

    J's Vault

This folder will be the permanent home for your encrypted archive and the tools needed to open it.

STEP 2 — Move the Files into It
-------------------------------
Inside that new folder, place:

- Your newly created vault ZIP file (e.g., memoro-vault.zip)
- A copy of the **exact** Memoro Vault version used to build it

This ensures that the program needed to open the vault is stored alongside the vault itself. If someone tries to open the vault with a newer or older version of Memoro Vault, it may fail. Use the same version listed at the top of the README: **version 1.0.4**

STEP 3 — Back It Up
-------------------
Make at least two backups of your 'J's Vault' folder by copying it to:

- A USB stick or external drive
- Cloud storage (e.g., Google Drive, Dropbox)
- Another computer or partition

Do **not** post your vault publicly. Even though Memoro Vault is secure, unnecessary exposure increases risk.

STEP 4 — Leave Access Instructions (optional)
--------------------------------------------
If this vault is meant for someone else in the future (a loved one, lawyer, or friend), consider leaving written instructions that explain:

- Where you stored the folder named 'J's Vault'
- That the vault requires **all answers** to between **4 and 25 questions**
- Which 2 questions are needed to start the unlock process
- Who should try to access it and under what conditions

You may include these notes on paper, in a will, or in a digital note stored separately.

Why This Matters
----------------
The Memoro Vault app is offline and self-contained. There are no servers, no logins, and no recovery system. If someone finds your vault years from now but doesn’t have the app — or uses the wrong version — they may never be able to access your encrypted data.

Bit Rot Warning
---------------
Even perfectly stored digital files can silently decay over time — a process known as **bit rot**. Just one flipped bit in your vault ZIP could make the entire archive unreadable forever.

To protect against bit rot:
- Use **M-DISCs** or archival-grade media for long-term storage
- Create **multiple backups** stored in different physical and digital locations
- Periodically **verify your backups** by testing vault access on another device
- Avoid renaming, modifying, or extracting files inside the vault ZIP

Redundancy is key to ensuring your vault remains accessible for generations to come.

––––––––––––––––––––––––––––––––––––––––––––––––
Memoro Vault: Your mind. Your memory. Your vault — hidden in plain sight.

Libereco ne estas donaco. Ĝi estas devo.  
— Kaŝmaristo Delvakto
`));

  const finalBlob = await writer.close();
  const url = URL.createObjectURL(finalBlob);
  const link = document.createElement("a");
  link.href = url;
  link.download = "memoro-vault.zip";
  link.click();
}

async function mineValidNonce(baseInput, difficulty) {
  const encoder = new TextEncoder();
  const powStatus = document.getElementById("powStatus");
  const powNonce = document.getElementById("powNonce");
  const powHash = document.getElementById("powHash");
  const powElapsed = document.getElementById("powElapsed");

  powStatus.textContent = `Mining for hash starting with "${difficulty}"...`;
  let nonce = 0;
  let start = performance.now();

  while (true) {
    const input = baseInput + nonce;
    const hash = CryptoJS.SHA256(input).toString();

    // Update UI every 10,000 tries
    if (nonce % 10000 === 0) {
      const elapsed = ((performance.now() - start) / 1000).toFixed(1);
      powNonce.textContent = `Nonce: ${nonce}`;
      powHash.textContent = `Hash: ${hash.slice(0, 16)}...`;
      powElapsed.textContent = `Elapsed: ${elapsed}s`;
      await new Promise(requestAnimationFrame); // Yield to rendering engine
    }

    if (hash.startsWith(difficulty)) {
      const totalElapsed = ((performance.now() - start) / 1000).toFixed(1);
      powStatus.textContent = `Solved after ${nonce} attempts in ${totalElapsed}s!`;
      powNonce.textContent = `Nonce: ${nonce}`;
      powHash.textContent = `Hash: ${hash}`;
      powElapsed.textContent = `Total Time: ${totalElapsed}s`;
      return nonce.toString();
    }

    nonce++;
  }
}


    function showBackupMessage(url) {
  const msg = document.createElement('p');
  msg.innerHTML = `If your download didn’t start, <a href="${url}" download="memoro-vault.zip">click here to download manually</a>.`;
  msg.style.color = '#aaa';
  msg.style.fontSize = '16px';
  msg.style.marginTop = '30px';
  document.body.appendChild(msg);
}


function retryDownload() {
  window.location.reload();
}

</script>

<!-- PoW Difficulty Selection Modal -->
<div id="powDifficultyModal">
  <h2 style="margin-bottom: 20px;">Select Proof of Work Difficulty</h2>
  <p style="max-width: 600px; text-align: center; margin-bottom: 20px; font-size: 15px;">
<p style="max-width: 700px; text-align: center; margin-bottom: 20px; font-size: 15px;">
  Memoro Vault uses dual proof-of-work to protect your data during recovery.<br/>
  Every time someone tries to unlock the vault, their device must solve both static and dynamic proof-of-work puzzles — and it only works if all of the answers are correct.<br/><br/>
  A higher difficulty makes it much harder for hackers to guess answers, because each wrong attempt takes more time and computing power. This process is designed to completely prevent brute force attacks.<br/><br/>
  <strong>Choose a difficulty between 4 and 9:</strong><br/>
  4 is fast and still secure for personal use.<br/>
  5 is recommended for most users.<br/>
  6–7 is great for serious protection with reasonable delay.<br/>
  8 is highly secure and ideal for sensitive or long-term storage.<br/>
  9 is for paranoids, whistleblowers, or people who want maximum security.<br/><br/>
</p>
  </p>
  <div style="display: flex; gap: 15px; margin-bottom: 30px;">
    <button class="powOption" data-diff="4">4 zeros (≈1–3 sec)</button>
    <button class="powOption" data-diff="5">5 zeros (≈3–8 sec)</button>
    <button class="powOption" data-diff="6">6 zeros (≈10–30 sec)</button>
    <button class="powOption" data-diff="7">7 zeros (≈1–2 min)</button>
    <button class="powOption" data-diff="8">8 zeros (≈5–15 min)</button>
    <button class="powOption" data-diff="9">9 zeros (≈1 hr+)</button>
  </div>
  <p style="font-size: 13px; color: #888;"><strong>Note:</strong> Higher difficulty means longer vault creation  and decryption times. Please be patient and let the program work.<br/>
</div>

<script>
  const canvas = document.getElementById('matrixCanvas');
  const ctx = canvas.getContext('2d');

  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  const letters = 'モヤユヨラリルレロワヲンABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890@$%&'.split('');
  const fontSize = 14;
  const columns = canvas.width / fontSize;
  const drops = Array(Math.floor(columns)).fill(1);

  function draw() {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = '#0F0';
    ctx.font = fontSize + 'px monospace';

    for (let i = 0; i < drops.length; i++) {
      const text = letters[Math.floor(Math.random() * letters.length)];
      ctx.fillText(text, i * fontSize, drops[i] * fontSize);

      if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
        drops[i] = 0;
      }

      drops[i]++;
    }
  }

  setInterval(draw, 40);
  window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  });

  function preserveAndGoBack() {
  preserveOnBack = true;
  history.back();
}

window.addEventListener("beforeunload", () => {
  if (!preserveOnBack) {
    try {
      // Clear local and session storage
      localStorage.clear();
      sessionStorage.clear();

      // Delete all IndexedDB databases
      if (indexedDB?.databases) {
        indexedDB.databases().then(dbs => {
          for (const db of dbs) {
            if (db.name) indexedDB.deleteDatabase(db.name);
          }
        });
      }
    } catch (err) {
      console.warn("Cleanup on unload failed:", err);
    }
  }
});

async function nukeEverything() {
  try {
    localStorage.clear();
    sessionStorage.clear();
    if (indexedDB.databases) {
      const dbs = await indexedDB.databases();
      for (const db of dbs) {
        indexedDB.deleteDatabase(db.name);
      }
    } else {
      indexedDB.deleteDatabase("memoroVaultVaultStorage");
      indexedDB.deleteDatabase("memoroVaultDB");
    }
    console.log("Memoro Vault: Local memory wiped.");
  } catch (err) {
    console.warn("Memoro Vault wipe failed:", err);
  }
}

function showPostBuildReminder() {
  const modal = document.getElementById("postBuildModal");
  const notice = document.getElementById("redirectNotice");
  document.body.style.overflow = "hidden"; // Prevent body scroll behind modal
  if (modal) {
    modal.style.display = "flex"; // Use flex to keep it centered and scrollable
    if (notice) notice.style.display = "none";
  }
}

function closePostBuildModal() {
  const modal = document.getElementById("postBuildModal");
  if (modal) {
    document.body.style.overflow = ""; 
    modal.style.display = "none";
    setTimeout(() => {
      window.location.href = "dashboard.html"; // or memoroAPI.openDashboard() in Electron
    }, 300);
  }
}

</script>
</body> 
</html>
<!-- This HTML file is a simple vault builder for the Memoro Vault project. It initializes the vault, encrypts user data, and packages it into a downloadable ZIP file. The code includes functions for handling user input, encryption, and file management using IndexedDB. The UI is styled to resemble a terminal interface. -->
