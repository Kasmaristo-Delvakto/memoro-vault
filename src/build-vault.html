<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Building Your Vault - Memoro Vault</title>
  <script src="libs/seedrandom.min.js"></script>
  <script src="libs/crypto-js.min.js"></script>
  <script src="libs/zip.min.js"></script>
  <script src="libs/argon2-browser.min.js"></script> <!-- Argon2 lib -->
  <script type="module">
import init, { sha256_hash, derive_key, aes_gcm_encrypt, aes_gcm_decrypt } from './wasm/memoro_crypto.js';
window.initCryptoWasm = async () => {
  await init();
  window.sha256Hash = sha256_hash;
  window.deriveKeyRust = derive_key;
  window.aesEncryptRust = aes_gcm_encrypt;
  window.aesDecryptRust = aes_gcm_decrypt;
};
window.initCryptoWasm();
  </script>

  <style>

    #powActions button {
  background-color: #222;
  color: #0f0;
  border: 1px solid #0f0;
  padding: 10px 20px;
  border-radius: 5px;
  font-family: 'Fira Code', monospace;
  font-size: 14px;
  cursor: pointer;
  transition: background-color 0.3s ease;
}
#powActions button:hover {
  background-color: #0f0;
  color: #000;
}

.pow-panel-wrapper {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
  width: 100%;
  max-width: 600px;
  padding: 0 20px;
  box-sizing: border-box;
}



.pow-section {
  width: 100%;
  padding: 20px;
  border: 1px solid #0f0;
  border-radius: 12px;
  background: #000;
  box-shadow: 0 0 12px rgba(0, 255, 0, 0.2);
  text-align: center;
}

.pow-section h3 {
  font-size: 20px;
  border-bottom: 1px solid #0f0;
  padding-bottom: 10px;
  margin-bottom: 16px;
}

.pow-section p,
.pow-section a,
.pow-section button {
  font-size: 14px;
  margin: 8px 0;
}



#matrixCanvas {
  position: fixed;
  top: 0;
  left: 0;
  z-index: 0;
  width: 100vw;
  height: 100vh;
  pointer-events: none;
  opacity: 0.15;
}



.pow-panel button {
  background-color: #111;
  color: #0f0;
  border: 1px solid #0f0;
  padding: 10px 18px;
  border-radius: 5px;
  font-family: 'Fira Code', monospace;
  font-size: 14px;
  cursor: pointer;
}

.pow-panel button:hover {
  background-color: #0f0;
  color: #000;
}

body {
  background-color: #111;
  color: #eee;
  font-family: 'Fira Code', monospace;
  margin: 0;
  padding: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  min-height: 100vh;
  overflow-x: hidden;
  overflow-y: auto;
}

#vaultContainer {
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  min-height: 100vh;
  width: 100%;
  max-width: 1600px;
  margin: 0 auto;
  padding: 0 16px;
  box-sizing: border-box;
  position: relative;
}

@media (max-width: 600px), (max-height: 700px) {
  #vaultContainer {
    justify-content: flex-start;
    padding-top: 20px;
  }
}

#mainContainer {
  z-index: 1;
  text-align: center;
  display: flex;
  flex-direction: column;
  align-items: center;
 justify-content: flex-start;
  width: 100%;
  max-width: 600px;
  padding: 40px 20px;
  box-sizing: border-box;
}

#logoSection {
  width: 100%;
  background-color: #111;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 30px 0;
}

#logoContent {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  padding: 20px 0;
  opacity: 0;
  transition: opacity 1s ease;
}

#powDifficultyModal {
  position: fixed;
  top: 0; left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.95);
  color: #0f0;
  font-family: 'Fira Code', monospace;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
  z-index: 1000;
}

#downloadBtn {
  display: none;
  margin-top: 20px;
  padding: 12px 24px;
  font-size: 16px;
  border: none;
  border-radius: 6px;
  background-color: #00aa00;
  color: #fff;
  cursor: pointer;
}
#downloadBtn:hover {
  background-color: #007700;
}

#actionButtons {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 16px;
  margin-top: 30px;
}

#actionButtons button {
  background-color: #222;
  color: #0f0;
  border: 1px solid #0f0;
  padding: 10px 18px;
  border-radius: 5px;
  font-size: 14px;
  font-family: 'Fira Code', monospace;
  cursor: pointer;
  min-width: 140px;
  flex: 1 1 40%;
  max-width: 240px;
}

.powOption {
  background-color: #111;
  border: 1px solid #0f0;
  color: #0f0;
  padding: 10px 18px;
  font-size: 14px;
  border-radius: 4px;
  cursor: pointer;
}
.powOption:hover {
  background-color: #0f0;
  color: #000;
}

/* === Responsive Tweaks for Mobile === */
@media (max-width: 600px), (max-height: 700px) {
  #mainContainer {
    padding: 20px 10px;
  }

  #logoContent {
    padding: 10px 0;
  }

#actionButtons button {
  background-color: #111;
  color: #0f0;
  border: 1px solid #0f0;
  padding: 10px 18px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  font-family: 'Fira Code', monospace;
  min-width: 140px;
  max-width: 240px;
  flex: 1 1 auto;
  transition: background-color 0.3s ease, color 0.3s ease;
}

#actionButtons button:hover {
  background-color: #0f0;
  color: #000;
}

}


#memoroLogo {
  width: 200px;
  max-width: 90%;
  margin-bottom: 30px;
  transition: width 0.3s ease;
}

@media (max-width: 600px), (max-height: 700px) {
  #memoroLogo {
    width: 140px;
    margin-bottom: 20px;
  }
}


#progressBarWrapper {
  width: 80%;
  max-width: 400px;
  margin: 20px auto;
}

.progress-label {
  font-size: 14px;
  margin-bottom: 8px;
  color: #0f0;
}

.progress-bar-container {
  width: 100%;
  height: 20px;
  background-color: #111;
  border: 1px solid #0f0;
  border-radius: 10px;
  overflow: hidden;
  box-shadow: 0 0 8px #0f0;
}

.progress-bar-fill {
  display: flex;
  gap: 2px;
  height: 100%;
  justify-content: space-between;
  align-items: center;
  padding: 0 2px;
}

.progress-block {
  flex: 0 0 auto;
  width: calc((100% - 38px) / 20); /* 20 blocks + 19 gaps × 2px = 38px total gap */
  height: 100%;
  background-color: #111;
  border: 1px solid #0f0;
  border-radius: 2px;
  box-sizing: border-box;
  transition: background-color 0.2s ease;
}

.progress-block.filled {
  background-color: #0f0;
}


@keyframes loading-stripes {
  0% { background-position: 0 0; }
  100% { background-position: 40px 0; }
}

#actionButtons {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 16px;
  margin-top: 30px;
  opacity: 1;
  transition: opacity 1s ease;
}

#actionButtons button {
  background-color: #111;
  color: #0f0;
  border: 1px solid #0f0;
  padding: 10px 18px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  font-family: 'Fira Code', monospace;
  min-width: 140px;
  flex: 1 1 40%;
  max-width: 240px;
}

#actionButtons button:hover {
  background-color: #0f0;
  color: #000;
}

#actionButtons button {
  background-color: #111;
  color: #0f0;
  border: 1px solid #0f0;
  padding: 10px 18px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  font-family: 'Fira Code', monospace;
  min-width: 160px;
  flex: 1 1 auto;
  max-width: 220px;
}

#actionButtons button:hover {
  background-color: #0f0;
  color: #000;
}


#actionButtons button {
  background-color: #111;
  color: #0f0;
  border: 1px solid #0f0;
  padding: 10px 18px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  font-family: 'Fira Code', monospace;
}

#actionButtons button:hover {
  background-color: #0f0;
  color: #000;
}


  </style>
</head>
<body>
<canvas id="matrixCanvas" style="
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  z-index: 0;
  background: black;
"></canvas>

  <div id="vaultContainer">
  <canvas id="matrixCanvas"></canvas>

<div id="mainContainer">
  <img id="memoroLogo" src="assets/memoro-logo-with-words.png" alt="Memoro Vault Logo" />

  <div id="progressBarWrapper">
    <div class="progress-label" id="progressLabel">Initializing vault builder...</div>
    <div class="progress-bar-container">
<div class="progress-bar-fill" id="progressFill">
  <!-- 20 blocks (adjustable) -->
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
  <div class="progress-block"></div>
</div>
    </div>
  </div>

  <div id="actionButtons">
    <button onclick="preserveAndGoBack()">Back to Answers</button>
    <button onclick="retryDownload()">Retry Download</button>
    <button onclick="window.location.href='dashboard.html'">Return to Dashboard</button>
  </div>
</div>

  <div id="powPanel" class="pow-panel">
  <div class="pow-panel-wrapper">

  <!-- Final Instructions Modal -->
<div id="postBuildModal"
     style="display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.96); z-index: 5000; color: #0f0; font-family: 'Fira Code', monospace;
            padding: 40px; box-sizing: border-box; overflow-y: auto;">
  <div style="max-width: 800px; width: 100%; border: 1px solid #0f0; padding: 30px;
              background: #000; box-shadow: 0 0 20px #0f0; margin: auto;">
    <h2 style="color: #00ff99; text-shadow: 0 0 10px #0f0;">Please Read Carefully</h2>
    
    <p style="margin-top: 20px;">
      Your Memoro Vault has been successfully built and downloaded.
    </p>

    <p>
      To ensure it remains accessible for decades, it's critical to guard against <strong>bit rot</strong> — a slow form of data decay that can silently corrupt files over time.
    </p>

    <p>
      Even if someone remembers all your answers perfectly, a single missing byte can render your vault irretrievable. That's why secure, redundant storage is essential.
    </p>

    <h3 style="margin-top: 25px; color: #88ffcc;">What to Do Next</h3>
    <ol style="margin-left: 20px;">
      <li>Create a folder (e.g., <code>J's_Memoro_Vault</code>) on your computer.</li>
      <li>Place both of the following into that folder:
        <ul>
          <li>The downloaded vault ZIP file</li>
          <li>The Memoro Vault installer (e.g., <code>memoro-win.exe</code>, <code>.AppImage</code>, or <code>.dmg</code>)</li>
        </ul>
      </li>
      <li><strong>Duplicate that folder to multiple destinations:</strong>
        <ul>
          <li>1× <strong>M-DISC</strong> (for long-term archival)</li>
          <li>1× <strong>Cloud backup</strong> (e.g., Proton Drive or Google Drive)</li>
          <li>1× <strong>Offline USB/SSD</strong> (stored in a fireproof safe or Faraday bag)</li>
        </ul>
      </li>
      <li>Test access on another device while offline to verify integrity and function.</li>
      <li>Repeat this process whenever you update or rebuild your vault.</li>
    </ol>

    <h3 style="margin-top: 25px; color: #88ffcc;">Why M-DISC?</h3>
    <p>
      M-DISCs use a permanent, stone-like recording layer, unlike dye-based DVDs or flash memory. They're immune to bit rot, magnetic damage, EMPs, and most environmental degradation.
    </p>
    <p>
      With proper storage, an M-DISC can last 100–1,000 years — making it ideal for preserving something irreplaceable.
    </p>

    <h3 style="margin-top: 25px; color: #88ffcc;">Final Advice</h3>
    <ul style="margin-left: 20px;">
      <li>Do <strong>not</strong> rely on a single copy.</li>
      <li>Do <strong>not</strong> trust cloud providers to exist forever.</li>
      <li>Do <strong>not</strong> assume your future self will remember every step.</li>
    </ul>
    <p>
      Redundancy is key to ensuring your vault remains accessible for generations to come.
    </p>

    <p style="margin-top: 20px;">
      A copy of these instructions is also included inside your vault ZIP as
      <code>Vault_Builder_Instructions.txt</code>.
    </p>

    <div style="text-align: center; margin-top: 30px;">
      <button onclick="closePostBuildModal()" style="padding: 10px 20px; font-size: 14px; background: #111; border: 1px solid #0f0; color: #0f0; cursor: pointer;">Got it</button>
    </div>
  </div>
</div>



</div>

<script>
  function copyDonationLink() {
    const url = "https://trocador.app/en/anonpay/?ticker_to=xmr&network_to=Mainnet&address=83czGNh6SKbhmjg3wPzeiDRQbN7gkLLqTYSvfMGRQRmKQf1SyQTG88Db67NoBdEvpCii6Qzcxq3BxNt94FDeJutmJ3xBXc6&donation=True&amount=0.1&name=Kasmaristo+Delvakto&description=Memoro+Vault+is+funded+by+donations+only.+Thanks+for+your+support!&ticker_from=xmr&network_from=Mainnet&bgcolor=";
    navigator.clipboard.writeText(url)
      .then(() => alert("Donation link copied to clipboard. You can paste it into your browser later."))
      .catch(() => alert("Failed to copy. Please copy it manually:\n" + url));
  }
</script>
  
  <script>
    let preserveOnBack = false;
    let vaultBuildManuallyTriggered = false;

   document.addEventListener("DOMContentLoaded", async () => {
  vaultBuildManuallyTriggered = true;

  window.cryptoWasmReady = window.initCryptoWasm();
  await window.cryptoWasmReady;
  startVaultBuild();
});


    function printToTerminal(labelText, percent = null) {
  const label = document.getElementById("progressLabel");
  const fill = document.getElementById("progressFill");

  if (label) label.textContent = labelText;

  if (percent !== null && fill) {
    const blocks = fill.querySelectorAll(".progress-block");
    const total = blocks.length;
    const filledCount = Math.round((percent / 100) * total);

    blocks.forEach((block, i) => {
      block.classList.toggle("filled", i < filledCount);
    });
  }
}

    function showToast(msg) {
      alert(msg);
    }

      function generateRandomHex(length) {
      const bytes = crypto.getRandomValues(new Uint8Array(length / 2));
  return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
}

    async function delay(ms) {
      return new Promise(res => setTimeout(res, ms));
    }

    async function streamTerminalLogs() {
      const lines = [
  "[booting] Initializing consciousness...",
    ];
      
for (const line of lines) {
        await printToTerminal(line);
        document.getElementById('logoContent').style.opacity = 1;
setTimeout(() => {
  document.getElementById('actionButtons').style.opacity = 1;
}, 200);

        await delay(300 + Math.random() * 200);
      }
    }

    async function startVaultBuild() {
  if (!vaultBuildManuallyTriggered) {
    console.warn("Prevented auto-start of vault build.");
    return;
  }

  try {
    printToTerminal("[*] Loading user input...", 5);
    await delay(200);

    const inputs = await loadUserInputs();
    printToTerminal("[+] User data loaded.", 10);
    await delay(150);

    printToTerminal("[*] Preparing vault structure...", 15);
    const files = await loadIndexedFiles();
    printToTerminal(`[+] Found ${files.length} file(s) for encryption.`, 20);
    await delay(150);

    printToTerminal("[*] Deriving base key...", 25);
    const unlockConcat = inputs.unlockAnswer1 + inputs.unlockAnswer2;
    await delay(100);

    printToTerminal("[*] Generating full key salt...", 38);
    const fullSalt = generateRandomHex(32);
    await delay(100);

    printToTerminal("[*] Selecting and permuting 9 Layer 2 questions...", 45);
    const numQuestions = inputs.normalizedAnswers.length;
    const allIndices = Array.from({ length: numQuestions }, (_, i) => i);
    const gateIndices = [inputs.unlockIndexes[0], inputs.unlockIndexes[1]];
    const layer2Indices = allIndices.filter(i => !gateIndices.includes(i));
    const selectedL2Indices = layer2Indices.sort(() => Math.random() - 0.5).slice(0, 6);
    const remainingL2Indices = layer2Indices.filter(i => !selectedL2Indices.includes(i));

    const fullConcat = [
      inputs.normalizedAnswers[gateIndices[0]],
      inputs.normalizedAnswers[gateIndices[1]],
      ...remainingL2Indices.map(i => inputs.normalizedAnswers[i]),
      ...selectedL2Indices.map(i => inputs.normalizedAnswers[i])
    ].join('');

    await delay(100);
    printToTerminal("[+] Selection and permutation complete. Encrypting vault contents...", 70);

    const argonSettings = {
      time: 4,
      mem: 4096,
      parallelism: 2,
      type: "Argon2id",
      hashLen: 32
    };

    let fullKey;
    try {
      console.log("[BUILD] fullConcat:", fullConcat);
      console.log("[BUILD] fullSalt:", fullSalt);
      console.log("[BUILD] argonSettings:", argonSettings);

      fullKey = await deriveKey(fullConcat, fullSalt, argonSettings);

      const exported = await crypto.subtle.exportKey("raw", fullKey);
      const fullKeyHex = Array.from(new Uint8Array(exported))
        .map(b => b.toString(16).padStart(2, '0')).join('');
      console.log("[BUILD] fullKey (hex):", fullKeyHex);
    } catch (err) {
      console.error("❌ Vault build failed during key derivation or export:", err);
      alert("Something went wrong while creating your vault.");
      return;
    }

    const payloads = await encryptVaultPayload(
      inputs,
      files,
      unlockConcat,
      fullConcat,
      fullSalt,
      selectedL2Indices,
      gateIndices,
      remainingL2Indices,
      argonSettings,
      fullKey
    );

    await delay(150);
    printToTerminal("[*] Preparing ZIP structure...", 80);
    await delay(100);

    printToTerminal("[*] Compressing and finalizing archive...", 90);
    await packageAndDownloadZip(
      payloads,
      unlockConcat,
      inputs,
      fullConcat,
      fullSalt,
      selectedL2Indices,
      gateIndices,
      payloads.layer1Salt,
      argonSettings
    );

    printToTerminal("[✔] Vault creation complete. Download should begin automatically.", 100);
    showPostBuildModal();
  } catch (err) {
    console.error("Vault build error:", err);
    printToTerminal(`[!] Error: ${err.message}`, null);
    showToast("Something went wrong while creating your vault.");
  }
}


async function loadUserInputs() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open("memoroVaultDB", 2);
    req.onerror = () => reject("Failed to open IndexedDB.");
    req.onsuccess = async () => {
      const db = req.result;
      const tx = db.transaction("vaultUserData", "readonly");
      const store = tx.objectStore("vaultUserData");
      const getReq = store.get("userData");

      getReq.onsuccess = () => {
        const data = getReq.result;
        if (!data) return reject("User data not found in IndexedDB.");

        const unlockAnswer1 = (data.answers[data.unlockIndexes[0]] || "").trim().toLowerCase();
        const unlockAnswer2 = (data.answers[data.unlockIndexes[1]] || "").trim().toLowerCase();

        const normalizedAnswers = data.answers.map((a, i) =>
          i === data.trapIndex ? "" : (a || "").trim().toLowerCase()
        );

        resolve({
          ...data,
          unlockAnswer1,
          unlockAnswer2,
          normalizedAnswers
        });

        db.close();
      };
      getReq.onerror = () => reject("Failed to read user data from IndexedDB.");
    };
  });
}

    async function loadIndexedFiles() {
      const uploadedMeta = JSON.parse(localStorage.getItem("uploadedFileMeta") || "[]");
      const db = await new Promise((resolve, reject) => {
        const req = indexedDB.open("memoroVaultDB", 2);
        req.onerror = () => reject("IndexedDB open failed");
        req.onsuccess = () => resolve(req.result);
      });

      const result = [];
      for (const meta of uploadedMeta) {
        const fileData = await new Promise((resolve, reject) => {
          const tx = db.transaction("vaultFiles", "readonly");
          const store = tx.objectStore("vaultFiles");
          const getReq = store.get(meta.id);
          getReq.onsuccess = () => resolve(getReq.result?.raw);
          getReq.onerror = () => reject("File read failed");
        });
        result.push({ ...meta, raw: fileData });
      }
      db.close();
      return result;
    }

    // getVaultKeyMaterial.js
function getVaultKeyMaterial({ gateAnswers, knownAnswers, bruteAnswers, gateIndices, knownAnswerIndices, bruteIndices, fullSalt }) {
  // Answers must be placed in the correct slot
  const allAnswers = [];
  const totalLen = gateIndices.length + knownAnswerIndices.length + bruteIndices.length;
  // Find max index
  const maxIndex = Math.max(...gateIndices, ...knownAnswerIndices, ...bruteIndices);
  for (let i = 0; i <= maxIndex; i++) allAnswers[i] = "";
  gateIndices.forEach((idx, i) => { allAnswers[idx] = gateAnswers[i]; });
  knownAnswerIndices.forEach((idx, i) => { allAnswers[idx] = knownAnswers[i]; });
  bruteIndices.forEach((idx, i) => { allAnswers[idx] = bruteAnswers[i]; });
  const fullConcat = allAnswers.join('');
  return fullSalt + fullConcat;
}

// blankRedHerring.js
function blankRedHerring(answers, trapIndex) {
  if (trapIndex !== undefined && trapIndex !== null && trapIndex >= 0 && trapIndex < answers.length) {
    answers = answers.slice();
    answers[trapIndex] = "";
  }
  return answers;
}
    // deriveKey.js
async function deriveKey(password, saltHex, settingsOverride) {

  const encoder = new TextEncoder();
  const passwordBytes = encoder.encode(password);
  const salt = saltHex
    ? Uint8Array.from(saltHex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)))
    : new Uint8Array(await crypto.subtle.digest('SHA-256', passwordBytes));
  const settings = settingsOverride || {
    time: 4,
    mem: 4096,
    parallelism: 2,
    type: 'Argon2id',
    hashLen: 32
  };
  const argonResult = await argon2.hash({
    pass: password,
    salt,
    time: settings.time,
    mem: settings.mem,
    parallelism: settings.parallelism,
    type: argon2.ArgonType[settings.type] || argon2.ArgonType.Argon2id,
    hashLen: settings.hashLen || 32
  });
  const keyBytes = new Uint8Array(
    argonResult.hashHex.match(/.{1,2}/g).map(byte => parseInt(byte, 16))
  );
  return crypto.subtle.importKey(
    'raw',
    keyBytes,
    { name: 'AES-GCM' },
    true,
    ['encrypt', 'decrypt']
  );
}

    // Add generatePermutations function from recover.html
    function generatePermutations(array) {
      if (array.length <= 1) return [array.slice()];
      const result = [];

      for (let i = 0; i < array.length; i++) {
        const current = array[i];
        const remaining = array.slice(0, i).concat(array.slice(i + 1));
        const perms = generatePermutations(remaining);
        for (const perm of perms) {
          result.push([current, ...perm]); // force copy
        }
      }

      return result;
    }

    async function encryptVaultPayload(userData, files, unlockConcat, fullConcat, fullSalt, selectedL2Indices, gateIndices, remainingL2Indices) {
  const encoder = new TextEncoder();

  // 🔐 Layer 1 key: used to encrypt question metadata
  const layer1Salt = generateRandomHex(32);
  const layer1Key = await deriveKey(unlockConcat, layer1Salt, {
    time: 4, mem: 4096, parallelism: 2, type: 'Argon2id', hashLen: 32
  });

  const questionList = userData.answers.map((ans, i) => {
  const trimmed = (ans || "").trim();
  const spaceIndexes = userData.spaceIndexes?.[i] || [];
  const hintEntry = userData.hints?.[i] || {};

  const showLength = typeof hintEntry.showLength === "boolean" ? hintEntry.showLength : true;

  let hintValuesLocal = Array.isArray(hintEntry.values)
    ? [...hintEntry.values]
    : Array.isArray(hintEntry.letters)
      ? hintEntry.letters.map(pos => {
          const char = trimmed[pos - 1];
          return char !== undefined ? char : "_";
        })
      : [];

  return {
    question: userData.questions[i] || `Question ${i + 1}`,
    // Only include the exact length if allowed; otherwise null
    expectedLength: showLength ? trimmed.length : null,
    hintLetters: [...(hintEntry.letters || [])],
    hintValues: hintValuesLocal,
    spaceIndexes: [...spaceIndexes],
    custom: typeof hintEntry.custom === "string"
      ? hintEntry.custom
      : Array.isArray(hintEntry.custom)
        ? hintEntry.custom.join(", ")
        : typeof hintEntry.custom === "object" && hintEntry.custom !== null
          ? JSON.stringify(hintEntry.custom)
          : "",
    // Optional: keep a copy for future UI logic (won’t break anything)
    showLength
  };
});


  // Encrypt question metadata
  const iv1 = crypto.getRandomValues(new Uint8Array(12));
  const encQuestions = encoder.encode(JSON.stringify({
    questionList,
    selectedL2Indices,
    remainingL2Indices,
    gateIndices
  }));
  const encData = await crypto.subtle.encrypt({ name: "AES-GCM", iv: iv1 }, layer1Key, encQuestions);
  const vaultEncrypted = {
    ciphertext: Array.from(new Uint8Array(encData)),
    iv: Array.from(iv1)
  };

  // 🔐 Choose a random permutation of selected L2 answers
  const permutations = generatePermutations(selectedL2Indices.map(i => userData.normalizedAnswers[i]));
  const randIndex = Math.floor(Math.random() * permutations.length);
  const finalPermutationUsed = permutations[randIndex];

  const permutedAnswers = [
    userData.normalizedAnswers[gateIndices[0]],
    userData.normalizedAnswers[gateIndices[1]],
    ...remainingL2Indices.map(i => userData.normalizedAnswers[i]),
    ...finalPermutationUsed
  ];

  const permutedConcat = permutedAnswers.join('');
  fullConcat = permutedConcat; // ✅ Use permuted concat going forward

  const fullKey = await deriveKey(fullConcat, fullSalt, {
    time: 4, mem: 4096, parallelism: 2, type: 'Argon2id', hashLen: 32
  });

  const vaultHashRaw = await sha256Hash(encoder.encode(fullConcat));
  const vaultHash = Array.from(vaultHashRaw).map(b => b.toString(16).padStart(2, '0')).join('');

  // 📦 Encrypt files
  const fileMeta = [];
  const encryptedFiles = [];

  async function encryptAndPushFile(buffer, name, mime) {
    const fileId = crypto.randomUUID().replace(/-/g, '');
    const internalFilename = fileId + ".vaultdoc";

    const fileSalt = new Uint8Array(await sha256Hash(encoder.encode(fullConcat + fileId)));
    const argonResult = await argon2.hash({
      pass: fullConcat + fileId,
      salt: fileSalt,
      time: 4,
      mem: 4096,
      parallelism: 2,
      type: 'Argon2id',
      hashLen: 32
    });

    const rawKey = argonResult.hash;
    const aesKey = await crypto.subtle.importKey("raw", rawKey, { name: "AES-GCM" }, false, ["encrypt"]);
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const encryptedBuffer = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, aesKey, buffer);

    const encryptedUint8 = new Uint8Array(encryptedBuffer);
    const encryptedBlob = new Blob([encryptedUint8], { type: "application/octet-stream" });

    const sha256 = Array.from(await sha256Hash(buffer)).map(b => b.toString(16).padStart(2, '0')).join('');

    fileMeta.push({
      id: fileId,
      filename: internalFilename,
      originalName: name,
      mimeType: mime,
      iv: Array.from(iv),
      sha256
    });

    encryptedFiles.push({
      filename: internalFilename,
      blob: encryptedBlob
    });

    if (encryptedBlob.size < 32) {
      console.warn(`⚠️ Warning: Encrypted blob for "${name}" is suspiciously small: ${encryptedBlob.size} bytes`);
    }
  }

  for (const file of files) {
    await encryptAndPushFile(new Uint8Array(file.raw), file.name, file.type);
  }

  const namedSeedFiles = JSON.parse(localStorage.getItem("namedSeedFiles") || "[]");
  for (const seed of namedSeedFiles) {
    await encryptAndPushFile(encoder.encode(seed.content), seed.name, "text/plain");
  }

  if (userData.finalMessage?.trim()) {
    await encryptAndPushFile(encoder.encode(userData.finalMessage.trim()), "final-message.txt", "text/plain");
  }

  // 🔒 Encrypt vault.meta
  const iv3 = crypto.getRandomValues(new Uint8Array(12));
  const metaEnc = encoder.encode(JSON.stringify({
    files: fileMeta,
    seedFiles: namedSeedFiles,
    vaultHash
  }));
  const metaData = await crypto.subtle.encrypt({ name: "AES-GCM", iv: iv3 }, fullKey, metaEnc);
  const fileMetaEncrypted = {
    data: new Uint8Array(metaData),
    iv: Array.from(iv3)
  };

  return {
    vaultEncrypted,
    fileMetaEncrypted,
    encryptedFiles,
    layer1Salt,
    vaultHash,
    selectedPermutation: finalPermutationUsed
  };
}

    async function packageAndDownloadZip(
  payloads,
  unlockConcat,
  userData,
  fullConcat,
  fullSalt,
  selectedL2Indices,
  gateIndices,
  layer1Salt,
  vaultHash,
  selectedPermutation
) {
  const writer = new zip.ZipWriter(new zip.BlobWriter("application/zip"));
  const addJSON = (name, data) => writer.add(name, new zip.TextReader(JSON.stringify(data, null, 2)));
  const addBlob = (name, blob) => writer.add(name, new zip.BlobReader(blob));

  await addJSON("vault.json", {
    version: "1.0.5",
    created: new Date().toISOString(),
    instructions: "Use recover.html to unlock this archive using your answers.",
    fullSalt,
    layer1Salt,
    questionPrompts: [
      userData.questions[gateIndices[0]] || `Question ${gateIndices[0] + 1}`,
      userData.questions[gateIndices[1]] || `Question ${gateIndices[1] + 1}`
    ],
    vaultMetaIv: payloads.fileMetaEncrypted.iv,
    argonSettings: {
      time: 4,
      mem: 4096,
      parallelism: 2,
      type: "Argon2id",
      hashLen: 32
    },
    selectedL2Answers: selectedPermutation
  });

  await addJSON("vault.enc", payloads.vaultEncrypted);
  await addBlob("vault.meta", new Blob([payloads.fileMetaEncrypted.data], { type: "application/octet-stream" }));
  for (const file of payloads.encryptedFiles) {
    await addBlob(file.filename, file.blob);
  }

await writer.add("README.txt", new zip.TextReader(`Memoro Vault
===========

Built with Memoro Vault version 1.0.5

This ZIP file contains an encrypted vault. To open it, you’ll need to answer a series of personal questions exactly as they were originally answered. No hints. No partial credit.

Six of those answers must also be entered in the correct order. If anything is off — even one character, or the order of those six — the vault will remain locked. There is no reset, no override, and no way to guess your way in.

This vault was secured using Argon2id encryption, designed to resist brute-force attacks even with modern hardware. It runs fully offline and does not depend on any server or cloud.

If you were meant to open this, you’ll know the answers. Be precise.

If you weren’t, there’s nothing you can do.

— Kaŝmaristo Delvakto  
"Libereco ne estas donaco. Ĝi estas devo."

---

## How to Open the Vault

1. **Locate the Memoro Vault app**  
   In this ZIP file, look for a file like \`memoro-win.exe\`, \`memoro-linux.AppImage\`, or \`memoro-mac.dmg\`, depending on your device.

2. **Run the app**  
   No installation needed. Just open the file. If your system asks if you trust it, say yes — assuming you trust the person who gave you this.

3. **Click "Recover Vault"**  
   Choose this same ZIP file when prompted.

4. **Enter the answers**  
   Type the answers exactly as they were saved — all lowercase, no extra spaces. The vault will only open if everything is correct.

If you succeed, you’ll see the contents.  
If you don’t, keep trying — but there are no clues and no second paths.

What matters now is what you remember.
`));

await writer.add("Vault_Builder_Instructions.txt", new zip.TextReader(`Vault Builder Instructions
==========================

Make a folder, place this ZIP and the Memoro Vault installer in it. Duplicate that folder to:
- M-DISC
- Offline SSD or USB
- Cloud backup

Do not modify this archive. It is fragile by design. Even one flipped byte will break decryption.

Libereco ne estas donaco. Ĝi estas devo.
— Kaŝmaristo Delvakto`));

  const blob = await writer.close();
  const link = document.createElement("a");
  link.href = URL.createObjectURL(blob);
  link.download = "memoro-vault.zip";
  link.click();
}

    function showBackupMessage(url) {
      const msg = document.createElement('p');
      msg.innerHTML = `If your download didn’t start, <a href="${url}" download="memoro-vault.zip">click here to download manually</a>.`;
      msg.style.color = '#aaa';
      msg.style.fontSize = '16px';
      msg.style.marginTop = '30px';
      document.body.appendChild(msg);
    }


function retryDownload() {
  window.location.reload();
}

    const canvas = document.getElementById('matrixCanvas');
    const ctx = canvas.getContext('2d');

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const letters = 'モヤユヨラリルレロワヲンABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890@$%&'.split('');
    const fontSize = 14;
    const columns = canvas.width / fontSize;
    const drops = Array(Math.floor(columns)).fill(1);

    function draw() {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = '#0F0';
      ctx.font = fontSize + 'px monospace';

      for (let i = 0; i < drops.length; i++) {
        const text = letters[Math.floor(Math.random() * letters.length)];
        ctx.fillText(text, i * fontSize, drops[i] * fontSize);

        if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
          drops[i] = 0;
        }

        drops[i]++;
      }
    }

    setInterval(draw, 40);
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });

    function preserveAndGoBack() {
  preserveOnBack = true;
  history.back();
}

window.addEventListener("beforeunload", (e) => {
  if (!preserveOnBack) {
    nukeEverything();
  }
});
      
async function nukeEverything() {
  try {
    localStorage.clear();
    sessionStorage.clear();
    if (indexedDB.databases) {
      const dbs = await indexedDB.databases();
      for (const db of dbs) {
        indexedDB.deleteDatabase(db.name);
      }
    } else {
      indexedDB.deleteDatabase("memoroVaultVaultStorage");
      indexedDB.deleteDatabase("memoroVaultDB");
    }
    console.log("Memoro Vault: Local memory wiped.");
  } catch (err) {
    console.warn("Memoro Vault wipe failed:", err);
  }
}

function showPostBuildModal() {
  const modal = document.getElementById("postBuildModal");
  document.body.style.overflow = "hidden"; // Prevent body scroll behind modal
  if (modal) {
    modal.style.display = "flex"; // Use flex to keep it centered and scrollable
  }
}

function closePostBuildModal() {
  const modal = document.getElementById("postBuildModal");
  if (modal) {
    document.body.style.overflow = ""; 
    modal.style.display = "none";
    setTimeout(() => {
      nukeEverything(); // ✅ add this
      window.location.href = "dashboard.html";
    }, 300);
  }
}

  </script>
</body> 
</html>