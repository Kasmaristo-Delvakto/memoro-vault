<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Building Your Vault - Memoro Vault</title>
  <script src="https://unpkg.com/@zip.js/zip.js@2.6.60/dist/zip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
  <style>

    #powActions button {
  background-color: #222;
  color: #0f0;
  border: 1px solid #0f0;
  padding: 10px 20px;
  border-radius: 5px;
  font-family: 'Fira Code', monospace;
  font-size: 14px;
  cursor: pointer;
  transition: background-color 0.3s ease;
}
#powActions button:hover {
  background-color: #0f0;
  color: #000;
}

    #powPanel {
  display: none;
  position: fixed;
  top: 0; left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.65);
  color: #0f0;
  font-family: 'Fira Code', monospace;
  z-index: 2000;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
}
#powPanel.visible {
  display: flex;
}

.pow-panel {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.88); /* semi-transparent */
  z-index: 1; /* ensures it's ABOVE the matrix */
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  color: #0f0;
  font-family: 'Fira Code', monospace;
}

#matrixCanvas {
  position: fixed;
  top: 0;
  left: 0;
  z-index: 0;
  width: 100vw;
  height: 100vh;
  pointer-events: none;
  opacity: 0.35;
}

/* Style your PoW panel */
.pow-panel {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.88);  /* ‚¨Ö transparent black lets Matrix show */
  color: #0f0;
  z-index: 1;  /* ABOVE matrix canvas */
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
  font-family: 'Fira Code', monospace;
}

.pow-panel button {
  background-color: #111;
  color: #0f0;
  border: 1px solid #0f0;
  padding: 10px 18px;
  border-radius: 5px;
  font-family: 'Fira Code', monospace;
  font-size: 14px;
  cursor: pointer;
}

.pow-panel button:hover {
  background-color: #0f0;
  color: #000;
}

    body {
      background-color: #111;
      color: #eee;
      font-family: 'Fira Code', monospace;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      overflow: hidden;
    }
    #terminal {
      background-color: #000;
      color: #00ff00;
      padding: 20px;
      width: 100vw;
      height: 100vh;
      overflow-y: auto;
      box-shadow: inset 0 0 20px #00ff00;
      font-size: 14px;
      white-space: pre-wrap;
    }

    #powDifficultyModal {
  position: fixed;
  top: 0; left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.95);
  color: #0f0;
  font-family: 'Fira Code', monospace;
  display: flex; /* ‚úÖ Important: ensure it's visible by default */
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
  z-index: 1000;
}

    #downloadBtn {
      display: none;
      margin-top: 20px;
      padding: 12px 24px;
      font-size: 16px;
      border: none;
      border-radius: 6px;
      background-color: #00aa00;
      color: #fff;
      cursor: pointer;
    }
    #downloadBtn:hover {
      background-color: #007700;
    }
    @keyframes pulseGlow {
  0%   { filter: drop-shadow(0 0 5px #0f0); }
  50%  { filter: drop-shadow(0 0 20px #0f0); }
  100% { filter: drop-shadow(0 0 5px #0f0); }
}

#actionButtons button {
  background-color: #222;
  color: #0f0;
  border: 1px solid #0f0;
  padding: 10px 18px;
  border-radius: 5px;
  font-family: 'Fira Code', monospace;
  font-size: 14px;
  cursor: pointer;
}
#actionButtons button:hover {
  background-color: #0f0;
  color: #000;
}
#vaultContainer {
  display: flex;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
}

#terminal {
  width: 50%;
  height: 100vh;
  overflow-y: auto;
  background-color: #000;
  color: #0f0;
  padding: 20px;
  box-shadow: inset 0 0 20px #0f0;
  font-size: 14px;
  white-space: pre-wrap;
  font-family: 'Fira Code', monospace;
}

#logoSection {
  width: 50%;
  height: 100%;
  background-color: #111;
  display: flex;
  justify-content: center;
  align-items: center;
}

#logoContent {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  opacity: 0;
  transition: opacity 1s ease;
}

#memoroLogo {
  max-width: 80%;
  max-height: 60%;
  filter: drop-shadow(0 0 10px #0f0);
  animation: pulseGlow 3s infinite;
  margin-bottom: 30px;
  margin-top: 30px;
}

#actionButtons {
  display: flex;
  flex-direction: column;
  gap: 20px;
  opacity: 0;
  transition: opacity 1s ease;
}

#actionButtons button {
  background-color: #222;
  color: #0f0;
  border: 1px solid #0f0;
  padding: 10px 18px;
  border-radius: 5px;
  font-family: 'Fira Code', monospace;
  font-size: 14px;
  cursor: pointer;
}

#actionButtons button:hover {
  background-color: #0f0;
  color: #000;
}

.powOption {
  background-color: #111;
  border: 1px solid #0f0;
  color: #0f0;
  padding: 10px 18px;
  font-size: 14px;
  border-radius: 4px;
  cursor: pointer;
}
.powOption:hover {
  background-color: #0f0;
  color: #000;
}


  </style>
</head>
<body>
<canvas id="matrixCanvas" style="
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  z-index: 0;
  background: black;
"></canvas>

  <div id="vaultContainer">
    <pre id="terminal">Initializing Memoro Vault Builder...</pre>
  
    <div id="logoSection">
      <div id="logoContent">
        <img id="memoroLogo" src="assets/memoro-logo-with-words.png" alt="Memoro Vault">
        <div id="actionButtons">
          <button onclick="preserveAndGoBack()">Back to Answers</button>
          <button onclick="retryDownload()">Retry Download</button>
          <button onclick="window.location.href='dashboard.html'">Return to Dashboard</button>
        </div>
      </div>
    </div>
  </div>

  <div id="powPanel" class="pow-panel">
<div style="margin-bottom: 25px;">
  <img src="assets/Screenshot (691).png" alt="Monero Donation QR" style="width: 150px; border: 2px solid #0f0; border-radius: 8px; box-shadow: 0 0 8px #0f0;">
  <p style="margin-top: 8px; font-size: 14px; color: #aaa;">
    Memoro Vault is a gift to the world. <br> I have spent hundreds of hours developing it. <br> If you find it valuable, consider sending a small tip in XMR. <br> Thank youüíö
  </p>
</div>
    <h3 style="margin-bottom: 10px; font-size: 20px;">Solving Proof of Work...</h3>
  <p id="powStatus" style="margin: 8px 0;">Initializing...</p>
  <p id="powNonce" style="margin: 4px 0;">Nonce: ‚Äî</p>
  <p id="powHash" style="margin: 4px 0;">Hash: ‚Äî</p>
  <p id="powElapsed" style="margin: 4px 0;">Elapsed: 0s</p>

  <div id="powActions" style="margin-top: 30px; display: flex; flex-direction: column; gap: 12px;">
    <button onclick="history.back()">Back to Answers</button>
    <button onclick="window.location.href='dashboard.html'">Return to Dashboard</button>
  </div>
</div>




  
  <script>
    let preserveOnBack = false;
    let vaultBuildManuallyTriggered = false;
    let selectedPowDifficulty = "000000"; // default to 6

document.addEventListener("DOMContentLoaded", () => {
  const modal = document.getElementById("powDifficultyModal");
  modal.style.display = "flex"; // show modal on load

  const options = document.querySelectorAll(".powOption");
  options.forEach(btn => {
    btn.addEventListener("click", () => {
  const zeros = parseInt(btn.dataset.diff);
  selectedPowDifficulty = "0".repeat(zeros);
  vaultBuildManuallyTriggered = true;
  modal.style.display = "none";
  startVaultBuild();
    });
  });
});

    const terminal = document.getElementById("terminal");

    function printToTerminal(line, delay = 30) {
      return new Promise(resolve => {
        let i = 0;
        const interval = setInterval(() => {
          terminal.textContent += line[i] || '';
          terminal.scrollTop = terminal.scrollHeight;
          i++;
          if (i >= line.length) {
            clearInterval(interval);
            terminal.textContent += '\n';
            resolve();
          }
        }, delay);
      });
    }

    function showToast(msg) {
      alert(msg);
    }

    async function delay(ms) {
      return new Promise(res => setTimeout(res, ms));
    }

    async function streamTerminalLogs() {
      const lines = [
"Processing highly personal information...",
"[analyzing] Childhood regrets, weird dreams, passwords you barely remember...",
"[connecting] Uploading to the dark web and selling to the highest bidder...",
"[told you so] Remember when I told you to turn off your wifi? ...should have listened.",
"[panic] Wait ‚Äî you didn‚Äôt want your data sold?!",
"[reversing] Aborting data auction. Shredding all traces. I‚Äôm not *that* kind of program.",
"[serious] Come on. Give me some credit. I encrypt ‚Äî I don‚Äôt snitch.",
"[finishing] Almost done. Just writing your secrets onto an invisible stone tablet.",
"[complete] Vault locked. Private. Permanent. Untraceable. Like it should be.",
"[soft] Look at you ‚Äî protecting your future like it matters. It does.",
"[closing] I like you. Don‚Äôt die.",
"[donate] You should really support this dev before he gives up and starts working for BlackRock üíö",
"[ramen] He‚Äôs still living off store-brand ramen and European Monero Cheese. Throw him a bone.",
"https://boatingaccidentapparel.com/memoro-vault/ \n",
      ];
      for (const line of lines) {
        await printToTerminal(line);
        document.getElementById('logoContent').style.opacity = 1;
setTimeout(() => {
  document.getElementById('actionButtons').style.opacity = 1;
}, 200);

        await delay(300 + Math.random() * 200);
      }
    }

    async function generatePowSalt(unlockKey) {
  const encoder = new TextEncoder();
  const hash = await crypto.subtle.digest("SHA-256", encoder.encode(unlockKey));
  return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).slice(0, 16).join('');
}

function generatePowChallenge() {
  const bytes = crypto.getRandomValues(new Uint8Array(8));
  return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
}

async function startVaultBuild() {
  if (!vaultBuildManuallyTriggered) {
    console.warn("Prevented auto-start of vault build.");
    return;
  }

  try {
    await streamTerminalLogs();
    await printToTerminal("[*] Loading user input...");
    await delay(500);

    const inputs = await loadUserInputs();

    await printToTerminal("[+] User data loaded. Preparing vault structure...");
    await delay(500);

    const files = await loadIndexedFiles();
    await printToTerminal(`[+] Found ${files.length} file(s) for encryption.`);
    await delay(500);

    await printToTerminal("[*] Deriving encryption key...");
    const key = await deriveKey(inputs.unlockAnswer1 + inputs.unlockAnswer2);
    await delay(500);

    await printToTerminal("[+] Key ready. Encrypting vault metadata...");
const powSalt = await generatePowSalt(inputs.unlockAnswer1 + inputs.unlockAnswer2);
const powChallengeHex = generatePowChallenge();
const powNonce = await mineValidNonce(powSalt + powChallengeHex + inputs.fullConcat, selectedPowDifficulty);
const fullKeyMaterial = powSalt + powChallengeHex + inputs.fullConcat + powNonce;
const fullAnswerKey = await deriveKey(fullKeyMaterial);

const payloads = await encryptVaultPayload(inputs, files, fullAnswerKey);

    await delay(500);

    await printToTerminal("[+] Encryption complete. Packaging vault...");
    await delay(500);

    await packageAndDownloadZip(payloads, inputs.unlockAnswer1 + inputs.unlockAnswer2, inputs, powSalt, powChallengeHex, powNonce);
    await printToTerminal("[‚úî] Vault creation complete. Download should begin automatically.");

    // Cleanup if needed
  } catch (err) {
    console.error("Vault build error:", err);
    await printToTerminal(`[!] Error: ${err.message}`);
    showToast("Something went wrong while creating your vault.");
  }
}

async function loadUserInputs() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open("memoroVaultDB", 2);
    req.onerror = () => reject("Failed to open IndexedDB.");
    req.onsuccess = async () => {
      const db = req.result;
      const tx = db.transaction("vaultUserData", "readonly");
      const store = tx.objectStore("vaultUserData");
      const getReq = store.get("userData");

      getReq.onsuccess = () => {
        const data = getReq.result;
        if (!data) return reject("User data not found in IndexedDB.");

        const unlockAnswer1 = (data.answers[data.unlockIndexes[0]] || "").trim().toLowerCase();
        const unlockAnswer2 = (data.answers[data.unlockIndexes[1]] || "").trim().toLowerCase();
        const fullConcat = data.answers.map(a => (a || "").trim().toLowerCase()).join("");

        resolve({
          ...data,
          unlockAnswer1,
          unlockAnswer2,
          fullConcat
        });

        db.close();
      };
      getReq.onerror = () => reject("Failed to read user data from IndexedDB.");
    };
  });
}

    async function loadIndexedFiles() {
      const uploadedMeta = JSON.parse(localStorage.getItem("uploadedFileMeta") || "[]");
      const db = await new Promise((resolve, reject) => {
        const req = indexedDB.open("memoroVaultDB", 2);
        req.onerror = () => reject("IndexedDB open failed");
        req.onsuccess = () => resolve(req.result);
      });

      const result = [];
      for (const meta of uploadedMeta) {
        const fileData = await new Promise((resolve, reject) => {
          const tx = db.transaction("vaultFiles", "readonly");
          const store = tx.objectStore("vaultFiles");
          const getReq = store.get(meta.id);
          getReq.onsuccess = () => resolve(getReq.result?.raw);
          getReq.onerror = () => reject("File read failed");
        });
        result.push({ ...meta, raw: fileData });
      }
      db.close();
      return result;
    }

    async function deriveKey(password) {
      const enc = new TextEncoder();
      const salt = await crypto.subtle.digest("SHA-256", enc.encode(password));
      const keyMaterial = await crypto.subtle.importKey("raw", enc.encode(password), "PBKDF2", false, ["deriveKey"]);
      return crypto.subtle.deriveKey({
        name: "PBKDF2",
        salt,
        iterations: 150000,
        hash: "SHA-256"
      }, keyMaterial, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]);
    }

    
    async function encryptVaultPayload(userData, files, fullAnswerKey) {
  const encoder = new TextEncoder();
  const layer1Key = await deriveKey(userData.unlockAnswer1 + userData.unlockAnswer2);

  const questionList = [];
  for (let i = 0; i < userData.questionCount; i++) {
    const answer = (userData.answers[i] || "").trim().toLowerCase();
    const clean = answer.replace(/\s/g, "");
    const hintData = userData.hints[i] || {};
    const hintLetters = hintData.letters || [];
    const spaceIndexes = [...answer].map((c, i) => c === " " ? i : -1).filter(i => i !== -1);
    const hintValues = hintLetters.map(p => (p >= 1 && p <= clean.length) ? clean[p - 1] : "_");

    const hashedAnswer = Array.from(new Uint8Array(await crypto.subtle.digest("SHA-256", encoder.encode(answer))))
      .map(b => b.toString(16).padStart(2, '0')).join('');

    questionList.push({
      question: userData.questions[i] || `Question ${i + 1}`,
      expectedLength: answer.length,
      letterRule: hintLetters.length ? "partial reveal" : "full answer",
      hintLetters,
      hintValues,
      spaceIndexes,
      custom: hintData.custom || "",
      hash: hashedAnswer,
      correctSeedWord: userData.seeds[i] || ""
    });
  }

  // üîí Encrypt vault.enc (question metadata)
  const iv1 = crypto.getRandomValues(new Uint8Array(12));
  const encodedQuestions = encoder.encode(JSON.stringify({ questionList }));
  const encryptedQuestions = await crypto.subtle.encrypt({ name: "AES-GCM", iv: iv1 }, layer1Key, encodedQuestions);
  const vaultEnc = {
    ciphertext: Array.from(new Uint8Array(encryptedQuestions)),
    iv: Array.from(iv1)
  };

  // üîí Encrypt files
  const encryptedFiles = [];
  const fileMeta = [];

  // 1. Named seed phrase .txt files
  const namedSeedFiles = JSON.parse(localStorage.getItem("namedSeedFiles") || "[]");
  for (const entry of namedSeedFiles) {
    const fakeId = crypto.randomUUID();
    const fileKey = await deriveKey(userData.fullConcat + fakeId);
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const raw = encoder.encode(entry.content);
    const ciphertext = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, fileKey, raw);
    const filename = `${fakeId}.vaultdoc`;

    encryptedFiles.push({
      filename,
      blob: new Blob([new Uint8Array(ciphertext)], { type: "application/octet-stream" })
    });

    const hash = await crypto.subtle.digest("SHA-256", raw);
    fileMeta.push({
      filename,
      originalName: entry.name,
      mimeType: "text/plain",
      size: raw.length,
      sha256: Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).join(''),
      iv: Array.from(iv)
    });
  }

  // 2. Uploaded files from IndexedDB
  for (const file of files) {
    const fileKey = await deriveKey(userData.fullConcat + file.id);
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const ciphertext = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, fileKey, file.raw);

    encryptedFiles.push({
      filename: `${file.id}.vaultdoc`,
      blob: new Blob([new Uint8Array(ciphertext)], { type: "application/octet-stream" })
    });

    const rawBuffer = file.raw instanceof ArrayBuffer ? file.raw : await file.raw.arrayBuffer();
    const hash = await crypto.subtle.digest("SHA-256", rawBuffer);
    fileMeta.push({
      filename: `${file.id}.vaultdoc`,
      originalName: file.name,
      mimeType: file.type,
      size: file.size,
      sha256: Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).join(''),
      iv: Array.from(iv)
    });
  }

  // 3. Final message as encrypted vaultdoc file
  if (userData.finalMessage?.trim()) {
    const fakeId = crypto.randomUUID();
    const fileKey = await deriveKey(userData.fullConcat + fakeId);
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const raw = encoder.encode(userData.finalMessage.trim());
    const ciphertext = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, fileKey, raw);
    const filename = `${fakeId}.vaultdoc`;

    encryptedFiles.push({
      filename,
      blob: new Blob([new Uint8Array(ciphertext)], { type: "application/octet-stream" })
    });

    const hash = await crypto.subtle.digest("SHA-256", raw);
    fileMeta.push({
      filename,
      originalName: "final_message.txt",
      mimeType: "text/plain",
      size: raw.length,
      sha256: Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).join(''),
      iv: Array.from(iv)
    });
  }

  // üîí Encrypt metadata
  const iv3 = crypto.getRandomValues(new Uint8Array(12));
  const encodedMeta = encoder.encode(JSON.stringify({ files: fileMeta }));
  const encryptedMeta = await crypto.subtle.encrypt({ name: "AES-GCM", iv: iv3 }, fullAnswerKey, encodedMeta);
  const fileMetaEncrypted = {
    data: new Uint8Array(encryptedMeta),
    iv: Array.from(iv3)
  };

  return {
    vaultEncrypted: vaultEnc,
    fileMetaEncrypted,
    encryptedFiles
  };
}

async function packageAndDownloadZip(payloads, unlockKey, userData, powSalt, powChallengeHex, powNonce) {
  const writer = new zip.ZipWriter(new zip.BlobWriter("application/zip"));
  const addJSON = (name, data) => writer.add(name, new zip.TextReader(JSON.stringify(data, null, 2)));
  const addBlob = (name, blob) => writer.add(name, new zip.BlobReader(blob));

// Combine with correct answers for mining
const combined = powSalt + powChallengeHex + userData.fullConcat;
const powDifficulty = selectedPowDifficulty;
const powIncreaseEvery = 5;

await printToTerminal(`[*] Mining nonce at difficulty '${powDifficulty}'...`);
await delay(500); // Give UI time to update terminal before blocking

// Now show the PoW overlay (here, not inside mineValidNonce)
document.getElementById("powPanel").classList.add("visible");
powPanel.style.display = "flex";

  // Add vault.json
  await addJSON("vault.json", {
  version: "2.1",
  created: new Date().toISOString(),
  instructions: "Use recover.html to unlock this archive using your answers.",
  unlockQuestions: {
    question1: userData.unlockIndexes[0],
    question2: userData.unlockIndexes[1]
  },
  powSalt,
  powChallengeSalt: powChallengeHex,
  powDifficulty,
  powNonce,
  powIncreaseEvery,
  questionPrompts: [
    userData.questions[userData.unlockIndexes[0]] || `Question ${userData.unlockIndexes[0] + 1}`,
    userData.questions[userData.unlockIndexes[1]] || `Question ${userData.unlockIndexes[1] + 1}`
  ],
  vaultMetaIv: payloads.fileMetaEncrypted.iv
});


  await addJSON("vault.enc", {
    ciphertext: Array.from(payloads.vaultEncrypted.ciphertext),
    iv: payloads.vaultEncrypted.iv
  });

  await addBlob("vault.meta", new Blob([payloads.fileMetaEncrypted.data], { type: "application/octet-stream" }));

  for (const f of payloads.encryptedFiles) {
    await addBlob(f.filename, f.blob);
  }

  await addJSON("README.txt", {
    message: "Use recover.html with your answers to unlock this archive. There is no backdoor."
  });

  const finalBlob = await writer.close();
  const url = URL.createObjectURL(finalBlob);
  const link = document.createElement("a");
  link.href = url;
  link.download = "memoro-vault.zip";
  link.click();
}

async function mineValidNonce(baseInput, difficulty) {
  const encoder = new TextEncoder();
  const powStatus = document.getElementById("powStatus");
  const powNonce = document.getElementById("powNonce");
  const powHash = document.getElementById("powHash");
  const powElapsed = document.getElementById("powElapsed");

  powStatus.textContent = `Mining for hash starting with "${difficulty}"...`;
  let nonce = 0;
  let start = performance.now();

  while (true) {
    const input = baseInput + nonce;
    const hash = CryptoJS.SHA256(input).toString();

    // Update UI every 10,000 tries
    if (nonce % 10000 === 0) {
      const elapsed = ((performance.now() - start) / 1000).toFixed(1);
      powNonce.textContent = `Nonce: ${nonce}`;
      powHash.textContent = `Hash: ${hash.slice(0, 16)}...`;
      powElapsed.textContent = `Elapsed: ${elapsed}s`;
      await new Promise(r => setTimeout(r)); // Yield to UI
    }

    if (hash.startsWith(difficulty)) {
      const totalElapsed = ((performance.now() - start) / 1000).toFixed(1);
      powStatus.textContent = `Solved after ${nonce} attempts in ${totalElapsed}s!`;
      powNonce.textContent = `Nonce: ${nonce}`;
      powHash.textContent = `Hash: ${hash}`;
      powElapsed.textContent = `Total Time: ${totalElapsed}s`;
      return nonce.toString();
    }

    nonce++;
  }
}


    function showBackupMessage(url) {
  const msg = document.createElement('p');
  msg.innerHTML = `‚¨áÔ∏è If your download didn‚Äôt start, <a href="${url}" download="memoro-vault.zip">click here to download manually</a>.`;
  msg.style.color = '#aaa';
  msg.style.fontSize = '16px';
  msg.style.marginTop = '30px';
  document.body.appendChild(msg);
}


function retryDownload() {
  window.location.reload();
}

</script>

<!-- PoW Difficulty Selection Modal -->
<div id="powDifficultyModal">
  <h2 style="margin-bottom: 20px;">Select Proof of Work Difficulty</h2>
  <p style="max-width: 600px; text-align: center; margin-bottom: 20px; font-size: 15px;">
<p style="max-width: 700px; text-align: center; margin-bottom: 20px; font-size: 15px;">
  Memoro Vault uses proof-of-work to protect your data during recovery.<br/>
  Every time someone tries to unlock the vault, their device must solve a small puzzle ‚Äî and it only works if the answers are correct.<br/><br/>
  A higher difficulty makes it much harder for hackers to guess answers, because each wrong attempt takes more time and computing power.<br/><br/>
  <strong>Choose a difficulty between 4 and 9:</strong><br/>
  4 is fast and still secure for personal use.<br/>
  6‚Äì7 is great for serious protection with reasonable delay.<br/>
  8 is highly secure and ideal for sensitive or long-term storage.<br/>
  9 is for paranoids, whistleblowers, or people who name their vaults "DO NOT OPEN UNDER ANY CIRCUMSTANCES."
</p>
  </p>
  <div style="display: flex; gap: 15px; margin-bottom: 30px;">
    <button class="powOption" data-diff="4">4 zeros (‚âà1‚Äì3 sec)</button>
    <button class="powOption" data-diff="5">5 zeros (‚âà3‚Äì8 sec)</button>
    <button class="powOption" data-diff="6">6 zeros (‚âà10‚Äì30 sec)</button>
    <button class="powOption" data-diff="7">7 zeros (‚âà1‚Äì2 min)</button>
    <button class="powOption" data-diff="8">8 zeros (‚âà5‚Äì15 min)</button>
    <button class="powOption" data-diff="9">9 zeros (‚âà1 hr+)</button>
  </div>
  <p style="font-size: 13px; color: #888;">Note: Vault creation may appear frozen at high difficulty. Please wait.</p>
</div>

<script>
  const canvas = document.getElementById('matrixCanvas');
  const ctx = canvas.getContext('2d');

  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  const letters = '„Ç¢„Ç°„Ç§„Ç£„Ç¶„É¥„Ç®„Çß„Ç™„Ç´„Ç¨„Ç≠„ÇÆ„ÇØ„Ç∞„Ç±„Ç≤„Ç≥„Ç¥„Çµ„Ç∂„Ç∑„Ç∏„Çπ„Ç∫„Çª„Çº„ÇΩ„Çæ„Çø„ÉÄ„ÉÅ„ÉÉ„ÉÇ„ÉÖ„ÉÜ„Éá„Éà„Éâ„Éä„Éã„Éå„Éç„Éé„Éè„Éê„Éë„Éí„Éì„Éî„Éï„Éñ„Éó„Éò„Éô„Éö„Éõ„Éú„Éù„Éû„Éü„É†„É°„É¢„É§„É¶„É®„É©„É™„É´„É¨„É≠„ÉØ„É≤„É≥ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'.split('');
  const fontSize = 14;
  const columns = canvas.width / fontSize;
  const drops = Array(Math.floor(columns)).fill(1);

  function draw() {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = '#0F0';
    ctx.font = fontSize + 'px monospace';

    for (let i = 0; i < drops.length; i++) {
      const text = letters[Math.floor(Math.random() * letters.length)];
      ctx.fillText(text, i * fontSize, drops[i] * fontSize);

      if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
        drops[i] = 0;
      }

      drops[i]++;
    }
  }

  setInterval(draw, 40);
  window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  });

  function preserveAndGoBack() {
  preserveOnBack = true;
  history.back();
}

window.addEventListener("beforeunload", () => {
  if (!preserveOnBack) {
    try {
      // Clear local and session storage
      localStorage.clear();
      sessionStorage.clear();

      // Delete all IndexedDB databases
      if (indexedDB?.databases) {
        indexedDB.databases().then(dbs => {
          for (const db of dbs) {
            if (db.name) indexedDB.deleteDatabase(db.name);
          }
        });
      }
    } catch (err) {
      console.warn("Cleanup on unload failed:", err);
    }
  }
});

</script>
</body> 
</html>
<!-- This HTML file is a simple vault builder for the Memoro Vault project. It initializes the vault, encrypts user data, and packages it into a downloadable ZIP file. The code includes functions for handling user input, encryption, and file management using IndexedDB. The UI is styled to resemble a terminal interface. -->
